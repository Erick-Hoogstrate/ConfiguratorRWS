<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fact</name>
    </assembly>
    <members>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.MakeMultiBooleanShapeDPolygon2D(u040.prespective.math.doubles.DPolygon2D,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D})">
            <summary>
            makes hulls from main while removing the subtraction hulls
            </summary>
            <param name="_main">main hull to do the subtractions on</param>
            <param name="_subtractionHulls">the hulls to subtract</param>
            <returns>hulls created form the subtractions</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.ClipMultiBooleanShapeDPolygon2D(u040.prespective.math.doubles.DPolygon2D,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D})">
            <summary>
            makes clipped hulls of DPolygon
            </summary>
            <param name="_main">main object to get its clipping hulls</param>
            <param name="_others"></param>
            <returns>the clipping hulls</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.baseMultiBooleanShapeDPolygon2D(u040.prespective.math.doubles.DPolygon2D,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Boolean)">
            <summary>
            makes hulls from main while removing the subtraction hulls
            </summary>
            <param name="_main">main hull to do the subtractions on</param>
            <param name="_subtractionHulls">the hulls to subtract</param>
            <returns>hulls created form the subtractions</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.checkIfCompletelyInsideAnSubtractionPolygon(u040.prespective.math.doubles.DVector2[],System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D})">
            <summary>
            checks if the main is completely inside a subtraction hull
            </summary>
            <param name="_verticesMain">vertices main</param>
            <param name="_subtractionHulls">the hulls to subtract</param>
            <returns>if completely inside a subtraction hull</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.firstInsidePolygon(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D})">
            <summary>
            determines if the first point is inside the polygon
            </summary>
            <param name="_firstPoint">first point</param>
            <param name="_secondPoint">second point</param>
            <param name="_subtractionHulls">the hulls to subtract</param>
            <returns>if first point is inside polygon</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.getCutLineData(u040.prespective.math.doubles.DVector2[],System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[]}@)">
            <summary>
            gets the cut line data of both the main and the subtraction hulls
            </summary>
            <param name="_verticesMain">vertices of the main</param>
            <param name="_subtractionHulls">subtraction hulls</param>
            <param name="_lineDataSubtractions">subtraction hulls cut line data</param>
            <returns>main cut line data</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.processCuttingLineGoingOverMain(u040.prespective.math.doubles.DVector2,u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData,System.Int32,System.Int32,u040.prespective.math.doubles.DPolygon2D,u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[],System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[]},System.Boolean[][]@)">
            <summary>
            determines points by going over the main lines
            </summary>
            <param name="_beginPoint">point that began this check</param>
            <param name="_currentMainLineData">data of current line of main</param>
            <param name="_indexLine">index current main line</param>
            <param name="_indexCutLine">index current cut point</param>
            <param name="_main">main polygon</param>
            <param name="_lineDataMain">main line data</param>
            <param name="_subtractionHulls">subtraction polygons</param>
            <param name="_lineDataSubtractions">subtractions line data</param>
            <param name="_usedCutLinesMain">check that indicates is a main line cut data was already used</param>
            <returns>created polygon</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.processCuttingLineGoingOverSubtraction(u040.prespective.math.doubles.DVector2,System.Int32,System.Int32,u040.prespective.math.doubles.DPolygon2D,u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[],System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[]},System.Boolean[][]@)">
            <summary>
            determines points by going over the subtraction lines
            </summary>
            <param name="_beginPoint">point that began this check</param>
            <param name="_lineIndexToCheckMain">index of main line</param>
            <param name="_cutIndexTocheckMain">index of main line</param>
            <param name="_main">main polygon</param>
            <param name="_lineDataMain">main line data</param>
            <param name="_subtractionHulls">subtraction polygons</param>
            <param name="_lineDataSubtractions">subtractions line data</param>
            <param name="_usedCutLinesMain">check that indicates is a main line cut data was already used</param>
            <returns>created polygon</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.backwardMovingAlongSubstraction(System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DPolygon2D,u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[],System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[]},System.Boolean[][]@)">
            <summary>
            moving backwardly along a subtraction line
            </summary>
            <param name="_indexSubtraction">index of subtraction hull</param>
            <param name="_indexVertSub">vert index of subtraction</param>
            <param name="_beginPoint">point that began this check</param>
            <param name="_main">main polygon</param>
            <param name="_lineDataMain">main line data</param>
            <param name="_subtractionHulls">subtraction polygons</param>
            <param name="_lineDataSubtractions">subtractions line data</param>
            <param name="_usedCutLinesMain">check that indicates is a main line cut data was already used</param>
            <returns>created polygon</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.forwardMovingAlongSubstraction(System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DPolygon2D,u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[],System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[]},System.Boolean[][]@)">
            <summary>
            moving forwardly along a subtraction line
            </summary>
            <param name="_indexSubtraction">index of subtraction hull</param>
            <param name="_indexVertSub">vert index of subtraction</param>
            <param name="_beginPoint">point that began this check</param>
            <param name="_main">main polygon</param>
            <param name="_lineDataMain">main line data</param>
            <param name="_subtractionHulls">subtraction polygons</param>
            <param name="_lineDataSubtractions">subtractions line data</param>
            <param name="_usedCutLinesMain">check that indicates is a main line cut data was already used</param>
            <returns>created polygon</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.processFromNewCutPoint(u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DPolygon2D,u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[],System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData[]},System.Boolean[][]@)">
            <summary>
            processes the system if a new cut point is found to work from
            </summary>
            <param name="_dataCut">cut to process</param>
            <param name="_beginPoint">point that began this check</param>
            <param name="_main">main polygon</param>
            <param name="_lineDataMain">main line data</param>
            <param name="_subtractionHulls">subtraction polygons</param>
            <param name="_lineDataSubtractions">subtractions line data</param>
            <param name="_usedCutLinesMain">check that indicates is a main line cut data was already used</param>
            <returns>created polygon</returns>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.getIndexOfCutLine(System.Collections.Generic.List{u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData},System.Double)">
            <summary>
            get the index of cut line corresponding to given distance
            </summary>
            <param name="_cutLines">cut lines</param>
            <param name="_distance">given distance on this line</param>
            <returns>index of cut line corresponding with given distance</returns>
        </member>
        <member name="T:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData">
            <summary>
            data of cutting along a given line
            </summary>
        </member>
        <member name="F:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.LineCuttingData.CutsOnLineData">
            <summary>
            cuts data
            </summary>
        </member>
        <member name="T:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData">
            <summary>
            data of a single cut on a line
            </summary>
        </member>
        <member name="F:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData.CuttingLineIndex">
            <summary>
            index of the line that causes the cutting
            </summary>
        </member>
        <member name="F:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData.SubtractionIndex">
            <summary>
            index from which hull that is
            </summary>
        </member>
        <member name="F:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData.DistanceOnThisLine">
            <summary>
            percentage to cut on this line
            </summary>
        </member>
        <member name="F:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData.DistanceOnCuttingLine">
            <summary>
            distance to cut on cutting line
            </summary>
        </member>
        <member name="F:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData.CutPoint">
            <summary>
            cut point
            </summary>
        </member>
        <member name="M:u040.prespective.fact.shapegenerators.Boolean2DOperationUtility.CutData.#ctor(System.Int32,System.Int32,System.Double,System.Double,u040.prespective.math.doubles.DVector2)">
            <summary>
            constructor
            </summary>
            <param name="_cuttingLineIndex">index of the line that causes the cutting</param>
            <param name="_subtractionIndex">index from which hull that is</param>
            <param name="_distanceOnThisLine">percentage to cut on this line</param>
            <param name="_distanceOnCuttingLine">distance to cut on cutting line</param>
            <param name="_cutPoint">cut point</param>
        </member>
        <member name="M:u040.prespective.fact.collision.post.PostCollisionTranslationToRotation.getCollisionEdges(u040.prespective.math.doubles.DVector2,u040.prespective.fact.BodyPlaneProjectionRecord,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector3,System.Double,System.Double,u040.prespective.fact.collision.DEdgeData@,u040.prespective.fact.collision.DEdgeData@,u040.prespective.math.doubles.DVector2@,System.Double@,u040.prespective.math.doubles.DVector3@)">
            <summary>
            gets the collision edges of both bodies
            </summary>
            <param name="_translation">moved back translation caused by collision</param>
            <param name="_collidedProjection">collided projection</param>
            <param name="_collidedHulls">collided hulls</param>
            <param name="_collidedWithHulls">collided with hulls</param>
            <param name="_colliderTranslationOriginal">original translation</param>
            <param name="_collidedVelocity">velocity</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_collisionEdgeCollided">collision edge collided</param>
            <param name="_collisionEdgeCollidedWith">collision edge collided with</param>
            <param name="_dir">new direction translation</param>
            <param name="_magnitude">new magnitude translation</param>
            <param name="_correctNewVelocity">new velocity translation</param>
            <returns>if can be rotated</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.post.PostCollisionTranslationToRotation.processRotation(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.fact.BodyPlaneProjection,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},u040.prespective.math.doubles.DPlane,u040.prespective.fact.collision.DEdgeData,u040.prespective.fact.collision.DEdgeData,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Boolean,System.Double@,u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DQuaternion@,u040.prespective.fact.BodyPlaneProjection@)">
            <summary>
            processes the object being rotated after collision
            </summary>
            <param name="_fromTranslationDirection">direction of movement</param>
            <param name="_accelerationDirection">direction of acceleration</param>
            <param name="_collisionProjection">projection at collision</param>
            <param name="_toCurrentHulls">hulls from the object that it collided with</param>
            <param name="_collisionPlane">collision plane</param>
            <param name="_collisionEdgeSelf">collision edge self</param>
            <param name="_collisionEdgeOther">collision edge other</param>
            <param name="_remainingTranslation">extra translation applied because of collision</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_showDebug">show debug</param>
            <param name="_magnitude">magnitude of the remaining movement</param>
            <param name="_translation">extra translation applied because of collision</param>
            <param name="_worldRotation">extra rotation applied because of collision</param>
            <param name="_correctedProjection">end state after collision</param>
        </member>
        <member name="M:u040.prespective.fact.collision.post.PostCollisionTranslationToRotation.getOptimalAngle(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.Int32[],u040.prespective.math.doubles.DVector2}},u040.prespective.fact.collision.DEdgeData,System.Double,System.Double,System.Boolean,System.Double@,u040.prespective.math.doubles.DPlane@,System.Boolean@)">
            <summary>
            gets optimal angle around rotation point
            </summary>
            <param name="_rotationPointWorld">rotation world point</param>
            <param name="_rotationTranslationDirectionWorld">translation direction of rotated object</param>
            <param name="_rotationHulls">rotation hulls</param>
            <param name="_otherHulls">other hulls</param>
            <param name="_pointsSelfOnLine">points that are on collision edge other hull</param>
            <param name="_collisionEdgeOther">collision edge other hull</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_showDebug">show debug</param>
            <param name="_optimalAngle">found optimal angle in radii</param>
            <param name="_optimalPlane">found plane to work with</param>
            <param name="_clockwise">if rotating clockwise</param>
            <returns>if found optimal angle</returns>
        </member>
        <member name="F:u040.prespective.fact.collision.post.CORCollisionSolve.recursionCounter">
            <summary>
            gets optimal angle around rotation point
            </summary>
            <param name="RecursionCounter">How many recursive iterations have occurred in 1 timestep</param>
            <param name="Psr">Poisson's ratio - intrinsic mechanical material property</param>
            <param name="Ey">Elastic modulus - intrinsic mechanical material property</param>
            <param name="Sy">Yield strength - intrinsic mechanical material property</param>
            <param name="EyEffective">Effective elastic modulus</param>
            <param name="ReturnVelVector">The velocity vector right after collision</param>
            <param name="OffSet">The translation between the collision point and the calculated end position</param>
            <param name="velVector">The velocity at release, end of timestep</param>
            <param name="ExternalAccel">External forces vector</param>
            <param name="fullImpactVector">The complete impact velocity vector</param>
            <param name="prevImpactSite">The coordinates of the last collision site. Used in recursive solver</param>
            <param name="preVelVector">Velocity vector at start of physics time step</param>
            <param name="DistToImpact">Distance from starting position of time step to collision site</param>
            <param name="TimeToImpact">Time from the start of the physics time step until collision</param>
            <param name="TimeAfterImpact">Time after collision within physics time step</param>
            <param name="CritForce">The force at which initial plastic deformation occurs</param>
            <param name="CritInterference">The displacement of the sphere into the flat at which initial plastic deformation occurs</param>
            <param name="Critvel">The impact velocity at which initial plastic deformation occurs</param>
            <param name="NormVel">ImpactVel/CritVel</param>
            <param name="NormVector">Vector normal to the collision surface</param>
            <param name="COR">Coefficient of restitution: a measure for the conservation of energy in a collision</param>
            <param name="ExternalAccel">The acceleration caused by external forces. I.e. gravity -> -9.807 m/s^2</param>
            <param name="ReleasePosition">The coordinates of the position of the object at the end of the time step</param>
            <param name="BeginRotation">Rotation at start of physics time step</param>
            <param name="ReleaseRotation">Rotation at release, end of physics time step after solving</param>
            <param name="ImpactRotation">Rotation at impact</param>
            <param name="OriginalEndRotation">Rotation at end of the time step before solving</param>
            <param name="RotationPoint">Coordinates of impact site</param>
            <param name="RotationArm">Distance vector between centre of mass and rotation point -> torque arm.</param>
            <param name="ImpulseReactionMagnitude">The magnitude of the collision impulse, used to calculate post-collision parameters</param>
            /// <param name="worldOffset">The translation between the collision point and the calculated end position</param>
            <returns>Release position/rotation and (angular+linear) velocity</returns>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionComparisonRecord.OwnerIsFirstShape">
            <summary>
            Whether the owner of this record is also Shape1 in the Collision Record (Default is true)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionComparisonRecord.CollisionRecord">
            <summary>
            The Original CollisionRecord this comparison report is based on
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionComparisonRecord.CollisionIsUnresolvedResultOfLastTick">
            <summary>
            Whether the collision is actually an unresolved collision resulting from the last tick solver
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionComparisonRecord.MinDistanceTravelledToCollision">
            <summary>
            The minimum distance to travel to the collision, if this value is negative the previous shape projection intersects with the collision hull
            (which means these objects actually intrude each other)
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.CollisionComparisonRecord.OwnerProjectionRecord">
            <summary>
            Get the projection record belonging to the owner
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.CollisionComparisonRecord.OpposingProjectionRecord">
            <summary>
            Get the projection record belonging to the opposing shape
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.CollisionComparisonRecord.OwnerBody">
            <summary>
            Get the shape belonging to the owner
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.CollisionComparisonRecord.OpposingBody">
            <summary>
            Get the shape belonging to the opposing shape
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.CollisionComparisonRecord.OccludesOtherCollision(u040.prespective.fact.collision.CollisionComparisonRecord)">
            <summary>
            An opposing collision is occluded by this collision if the angle between the projection of the shortest traversal vector
            and the vector between the this traversals' start and the opposing collision results in an angle smaller than 90 degrees
            </summary>
            <param name="_otherCollision"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.PostCollisionBehaviour.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.PostCollisionBehaviour.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.PostCollisionBehaviour.EnactBehavior(u040.prespective.fact.collision.CollisionComparisonRecord,System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData},System.Double,System.Double,System.Collections.Generic.List{u040.prespective.prepair.IntentData}@)">
            <summary>
            function that solves post collision
            </summary>
            <param name="_collisionData"></param>
            <param name="_collisionIntent"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_intent"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.fact.collision.RotationUtility">
            <summary>
            <description>
            Used to find the smallest angle between two 2D closed bodies with given rotation point
            </description>
            <version 
                version="1.0.0" 
                author="TGE" 
                date="200611">
                Finds smallest angle checking with checking for intersection if body is rotated
            </version>
            <version 
                version="1.1.0" 
                author="TGE" 
                date="2-0903">
                Gets rotation point on collision
            </version>
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.GetRotationPoint(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2,System.Double,System.Double,u040.prespective.math.doubles.DVector2@)">
            <summary>
            gets rotation point of collision if present
            </summary>
            <param name="_rotationTranslationDirection">translation direction</param>
            <param name="_collisionEdgeRotation">collision edge body that is going to rotated</param>
            <param name="_collisionEdgeCollider">collision edge object colliding against</param>
            <param name="_centreOfGravity">centre of gravity</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">margin of the dot check</param>
            <param name="_rotationPoint">found rotation point</param>
            <returns>if present</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.getCollisionRotationPoint(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2@)">
            <summary>
            gets rotation point if present
            </summary>
            <param name="_collisionEdge">collision edge</param>
            <param name="_centreOfGravity">centre of gravity of rotating object</param>
            <param name="_translationDirection">translation direction</param>
            <param name="_rotationPoint">found rotation point</param>
            <returns>if rotation point is present</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.projectedDistance(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            gets projected distance perpendicular
            </summary>
            <param name="_edge">edge to project on</param>
            <param name="_point">point to project</param>
            <param name="_margin">margin dot</param>
            <returns>projected distance perpendicular</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.GetSmallestRotationAngle(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Boolean,System.Double,System.Double,System.Boolean,System.Double@,u040.prespective.math.doubles.DVector2@,System.Int32@,System.Boolean,System.Int32[][],System.Boolean)">
            <summary>
            gets the smallest angle around rotation point in clockwise direction
            </summary>
            <param name="_rotationPoint">rotation point</param>
            <param name="_rotatingHull">the hull of the object that is going to rotated</param>
            <param name="_hullToCheckForCollsion">the hull of a object it can have a collision with while rotating</param>
            <param name="_clockWise">if should check rotations clockwise</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_showDebug">show debug</param>
            <param name="_minimumAngle">minimum angle found if radian</param>
            <param name="_hitPoint">point the hit was made</param>
            <param name="_hitEdgeIndex">hit edge of hull to check index</param>
            <param name="_ignoredInsideCircle">ignore inside circle calculation</param>
            <param name="_ignoredCombinations">ignore combination of point rotation hull to edge collision hull</param>
            <param name="_ignoreZeroAngles">if ignore zero angles</param>
            <returns>smallest found clockwise rotation against given hull </returns>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.checkAngleHittingEdgePoint(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Double,System.Double,System.Boolean,u040.prespective.math.doubles.DVector2[]@,System.Double@)">
            <summary>
            checks angle of hitting edge point
            </summary>
            <param name="_edgePoint">edge point</param>
            <param name="_rotationPoint">rotation point circle</param>
            <param name="_originalPoint">original point checked</param>
            <param name="_rotatingHull">hull that is rotation</param>
            <param name="_hullToCheckForCollsion">hull that is causing collision</param>
            <param name="_radiusOriginal">radius original circle</param>
            <param name="_originalIndex">original index that was checked</param>
            <param name="_amountOfPoints">amount of points</param>
            <param name="_ingnoreZeroAngles">if ignore zero angles</param>
            <param name="_clockWise">if should check rotations clockwise</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_showDebug">show debug</param>
            <param name="_hitEgde">edge that got a new smaller angle</param>
            <param name="_minimumAngle">minimum angle until now</param>
            <returns>if found new optimal angle</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.checkIntersectionsLineCircleEdgePoint(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Double,System.Boolean,System.Boolean,System.Double,System.Double,System.Boolean,System.Double@)">
            <summary>
            checks intersection between line and circle
            </summary>
            <param name="_lineBeginPoint">line begin point</param>
            <param name="_lineEndPoint"></param>
            <param name="_originalCirclePoint">original circle point</param>
            <param name="_rotationPoint">rotation point circle</param>
            <param name="_rotatingHull">hull that is rotation</param>
            <param name="_hullToCheckForCollsion">hull that is causing collision</param>
            <param name="_radius">radius circle</param>
            <param name="_ingnoreZeroAngles">if ignore zero angles</param>
            <param name="_clockWise">if should check rotations clockwise</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_showDebug">show debug</param>
            <param name="_minimumAngle">minimum angle until now</param>
            <returns>if found new optimal angle</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.checkAngleSmaller(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean,u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Boolean,System.Double@)">
            <summary>
            checks the angle if smaller
            </summary>
            <param name="_direction">original direction</param>
            <param name="_newDirection">new direction</param>
            <param name="_ingnoreZeroAngles">if ignore zero angles</param>
            <param name="_clockWise">if should check rotations clockwise</param>
            <param name="_rotatingHull">hull that is rotation</param>
            <param name="_hullToCheckForCollsion">hull that is causing collision</param>
            <param name="_rotationPoint">rotation point</param>
            <param name="_ignorePoint">point to ignore</param>
            <param name="_marginDistance">margin distance</param>
            <param name="_marginAngle">margin angle</param>
            <param name="_showDebug">show debug</param>
            <param name="_minimumAngle">minimum angle until now</param>
            <returns>if found new optimal angle</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.RotationUtility.checkInterSectionInsideOtherHull(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Boolean,System.Double,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double)">
            <summary>
            checks if their as an intersection between the hulls because of the rotation
            </summary>
            <param name="_rotatingHull">original hull that is rotated</param>
            <param name="_hullToCheckForCollsion">hull to check against</param>
            <param name="_clockWise">is clockwise rotation</param>
            <param name="_angle">angle</param>
            <param name="_rotationPoint">point rotating around</param>
            <param name="_ignorePoint">point to ignore</param>
            <param name="_marginDistance">margin distance</param>
            <param name="_marginAngle">margin angle</param>
            <returns>if no intersection hull</returns>
        </member>
        <member name="T:u040.prespective.fact.collision.properties.CollisionDetectionBehaviour">
            <summary>
            <description>
            Basic trigger (checks if one object is inside another object)
            </description>
            <version 
                version="1.0.0" 
                author="TGE" 
                date="200720">
                //first version
            </version>
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.properties.CollisionDetectionBehaviour.PropertyName">
            <summary>
            property name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.CollisionDetectionBehaviour.GetProperty(u040.prespective.fact.APhysicalBody,u040.prespective.fact.BodyPlaneProjection[],u040.prespective.fact.APhysicalBody,u040.prespective.fact.BodyPlaneProjection[],System.Double,System.Double)">
            <summary>
            gets property and applies to body
            </summary>
            <param name="_bodySelf"></param>
            <param name="_selfProjection"></param>
            <param name="_bodyOther"></param>
            <param name="_otherProjection"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.CollisionDetectionBehaviour.isInsideContactArea(System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Double)">
            <summary>
            checks if inside body
            </summary>
            <param name="_hulls1"></param>
            <param name="_hulls2"></param>
            <param name="_distanceMargin"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.fact.collision.properties.InteractionAreaBehaviour">
            <summary>
            <description>
            Gets the overlap area of 2 object within a certain margin
            </description>
            <version 
                version="1.0.0" 
                author="TGE" 
                date="200611">
                //first version
            </version>
            <version 
                version="1.1.0" 
                author="TGE" 
                date="200619">
                added is already present check
            </version>
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.InteractionLength">
            <summary>
            the distance to have an interaction area
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.PropertyName">
            <summary>
            interaction area name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.GetProperty(u040.prespective.fact.APhysicalBody,u040.prespective.fact.BodyPlaneProjection[],u040.prespective.fact.APhysicalBody,u040.prespective.fact.BodyPlaneProjection[],System.Double,System.Double)">
            <summary>
            gets interaction area
            </summary>
            <param name="_bodySelf"></param>
            <param name="_selfProjection"></param>
            <param name="_bodyOther"></param>
            <param name="_otherProjection"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.alreadyPresentCheck(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody)">
            <summary>
            checks if the body is already present
            </summary>
            <param name="_main">body</param>
            <param name="_checkObject">body to check if already present</param>
            <returns>if already present</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.enlargeHulls(System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Double)">
            <summary>
            enlarges given hulls
            </summary>
            <param name="_hulls">hulls</param>
            <param name="_enlargingLength">enlarging length</param>
            <returns>enlarged hulls</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.isInsideContactArea(u040.prespective.math.doubles.DPolygon2D[],u040.prespective.math.doubles.DPolygon2D[],System.Double,System.Double)">
            <summary>
            checks if the objects are inside each other within a margin
            </summary>
            <param name="_hulls1">polygon hull 1</param>
            <param name="_hulls2">polygon hull 2</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_dotMargin">dot margin</param>
            <returns>if inside</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.find2DContactArea(u040.prespective.math.doubles.DPolygon2D[],u040.prespective.math.doubles.DPolygon2D[],System.Double,System.Double,System.Double,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}}@)">
            <summary>
            gets the 2D contact area
            </summary>
            <param name="_hulls1">hulls to check</param>
            <param name="_hulls2">other hulls to check</param>
            <param name="_enlargingLength">length of the enlarging</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_result2">contact area's 2D hull 2</param>
            <returns>contact area's 2D hull 1</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.getHullContactArea2D(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Int32,System.Boolean,System.Boolean,System.Double,System.Double,System.Double,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}}@)">
            <summary>
            gets the 2D contact area
            </summary>
            <param name="_vert1">first hull vertices</param>
            <param name="_vert2">second hull vertices</param>
            <param name="_amountVertices1">amount vertices first hull</param>
            <param name="_firstInPolygon1">first polygon in hull 1</param>
            <param name="_firstInPolygon2">first polygon in hull 2</param>
            <param name="_enlargingLength">length of the enlarging</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_contactAreaHull2">contact area's 2D hull 2</param>
            <returns>contact area's 2D hull 1</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.getCuttingLineData(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Int32,System.Int32,System.Double,System.Double,System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.Double,u040.prespective.math.doubles.DVector2}}[]@)">
            <summary>
            gets the cutting line data between 2 hulls
            </summary>
            <param name="_vert1">hull 1</param>
            <param name="_vert2">hull 2</param>
            <param name="_amountVertices1">amount of vertices in hull 1</param>
            <param name="_amountVertices2">amount of vertices in hull 2</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_cuttingData2">cutting line data hull 2</param>
            <returns>cutting line data hull 1</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.properties.InteractionAreaBehaviour.get2DContactAreaOfHull(u040.prespective.math.doubles.DVector2[],System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.Double,u040.prespective.math.doubles.DVector2}}[],System.Int32,System.Boolean,System.Double)">
            <summary>
            get 2D contact area of given hull
            </summary>
            <param name="_vert">hull</param>
            <param name="_cuttingData">cutting line data of hull</param>
            <param name="_amountVertices">amount of vertices of hull</param>
            <param name="_firstInPolygon1">first polygon in hull</param>
            <param name="_enlargingLength">length of the enlarging</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionIntentData.OriginalTranslation">
            <summary>
            original translation before collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionIntentData.OriginalVelocity">
            <summary>
            original velocity before collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionIntentData.OriginalAngularVelocity">
            <summary>
            original angular velocity before collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionIntentData.AppliedTranslationCollision">
            <summary>
            translation applied by collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.CollisionIntentData.AppliedRotationCollision">
            <summary>
            rotation applied by collision
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.CollisionIntentData.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.CollisionIntentData.#ctor(u040.prespective.prepair.IntentData)">
            <summary>
            constructor
            </summary>
            <param name="_intent">base intent</param>
        </member>
        <member name="P:u040.prespective.fact.collision.PhysicsUtility.PhysicsPropertiesPrototypes">
            <summary>
            The Physics Collision Behaviour Prototype Requester
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetCollisionBehaviorPrototypeByName(System.String,u040.prespective.fact.collision.CollisionProperties@)">
            <summary>
            Retrieve a collision property Prototype by name
            </summary>
            <param name="_name">the name to look for</param>
            <param name="_prototype">the prototype returned</param>
            <returns></returns>
        </member>
        <member name="P:u040.prespective.fact.collision.PhysicsUtility.PhysicsCollisionPrototypes">
            <summary>
            The Physics Collision Behaviour Prototype Requester
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetCollisionBehaviorPrototypeByName(System.String,u040.prespective.fact.collision.CollisionBehavior@)">
            <summary>
            Retrieve a collision Behaviour Prototype by name
            </summary>
            <param name="_name">the name to look for</param>
            <param name="_prototype">the prototype returned</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.fact.collision.PhysicsUtility.physicsBehaviorPrototypes">
            <summary>
            The buffered prototype objects with custom Physics Behaviour
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.PhysicsUtility.PhysicsBehaviorPrototypes">
            <summary>
            The Physics Behaviour Prototype Requester
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetPhysicsBehaviorPrototypeByName(System.String,u040.prespective.fact.PhysicsBehavior@)">
            <summary>
            Retrieve a physics Behaviour Prototype by name
            </summary>
            <param name="_name">the name to look for</param>
            <param name="_prototype">the prototype returned</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.fact.collision.PhysicsUtility.frictionBehavioursBuffer">
            <summary>
            The buffered friction behaviours
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.PhysicsUtility.FrictionBehaviours">
            <summary>
            The friction Behaviours Requester
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetFrictionBehaviorByName(System.String,u040.prespective.fact.FrictionBehaviour@)">
            <summary>
            Retrieve a friction Behaviour by name
            </summary>
            <param name="_name">the name to look for</param>
            <param name="_prototype">the prototype returned</param>
            <returns>if found connected behaviour</returns>
        </member>
        <member name="F:u040.prespective.fact.collision.PhysicsUtility.postCollisionBehavioursBuffer">
            <summary>
            The buffered post collision behaviours
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.PhysicsUtility.PostCollisionBehaviours">
            <summary>
            The post collision Behaviours Requester
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetPostCollisionBehaviourByName(System.String,u040.prespective.fact.collision.PostCollisionBehaviour@)">
            <summary>
            Retrieve a post collision Behaviour by name
            </summary>
            <param name="_name">the name to look for</param>
            <param name="_prototype">the prototype returned</param>
            <returns>if found connected behaviour</returns>
        </member>
        <member name="F:u040.prespective.fact.collision.PhysicsUtility.meshOutlineSignatures">
            <summary>
            Buffer containing the signatures for previously requested meshes
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetMeshOutlineSignature(UnityEngine.Transform,UnityEngine.Mesh)">
            <summary>
            Retrieve the signature for a specific mesh
            </summary>
            <param name="_t"></param>
            <param name="_mesh"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.generateUniqueMeshEdgeRegistration(u040.prespective.core.transformation.ADTransform,UnityEngine.Mesh)">
            <summary>
            Generate the mesh outline signature for a specific mesh
            </summary>
            <param name="_t">a transform containing the mesh</param>
            <param name="_mesh">the Mesh itself to generate the signature for</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetCollisionEdges(u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},u040.prespective.fact.collision.DEdgeData@,u040.prespective.fact.collision.DEdgeData@,System.Double)">
            <summary>
            gets collision edges
            </summary>
            <param name="_translationDirection">translation direction</param>
            <param name="_selfHulls">self hulls</param>
            <param name="_otherHulls">other hulls</param>
            <param name="_collisionEdgeSelf">found collision edge self record</param>
            <param name="_collisionEdgeOther">found collision edge other record</param>
            <param name="_margin">margin</param>
            <returns>if found collision edges</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.GetCollisionEdgeOnLineChecks(System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},u040.prespective.fact.collision.DEdgeData@,u040.prespective.fact.collision.DEdgeData@,System.Double)">
            <summary>
            finds the collision edge by checking which points are on the line
            </summary>
            <param name="_selfHulls">self hulls</param>
            <param name="_otherHulls">other hulls</param>
            <param name="_collisionEdgeSelf">found collision edge self record</param>
            <param name="_collisionEdgeOther">found collision edge other record</param>
            <param name="_margin">margin</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.FromToTranslation(u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.fact.BodyPlaneProjectionRecord@,u040.prespective.fact.BodyPlaneProjectionRecord@,u040.prespective.fact.BodyRegionRecord@,u040.prespective.fact.BodyRegionRecord@,System.Int32@,System.Int32@)">
            <summary>
            determines the from and the to for translation
            </summary>
            <param name="_collisionData">collision data</param>
            <param name="_fromProjection">from projection</param>
            <param name="_toProjection">to projection</param>
            <param name="_fromBody">from body</param>
            <param name="_toBody">to body</param>
            <param name="_fromMatchIndex">from match index</param>
            <param name="_toMatchIndex">to match index</param>
        </member>
        <member name="M:u040.prespective.fact.collision.PhysicsUtility.FromToRotation(u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.fact.BodyPlaneProjectionRecord@,u040.prespective.fact.BodyPlaneProjectionRecord@,u040.prespective.fact.BodyRegionRecord@,u040.prespective.fact.BodyRegionRecord@,System.Int32@,System.Int32@)">
            <summary>
            determines the from and the to for rotation
            </summary>
            <param name="_collisionData">collision data</param>
            <param name="_fromProjection">from projection</param>
            <param name="_toProjection">to projection</param>
            <param name="_fromBody">from body</param>
            <param name="_toBody">to body</param>
            <param name="_fromMatchIndex">from match index</param>
            <param name="_toMatchIndex">to match index</param>
        </member>
        <member name="T:u040.prespective.fact.collision.DEdgeData">
            <summary>
            data struct data of edge
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.DEdgeData.Edge">
            <summary>
            edge
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.DEdgeData.PolyIndex">
            <summary>
            index of the polyhedron
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.DEdgeData.EdgePointIndex">
            <summary>
            index edge
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.DEdgeData.AllPoints">
            <summary>
            all points used to created the edge
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.DEdgeData.#ctor(u040.prespective.math.doubles.DVector2[],System.Int32,System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="_verts">vertices</param>
            <param name="_index">index</param>
            <param name="_polyIndex">index polygon</param>
        </member>
        <member name="P:u040.prespective.fact.collision.behaviour.SignoriniRotationBehaviour.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniRotationBehaviour.EnactBehavior(u040.prespective.fact.collision.CollisionComparisonRecord,System.Double,System.Double,System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData}@)">
            <summary>
            enacts the rotation behaviour
            </summary>
            <param name="_collisionData">collision data</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_intent">done intent</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniRotationBehaviour.getOptimalAngle(u040.prespective.fact.BodyRegionRecord,u040.prespective.fact.BodyPlaneProjectionRecord,u040.prespective.fact.BodyPlaneProjectionRecord,System.Double,System.Double,System.Boolean,System.Double@,u040.prespective.math.doubles.DPlane@,System.Boolean@)">
            <summary>
            get optimal angle if present
            </summary>
            <param name="_rotationProjection">rotation projection</param>
            <param name="_rotationRecord">rotation record</param>
            <param name="_otherRecord">other record</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_showDebug">show debug</param>
            <param name="_optimalAngle">found optimal angle</param>
            <param name="_optimalPlane">found optimal plane</param>
            <param name="_normal">found normal</param>
            <returns>if successful</returns>
        </member>
        <member name="P:u040.prespective.fact.collision.behaviour.SignoriniController.BehaviorName">
            <summary>
            Name of the Behaviour; used in the inspector to apply it to shapes
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniController.EnactBehavior(u040.prespective.fact.collision.CollisionComparisonRecord,System.Double,System.Double,System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData}@)">
            <summary>
            enacts the Signorini behaviour (rotation or translation)
            </summary>
            <param name="_collisionData">collision data</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_intent">done intent</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.IntersectionCase">
            <summary>
            Case overview of the handled Intersection scenarios
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.BehaviorName">
            <summary>
            Name of the Behaviour; used in the inspector to apply it to shapes
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.EnactBehavior(u040.prespective.fact.collision.CollisionComparisonRecord,System.Double,System.Double,System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData}@)">
            <summary>
            Called by the Physics region on a specific collision to be resolved
            </summary>
            <param name="_collisionComparisonData"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_intent"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.solveSignorini(u040.prespective.fact.collision.CollisionComparisonRecord,System.Double,System.Double,System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData}@)">
            <summary>
            
            </summary>
            <param name="_collisionComparisonData"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_intent"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.getSignoriniIntersectionCase(u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.fact.BodyPlaneProjectionRecord,u040.prespective.fact.BodyPlaneProjectionRecord,System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Boolean)">
            <summary>
            gets with signorini case it is in
            </summary>
            <param name="_comparsionRecord">collision record</param>
            <param name="_owner">owner</param>
            <param name="_opposing">opposing</param>
            <param name="_ownerMatchIndex">owner match index</param>
            <param name="_opposingMatchIndex">opposing match index</param>
            <param name="_ownTranslation">owner translation</param>
            <param name="_opposingTranslation">opposing translation</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_dotMargin">dot margin</param>
            <param name="_isDebug">if show debug</param>
            <returns>case</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.insideCollisionHull(System.Int32,u040.prespective.fact.BodyPlaneProjection,u040.prespective.fact.BodyPlaneProjection,System.Int32,System.Double,System.Double)">
            <summary>
            check if inside collision hull also partially
            </summary>
            <param name="_amountOfHullsToCheck">amount of hulls</param>
            <param name="_collisionHulls">collision hulls</param>
            <param name="_hullsToCheck">hull to check if inside</param>
            <param name="_matchIndex">match index of hull to check</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_dotMargin">dot margin</param>
            <returns>if inside collision hull</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.resolveS6Scenario(u040.prespective.fact.BodyPlaneProjection,u040.prespective.fact.BodyPlaneProjectionRecord,u040.prespective.fact.BodyPlaneProjectionRecord,System.Int32,System.Int32,System.Boolean,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            
            </summary>
            <param name="_collisionHulls"></param>
            <param name="_owner"></param>
            <param name="_opposing"></param>
            <param name="_ownerMatchIndex"></param>
            <param name="_opposingMatchIndex"></param>
            <param name="_isDebug"></param>
            <param name="_ownTranslation"></param>
            <param name="_ownStartTranslation"></param>
            <param name="_opposingTranslation"></param>
            <param name="_opposingStartTranslation"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.processCase(u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.IntersectionCase,u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.fact.BodyPlaneProjectionRecord,u040.prespective.fact.BodyPlaneProjectionRecord,System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.String,System.Double@,System.Double@,u040.prespective.math.doubles.DVector2@,System.Double@)">
            <summary>
            processes the given case to get the data form determining how much it needs to be translated because of case
            </summary>
            <param name="_iCase"></param>
            <param name="_collisionComparisonData"></param>
            <param name="_fromProjection"></param>
            <param name="_toProjection"></param>
            <param name="_fromMatchIndex"></param>
            <param name="_toMatchIndex"></param>
            <param name="_fromTranslation"></param>
            <param name="_toTranslation"></param>
            <param name="_fromRotation"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_surfaceMargin"></param>
            <param name="_showDebug"></param>
            <param name="_debugPrefix"></param>
            <param name="_maxDistanceTravelledToCollision"></param>
            <param name="_minDistanceTravelledToCollision"></param>
            <param name="_translation"></param>
            <param name="_rotation"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.processS1(System.Collections.Generic.List{UnityEngine.Vector2Int},u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Double,System.Boolean,u040.prespective.math.doubles.DVector2@,System.Double@,System.Double@,u040.prespective.math.doubles.DVector2[]@)">
            <summary>
            
            </summary>
            <param name="_matches"></param>
            <param name="_fromCurrentProjectedOrgin"></param>
            <param name="_fromCurrentHulls"></param>
            <param name="_toCurrentHulls"></param>
            <param name="_fromMatchIndex"></param>
            <param name="_toMatchIndex"></param>
            <param name="_fromTranslation"></param>
            <param name="_toTranslation"></param>
            <param name="_fromRotation"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_showDebug"></param>
            <param name="_translation"></param>
            <param name="_rotation"></param>
            <param name="_maxDistanceTravelledToCollision"></param>
            <param name="_positions"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.processS2(System.Collections.Generic.List{UnityEngine.Vector2Int},u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Double,System.Boolean,u040.prespective.math.doubles.DVector2@,System.Double@,System.Double@,u040.prespective.math.doubles.DVector2[]@)">
            <summary>
            
            </summary>
            <param name="_matches"></param>
            <param name="_collisionComparisonData"></param>
            <param name="_fromPreviousProjectedOrgin"></param>
            <param name="_fromPreviousHulls"></param>
            <param name="_toCurrentHulls"></param>
            <param name="_fromMatchIndex"></param>
            <param name="_toMatchIndex"></param>
            <param name="_fromTranslation"></param>
            <param name="_toTranslation"></param>
            <param name="_fromRotation"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_showDebug"></param>
            <param name="_translation"></param>
            <param name="_rotation"></param>
            <param name="_maxDistanceTravelledToCollision"></param>
            <param name="_positions"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.processS3(System.Collections.Generic.List{UnityEngine.Vector2Int},u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Double,System.Boolean,u040.prespective.math.doubles.DVector2@,System.Double@,System.Double@,u040.prespective.math.doubles.DVector2[]@)">
            <summary>
            
            </summary>
            <param name="_matches"></param>
            <param name="_collisionComparisonData"></param>
            <param name=""></param>
            <param name="_fromPreviousHulls"></param>
            <param name="_toCurrentHulls"></param>
            <param name="_fromMatchIndex"></param>
            <param name="_toMatchIndex"></param>
            <param name="_fromTranslation"></param>
            <param name="_fromRotation"></param>
            <param name="_angleMargin"></param>
            <param name="_surfaceMargin"></param>
            <param name="_showDebug"></param>
            <param name="_translation"></param>
            <param name="_minDistanceTravelledToCollision"></param>
            <param name="_positions"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.processS4(System.Collections.Generic.List{UnityEngine.Vector2Int},u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,System.Double,System.Double,System.Double,System.Boolean,u040.prespective.math.doubles.DVector2@,System.Double@,System.Double@,u040.prespective.math.doubles.DVector2[]@)">
            <summary>
            
            </summary>
            <param name="_matches"></param>
            <param name="_collisionComparisonData"></param>
            <param name="_fromCurrentProjectedOrgin"></param>
            <param name="_fromCurrentHulls"></param>
            <param name="_toCurrentHulls"></param>
            <param name="_fromMatchIndex"></param>
            <param name="_toMatchIndex"></param>
            <param name="_fromTranslation"></param>
            <param name="_fromRotation"></param>
            <param name="_angleMargin"></param>
            <param name="_surfaceMargin"></param>
            <param name="_showDebug"></param>
            <param name="_translation"></param>
            <param name="_rotation"></param>
            <param name="_maxDistanceTravelledToCollision"></param>
            <param name="_positions"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.SignoriniContactBehaviour.determineRemainingVelocityTranslation(u040.prespective.math.doubles.DVector2,u040.prespective.fact.BodyPlaneProjectionRecord,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector3,System.Double,System.Double,u040.prespective.math.doubles.DVector2@,System.Double@,u040.prespective.math.doubles.DVector3@)">
            <summary>
            gets the collision edges of both bodies
            </summary>
            <param name="_translation">moved back translation caused by collision</param>
            <param name="_collidedProjection">collided projection</param>
            <param name="_collidedHulls">collided hulls</param>
            <param name="_collidedWithHulls">collided with hulls</param>
            <param name="_colliderTranslationOriginal">original translation</param>
            <param name="_collidedVelocity">velocity</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_collisionEdgeCollided">collision edge collided</param>
            <param name="_collisionEdgeCollidedWith">collision edge collided with</param>
            <param name="_dir">new direction translation</param>
            <param name="_magnitude">new magnitude translation</param>
            <param name="_correctNewVelocity">new velocity translation</param>
            <returns>if can be rotated</returns>
        </member>
        <member name="P:u040.prespective.fact.collision.behaviour.RotationSolver.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.RotationSolver.EnactBehavior(u040.prespective.fact.collision.CollisionComparisonRecord,System.Double,System.Double,System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData}@)">
            <summary>
            enacts rotation solver
            </summary>
            <param name="_collisionData">collision data</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_intent">intent</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.RotationSolver.getRotationAngleOnPlane(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DPlane)">
            <summary>
            determines how much rotated on plane
            </summary>
            <param name="_rotationDeltaInLastTick">world rotation delta</param>
            <param name="_plane">plane</param>
            <returns>amount rotated on plane</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.RotationSolver.getHitAngle(u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Collections.Generic.List{u040.prespective.math.doubles.DPolygon2D},System.Boolean,System.Double,System.Double,System.Boolean,System.Double@,System.Int32[]@,u040.prespective.math.doubles.DVector2@)">
            <summary>
            gets angle rotated hulls hits other hull
            </summary>
            <param name="_rotationPointWorld">rotation point rotating hull world</param>
            <param name="_rotationHulls">rotation hulls</param>
            <param name="_otherHulls">other hulls</param>
            <param name="_clockwise">if going clockwise</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_showDebug">if show debug</param>
            <param name="_hitAngle">angle hit found</param>
            <param name="_indexOtherEdgeHit">index other edge hit found</param>
            <param name="_hitPoint">hit point found</param>
            <returns>if found angle</returns>
        </member>
        <member name="M:u040.prespective.fact.collision.behaviour.RotationSolver.rotatePoint(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            get points position after rotation added
            </summary>
            <param name="_rotationPoint">rotation point</param>
            <param name="_point">point that is rotated</param>
            <param name="_cwRotationDeg">amount clock wise rotation</param>
            <returns>rotated point</returns>
        </member>
        <member name="T:u040.prespective.fact.collision.CollisionBehavior">
            <summary>
            <description>
            Abstract class to get collision behaviour
            </description>
            <version 
                version="1.0.0" 
                author="TGE" 
                date="200611">
                //first version
            </version>
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.CollisionBehavior.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.CollisionBehavior.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.CollisionBehavior.EnactBehavior(u040.prespective.fact.collision.CollisionComparisonRecord,System.Double,System.Double,System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData}@)">
            <summary>
            function that solves collision
            </summary>
            <param name="_collisionData"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_intent"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.fact.collision.BodyCollisionRecord">
            <summary>
            Record of a single shape-shape intersection on a single plane; note that a single shape-shape intersection may 
            involve multiple non-continuous collision hulls
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.BodyCollisionRecord.CollisionPlane">
            <summary>
            Reference to Cut-plane the collision occurred on
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.BodyCollisionRecord.Shape1">
            <summary>
            Reference to the record of the first participating shape in this collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.BodyCollisionRecord.ProjectionRecord1">
            <summary>
            Reference to the Projection record that fits the first participating shape on the collision plane
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.BodyCollisionRecord.Shape2">
            <summary>
            Reference to the record of the second participating shape in this collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.BodyCollisionRecord.ProjectionRecord2">
            <summary>
            Reference to the Projection record that fits the second participating shape on the collision plane
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.BodyCollisionRecord.CollisionHulls">
            <summary>
            Projection containing all collision hulls in this collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.collision.BodyCollisionRecord.CollisionHullVertexAddresses">
            <summary>
            Registry of the vertex indices participating in the collision hull and their origin in the participating mesh
            (X = origin shape mesh (either 0 or 1, -1 means it was generated; Y = origin vertex # in the mesh; -1 means it was generated)
            </summary>
        </member>
        <member name="T:u040.prespective.fact.collision.CollisionProperties">
            <summary>
            <description>
            Abstract class to get collision property after collision
            </description>
            <version 
                version="1.0.0" 
                author="TGE" 
                date="200611">
                //first version
            </version>
            </summary>
        </member>
        <member name="P:u040.prespective.fact.collision.CollisionProperties.PropertyName">
            <summary>
            the name this property to be found under
            </summary>
        </member>
        <member name="M:u040.prespective.fact.collision.CollisionProperties.GetProperty(u040.prespective.fact.APhysicalBody,u040.prespective.fact.BodyPlaneProjection[],u040.prespective.fact.APhysicalBody,u040.prespective.fact.BodyPlaneProjection[],System.Double,System.Double)">
            <summary>
            the basic function to process the object to get the property
            </summary>
            <param name="_bodySelf"></param>
            <param name="_selfProjection"></param>
            <param name="_bodyOther"></param>
            <param name="_otherProjection"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="T:u040.prespective.fact.bodyproperties.PASSMaterials">
            <remarks/>
        </member>
        <member name="P:u040.prespective.fact.bodyproperties.PASSMaterials.PASSMaterial">
            <remarks/>
        </member>
        <member name="T:u040.prespective.fact.bodyproperties.PASSMaterialsPASSMaterial">
            <remarks/>
        </member>
        <member name="P:u040.prespective.fact.bodyproperties.PASSMaterialsPASSMaterial.Name">
            <remarks/>
        </member>
        <member name="P:u040.prespective.fact.bodyproperties.PASSMaterialsPASSMaterial.Density">
            <remarks/>
        </member>
        <member name="P:u040.prespective.fact.bodyproperties.PASSMaterialsPASSMaterial.YoungsModulus">
            <remarks/>
        </member>
        <member name="P:u040.prespective.fact.bodyproperties.PASSMaterialsPASSMaterial.YieldStrength">
            <remarks/>
        </member>
        <member name="P:u040.prespective.fact.bodyproperties.PASSMaterialsPASSMaterial.PoissonsRatio">
            <remarks/>
        </member>
        <member name="P:u040.prespective.fact.bodyproperties.APhysicalBodyProperties.GetConcreteExplicitType">
            <summary>
            Retrieve the preferred Concrete Explicit Inheritant Class of AphysicalBodyProperties 
            (which is located in a different assembly, so we need to index it in runtime)
            </summary>
        </member>
        <member name="T:u040.prespective.fact.components.APhysicsBelt">
            <summary>
            <description>
            Belt that uses APA
            </description>
            <version 
                ver="1.0.0" 
                author="TGE" 
                date="200901">
                made first version with an directional vector to implement the belt speed
            </version>
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.APhysicsBelt.Velocity">
            <summary>
            the velocity on the belt
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.APhysicsBelt.bodyStored">
            <summary>
            physical body of the belt
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.APhysicsBelt.velocityDirection">
            <summary>
            the velocity direction of the belt
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.APhysicsBelt.active">
            <summary>
            if belt is active
            </summary>
        </member>
        <member name="P:u040.prespective.fact.components.APhysicsBelt.VelocityDirection">
            <summary>
            the velocity direction of the belt
            </summary>
        </member>
        <member name="P:u040.prespective.fact.components.APhysicsBelt.TurnedOn">
            <summary>
            if belt is turned on
            </summary>
        </member>
        <member name="P:u040.prespective.fact.components.APhysicsBelt.StaticFriction">
            <summary>
            static friction of the belt
            </summary>
        </member>
        <member name="P:u040.prespective.fact.components.APhysicsBelt.DynamicFriction">
            <summary>
            dynamic friction of the belt
            </summary>
        </member>
        <member name="P:u040.prespective.fact.components.APhysicsBelt.speed">
            <summary>
            speed of belt
            </summary>
        </member>
        <member name="M:u040.prespective.fact.components.APhysicsBelt.Start">
            <summary>
            start
            </summary>
        </member>
        <member name="M:u040.prespective.fact.components.APhysicsBelt.FixedUpdate">
            <summary>
            fixed update
            </summary>
        </member>
        <member name="M:u040.prespective.fact.components.APhysicsBelt.Reset">
            <summary>
            reset that makes sure it gets a physical body
            </summary>
        </member>
        <member name="P:u040.prespective.fact.components.APhysicsBelt.GetConcreteExplicitType">
            <summary>
            Retrieve the preferred Concrete Explicit Inheritance Class of APhysicsBelt 
            (which is located in a different assembly, so we need to index it in runtime)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.SpringComponent.ConnectedBody">
            <summary>
            body which between which the spring is
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.SpringComponent.SpringConstant">
            <summary>
            spring constant
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.SpringComponent.Length">
            <summary>
            rest length of the spring
            </summary>
        </member>
        <member name="F:u040.prespective.fact.components.SpringComponent.bodySelfStored">
            <summary>
            own stored physical body
            </summary>
        </member>
        <member name="P:u040.prespective.fact.components.SpringComponent.bodySelf">
            <summary>
            own physical body
            </summary>
        </member>
        <member name="M:u040.prespective.fact.components.SpringComponent.GetAppliedForceOnSelf">
            <summary>
            get spring force applied to this object
            </summary>
            <returns>spring force</returns>
        </member>
        <member name="M:u040.prespective.fact.components.SpringComponent.Reset">
            <summary>
            reset that makes sure it gets a physical body
            </summary>
        </member>
        <member name="M:u040.prespective.fact.behaviour.GravityRotationBehaviour.EnactBehavior(u040.prespective.fact.BodyRegionRecord,System.Double,System.Double)">
            <summary>
            does the effect of a body rotating around wheel joint caused by gravity
            </summary>
            <param name="_projection">projections of the body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
            <returns>intents of the effect</returns>
        </member>
        <member name="M:u040.prespective.fact.behaviour.GravityBehaviour.EnactBehavior(u040.prespective.fact.BodyRegionRecord,System.Double)">
            <summary>
            enacts the effect of gravity on velocity and acceleration on body
            </summary>
            <param name="_projection">body record</param>
            <param name="_deltaTime">delta time</param>
            <returns>created intents</returns>
        </member>
        <member name="P:u040.prespective.fact.behaviour.SpringBehaviour.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="P:u040.prespective.fact.behaviour.SpringBehaviour.MaxApplicationsPerTick">
            <summary>
            Gravity can only be applied once per tick
            </summary>
        </member>
        <member name="M:u040.prespective.fact.behaviour.SpringBehaviour.EnactBehavior(u040.prespective.fact.BodyRegionRecord,System.Double,System.Double,System.Double)">
            <summary>
            determines with kind of spring force needs to be applied
            </summary>
            <param name="_projection">body projection</param>
            <param name="_deltaTime">delta time of this tick</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <returns>intent of applied spring force</returns>
        </member>
        <member name="P:u040.prespective.fact.behaviour.GravityBehaviourController.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="P:u040.prespective.fact.behaviour.GravityBehaviourController.MaxApplicationsPerTick">
            <summary>
            Gravity can only be applied once per tick
            </summary>
        </member>
        <member name="M:u040.prespective.fact.behaviour.GravityBehaviourController.EnactBehavior(u040.prespective.fact.BodyRegionRecord,System.Double,System.Double,System.Double)">
            <summary>
            determines with kind of gravity needs to be applied
            </summary>
            <param name="_projection">body projection</param>
            <param name="_deltaTime">delta time of this tick</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <returns>intent of applied gravity</returns>
        </member>
        <member name="F:u040.prespective.fact.friction.Drag.DragCoefficient">
            <summary>
            drag coefficient
            </summary>
        </member>
        <member name="P:u040.prespective.fact.friction.Drag.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.friction.Drag.MovementFrictionUpdate(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            updates the movement of the body depending on friction
            </summary>
            <param name="_body">body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.Drag.VelocityFrictionUpdate(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            updates the velocity of the body depending on friction
            </summary>
            <param name="_body">body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
        </member>
        <member name="P:u040.prespective.fact.friction.ContactFriction.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.MovementFrictionUpdate(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            updates the movement of the body depending on friction
            </summary>
            <param name="_body">body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.VelocityFrictionUpdate(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            updates the velocity of the body depending on friction
            </summary>
            <param name="_body">body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.processBodyVelocity(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}},System.Double,System.Double)">
            <summary>
            processes the velocity of body
            </summary>
            <param name="_body">body</param>
            <param name="_contactBody">contact body</param>
            <param name="_velocityDirection">velocity direction body</param>
            <param name="_accelerationDirection">acceleration direction body</param>
            <param name="_contactLines">contact lines 2D</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.processBodyAcceleration(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody,u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}},System.Double,System.Double)">
            <summary>
            processes the acceleration of body
            </summary>
            <param name="_body">body</param>
            <param name="_contactBody">contact body</param>
            <param name="_accelerationDirection">acceleration direction body</param>
            <param name="_contactLines">contact lines 2D</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.checkContactBodyEffects(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}},System.Double,System.Double)">
            <summary>
            checks the effect of the contact body on the body
            </summary>
            <param name="_body">body</param>
            <param name="contactBody">contact body</param>
            <param name="_contactLines">contact lines 2D</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.processContactBodyAcceleration(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}},System.Double)">
            <summary>
            processes the effect of the acceleration of the contact body
            </summary>
            <param name="_body">body</param>
            <param name="_contactBody">contact body</param>
            <param name="_contactLines">contact lines 2D</param>
            <param name="_distanceMargin">distance margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.processDynamicFriction(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double,System.Double)">
            <summary>
            process dynamic friction
            </summary>
            <param name="_body">body</param>
            <param name="_contactBody">contact body</param>
            <param name="_directionalVelocityObject">velocity in the desired direction of body</param>
            <param name="_directionalVelocityContactObject">velocity in the desired direction of contact body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin">distance margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.processStaticFriction(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            processes statical friction on object
            </summary>
            <param name="_body">body</param>
            <param name="_contactBody">contact body</param>
            <param name="_direction">direction of acceleration contact area</param>
            <param name="_distanceMargin">distance margin</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.processStaticFriction(u040.prespective.fact.APhysicalBody,u040.prespective.fact.APhysicalBody,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Boolean)">
            <summary>
            processes statical friction on object
            </summary>
            <param name="_body">body</param>
            <param name="_contactBody">contact body</param>
            <param name="_accelerationDirection">direction of the acceleration</param>
            <param name="_directionalAccelerationObject">directional acceleration of body</param>
            <param name="_directionalAccelerationContactObject">directional acceleration of contact body</param>
            <param name="_deaccelerated">if de-accelerating</param>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.findBestContactDirection(u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}},u040.prespective.math.doubles.DVector3@)">
            <summary>
            finds highest directional overlap vector from contact lines
            </summary>
            <param name="_contactDirection">direction check contact in</param>
            <param name="_contactLines">contact lines</param>
            <param name="_optimalDir">optimal contact direction</param>
            <returns>if has contact direction</returns>
        </member>
        <member name="M:u040.prespective.fact.friction.ContactFriction.getDirtionalVector(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            gets the direction velocity given direction
            </summary>
            <param name="_direction">direction</param>
            <param name="_vector">original vector</param>
            <param name="_distanceMargin">distance margin</param>
            <returns>directional velocity</returns>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.CutPlaneName">
            <summary>
            cut plane name
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.IsActive">
            <summary>
            cut plane is active
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.ProjectionDetailLevel">
            <summary>
            level of detail over projections (for Boolean Body Modifier)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.Offset">
            <summary>
            The offset this plane has from the Custom Physics' region centre in the projection direction
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.Thickness">
            <summary>
            thickness of the plane projection zone
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.SceneOutlineColor">
            <summary>
            The Colour this projections' outline has in the Unity Editor Scene
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.LocalProjectionDirection">
            <summary>
            The (up) direction of this projection('s plane)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.AllowedPhysicalBodyProfiles">
            <summary>
            profiles projected on this plane
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.OverrideCollisionMatrix">
            <summary>
            if should override collision matrix
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.CollisionMatrixData">
            <summary>
            stored data collision matrix on plane for editor
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.OverridenBufferedProfiles">
            <summary>
            override for this plane of buffered profiles
            </summary>
        </member>
        <member name="F:u040.prespective.fact.RegionCutPlane.projectionPlane">
            <summary>
            Locally Stored projection plane
            </summary>
        </member>
        <member name="P:u040.prespective.fact.RegionCutPlane.OriginPosition">
            <summary>
            original position
            </summary>
        </member>
        <member name="P:u040.prespective.fact.RegionCutPlane.OriginRotation">
            <summary>
            original rotation
            </summary>
        </member>
        <member name="P:u040.prespective.fact.RegionCutPlane.ProjectionPlane">
            <summary>
            projected plane
            </summary>
        </member>
        <member name="M:u040.prespective.fact.RegionCutPlane.updatePositionAndRotation">
            <summary>
            update position and rotation from public variables
            </summary>
        </member>
        <member name="M:u040.prespective.fact.RegionCutPlane.BufferProfiles(System.Collections.Generic.List{u040.prespective.fact.PhysicalBodyBehavior})">
            <summary>
            buffers collision matrices profiles
            </summary>
        </member>
        <member name="M:u040.prespective.fact.RegionCutPlane.UpdateProfileName(System.String,System.String)">
            <summary>
            updates profile name
            </summary>
            <param name="_oldName">old name</param>
            <param name="_newName">new name</param>
        </member>
        <member name="M:u040.prespective.fact.RegionCutPlane.UpdateAllowedProfilesTable(System.Collections.Generic.List{u040.prespective.fact.PhysicalBodyBehavior},System.Collections.Generic.List{u040.prespective.fact.ProfileCollisionSettings},System.Boolean)">
            <summary>
            updates profiles
            </summary>
            <param name="_profiles">all current profiles present</param>
            <param name="_controllerSettings">controller settings of profiles</param>
            <param name="_forceUpdateThroughController">if should force the controller settings</param>
        </member>
        <member name="M:u040.prespective.fact.RegionCutPlane.SetAllowedProfile(System.String,System.String,System.Boolean)">
            <summary>
            set new allowed value for both matrices
            </summary>
            <param name="_a">profile name a</param>
            <param name="_b">profile name b</param>
            <param name="_allowed">if now allowed</param>
            <returns>successful</returns>
        </member>
        <member name="M:u040.prespective.fact.RegionCutPlane.SetProjectionPlane(u040.prespective.core.transformation.ADTransform)">
            <summary>
            Update the projection plane of this Cut through (after the owner has moved)
            </summary>
            <param name="_owner"></param>
        </member>
        <member name="F:u040.prespective.fact.CollisionMatrixPlaneData.ProfileName">
            <summary>
            profile name
            </summary>
        </member>
        <member name="F:u040.prespective.fact.CollisionMatrixPlaneData.Colliders">
            <summary>
            colliders that have collision
            </summary>
        </member>
        <member name="F:u040.prespective.fact.CollisionMatrixPlaneData.IfAllowed">
            <summary>
            is allowed collision
            </summary>
        </member>
        <member name="M:u040.prespective.fact.CollisionMatrixPlaneData.#ctor(u040.prespective.fact.PhysicalBodyBehavior,System.Collections.Generic.List{u040.prespective.fact.PhysicalBodyBehavior},u040.prespective.fact.CollisionMatrixPlaneData)">
            <summary>
            constructor
            </summary>
            <param name="_subject">behaviour to store</param>
            <param name="_allProfiles">all behaviours present</param>
            <param name="_existingProfileList">possible already present values</param>
        </member>
        <member name="M:u040.prespective.fact.CollisionMatrixPlaneData.#ctor(u040.prespective.fact.ProfileCollisionSettings)">
            <summary>
            constructor
            </summary>
            <param name="_controllerSettings">data from controller</param>
        </member>
        <member name="M:u040.prespective.fact.CollisionMatrixPlaneData.IsAllowed(System.String)">
            <summary>
            if profile is allowed to have collision
            </summary>
            <param name="_profileName">profile name</param>
            <returns>if allowed collision</returns>
        </member>
        <member name="T:u040.prespective.fact.BodyPlaneProjection">
            <summary>
            Class managing a single projection of a single shape (possibly with multiple hull projections as polygons) on a single plane
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjection.ProjectedHullMatches">
            <summary>
            
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjection.ProjectedOrigin">
            <summary>
            The projected origin
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjection.ProjectedHulls">
            <summary>
            The Projected Hull
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjection.PlanarTranslationDelta">
            <summary>
            The Delta translation this shape has made on this projection
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjection.PlanarClockwiseRotationDelta">
            <summary>
            The Delta rotation this shape has made on this projection
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjection.ProjectionPos">
            <summary>
            projected position
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjection.ProjectionRot">
            <summary>
            projected rotation
            </summary>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.GetWorldPoint(u040.prespective.math.doubles.DVector2)">
            <summary>
            gets world position point
            </summary>
            <param name="_point">plane point</param>
            <returns>plane point in world space</returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.GetWorldVector(u040.prespective.math.doubles.DVector2)">
            <summary>
            gets world vector
            </summary>
            <param name="_vector">plane vector</param>
            <returns>plane vector in world space</returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.GetWorldProjectedOrigin">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.GetLocalVector(u040.prespective.math.doubles.DVector3)">
            <summary>
            make world space vector plane vector
            </summary>
            <param name="_vector">world space vector</param>
            <returns>plane vector</returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.GetWorldProjections">
            <summary>
            Returns the Projected hulls as 3D World Coordinates 
            (by projection on the plane)
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.HullsCentroid">
            <summary>
            Returns the Centroid of all combines hulls part of this projection
            (WARNING : this is NOT the projected centre point of the shape but rather the weighted centre of all projected vertices)
            </summary>
            <returns>centroid</returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.Clone">
            <summary>
            Returns a clone of this projection
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.DEBUG_DrawWorldProjections(UnityEngine.Color,System.Single)">
            <summary>
            
            </summary>
            <param name="_color"></param>
            <param name="_duration"></param>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.Transform(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Transform this 2D Projection
            </summary>
            <param name="_translation"></param>
            <param name="_cwRotationDeg"></param>
            <param name="_originOffset"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.Transform(u040.prespective.math.doubles.DVector2,System.Double,u040.prespective.math.doubles.DVector2)">
            <summary>
            Transform this 2D Projection
            </summary>
            <param name="_translation"></param>
            <param name="_cwRotationDeg"></param>
            <param name="_wantedOriginWorldSpace"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.ClippingProjectionHulls(u040.prespective.math.doubles.DPlane,u040.prespective.fact.BodyPlaneProjection,u040.prespective.fact.BodyPlaneProjection,System.Double,System.Double,u040.prespective.fact.BodyPlaneProjection@,System.Collections.Generic.List{System.Collections.Generic.List{UnityEngine.Vector2Int}}@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_projectionPlane"></param>
            <param name="_projection1"></param>
            <param name="_projection2"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_clippingProjection"></param>
            <param name="_resultPolyAddresses"></param>
            <param name="_debug"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.ConvexProjectionHulls(u040.prespective.fact.BodyPlaneProjection,u040.prespective.fact.BodyPlaneProjection,System.Double)">
            <summary>
            Returns a Convex Projection hull containing both hulls in projection 1 and projection 2
            </summary>
            <param name="_projection1">the first projection with n projected hulls</param>
            <param name="_projection2">the second projection with n projected hulls</param>
            <param name="_margin">margin to check same points</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.FromIntersectionInfo(u040.prespective.math.doubles.DPlane,u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}})">
            <summary>
            Returns a Projection2D from new intersection Info
            </summary>
            <param name="_projectionPlane">the plane we're projecting on</param>
            <param name="_shapeOrigin">the origin of the shape in world space</param>
            <param name="_intersections">the intersection info we got from projecting this shape onto the plane</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjection.FromIntersectionInfo(u040.prespective.math.doubles.DPlane,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Returns a DPolygon2D from a list of Intersection Info (representing a single hull)
            </summary>
            <param name="_projectionPlane">the plane we're projecting on</param>
            <param name="_intersections">the intersection info making up a single hull</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.fact.ManagedMesh">
            <summary>
            Class to manage a single Mesh Instantiated in the world on a transform using a Mesh filter
            This class is used to buffer mesh data to make it available for off-thread use
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ManagedMesh.StoredDTransform">
            <summary>
            Reference to the Mesh filter used by this worldMesh
            
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ManagedMesh.localToWorldMatrix">
            <summary>
            The most recent transform matrix for this world mesh
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ManagedMesh.meshSignature">
            <summary>
            Retrieves the Mesh Signature describing the unique line segments that make up this mesh
            (Since a mesh can exist in multiple instances in the world this value is a reference to a static buffered list in the PhysicsUtility)
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ManagedMesh.LocalToWorldMatrix">
            <summary>
            local to world matrix on mesh stored here
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ManagedMesh.Vertices">
            <summary>
            vertices of mesh stored here
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ManagedMesh.#ctor(UnityEngine.MeshFilter,u040.prespective.core.transformation.ADTransform)">
            <summary>
            Create a new Managed World Mesh Instance
            (can only be called on main thread)
            <param name="_owner">object to process</param>
            <param name="_head">head of boolean</param>
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ManagedMesh.#ctor(UnityEngine.MeshFilter)">
            <summary>
            Create a new Managed World Mesh Instance
            (can only be called on main thread)
            <param name="_owner">object to process</param>
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ManagedMesh.getParentStructure(u040.prespective.core.transformation.ADTransform,u040.prespective.core.transformation.ADTransform)">
            <summary>
            gets all the parents of a transform to a certain parent
            </summary>
            <param name="_dtransformToProcess">begin</param>
            <param name="_endParent">parent to stop at</param>
            <returns>parent structure</returns>
        </member>
        <member name="M:u040.prespective.fact.ManagedMesh.UpdateTransformationMatrixOnthread">
            <summary>
            Update the Transformation Matrix for this object 
            (can only be called on main thread)
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ManagedMesh.UpdateTransformationMatrixOffthread(u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            Updates the Transformation matrix of this shape manually (can be executed off-thread)
            </summary>
            <param name="_headLocalToWorldMatrix"></param>
        </member>
        <member name="M:u040.prespective.fact.ManagedMesh.UpdateTransformationMatrixOffthread(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3)">
            <summary>
            Updates the Transformation matrix of this shape manually (can be executed off-thread)
            </summary>
            <param name="_translation"></param>
            <param name="_rotation"></param>
            <param name="_scale"></param>
        </member>
        <member name="M:u040.prespective.fact.ManagedMesh.GetMeshPlaneIntersection(u040.prespective.math.doubles.DPlane,System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}@)">
            <summary>
            Get the intersecting hull of this mesh with the plane
            </summary>
            <param name="_plane"></param>
            <param name="_thickness">thickness of plane</param>
            <param name="_orderedIntersections">resulting created intersections with plane</param>
            <returns>if found intersections with plane</returns>
        </member>
        <member name="T:u040.prespective.fact.BodyRegionRecord">
            <summary>
            Container data class for managing a Custom Physical Body that has entered the Custom Physics Region
            A single CompoundConvexShapeProjection instance can manage multiple planar projections of the shape to resolve interactions
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyRegionRecord.ProjectedShapeTransformPath">
            <summary>
            The path to the scene root of the projected Shape Transform
            (buffered here because off-thread actions cannot access this getter)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyRegionRecord.ProjectedShape">
            <summary>
            Reference to the shape that was projected
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyRegionRecord.WorldPosition">
            <summary>
            The last tracked position of this transform
            (Locally buffered so we can check the delta translation this tick)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyRegionRecord.WorldRotation">
            <summary>
            The last tracked rotation of this transform
            (Locally buffered so we can check the delta rotation this tick
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyRegionRecord.WorldTranslationDelta">
            <summary>
            Transition of this Shape in world space in the last tick - 
            Note that this value may differ from velocity because of user interference
            (Calculated every update)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyRegionRecord.WorldRotationDelta">
            <summary>
            Rotation of this shape in world space in the last tick
            Note that this value may differ from velocity because of user interference
            (Calculated every update
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyRegionRecord.ProjectionRecords">
            <summary>
            List with projections made on Cut Planes in previous ticks
            </summary>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.SyncWithWorldTransform">
            <summary>
            sync with projected shape transform
            </summary>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.TransformAfterCollision(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,u040.prespective.fact.BodyPlaneProjectionRecord,System.Action,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="_worldTranslation"></param>
            <param name="_worldRotation"></param>
            <param name="_originPlaneRecord"></param>
            <param name="_updateOwnRecord"></param>
            <param name=""></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.recalculateAllTransformHulls(u040.prespective.fact.BodyPlaneProjectionRecord,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,System.Double,System.Double)">
            <summary>
            
            </summary>
            <param name="_requester"></param>
            <param name="_translationDelta"></param>
            <param name="_rotationDelta"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.UpdateHullProjection(System.Collections.Generic.List{u040.prespective.fact.RegionCutPlane},System.Double,System.Double,System.Boolean)">
            <summary>
            Update projections of this Shape
            </summary>
            <param name="_projectionPlanes">list with all planes part of this region</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_forceNotManual">force the update to be done non manual</param>
            <returns>whether the hull projections were successfully updated</returns>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.UpdateHullProjection(System.Collections.Generic.List{u040.prespective.fact.RegionCutPlane},u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,System.Double,System.Double,System.Boolean)">
            <summary>
            Update projections of this Shape
            </summary>
            <param name="_projectionPlanes">list with all planes part of this region</param>
            <param name="_worldTranslation">translation in world space</param>
            <param name="_worldRotation">rotation delta in world space</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_forceNotManual">force the update to be done non manual</param>
            <returns>whether the hull projections were successfully updated</returns>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.transformHasChanged(System.Double,System.Double,u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DQuaternion@)">
            <summary>
            Test whether the transform has changed since the last test and update the recorded world transformation
            </summary>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <param name="_deltaTranslation">the translation that has been made</param>
            <param name="_deltaRotation">the rotation that has been made</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.GetProjectedShapeOutlines(u040.prespective.fact.RegionCutPlane,u040.prespective.math.doubles.DVector3[][]@,u040.prespective.math.doubles.DVector3[][]@,u040.prespective.math.doubles.DVector3[][]@,u040.prespective.math.doubles.DVector3@)">
            <summary>
            Returns the most recently calculated hulls as lists of coordinates in world space
            </summary>
            <param name="_cutPlane">reference to the cut-through plane to get the projections on</param>
            <param name="_lastFrameHulls">output hulls this projected shape was previously</param>
            <param name="_currentFrameHulls">output hulls this projected shape is this tick</param>
            <param name="_transitHulls">convex inclusion hull around the previous and current hulls</param>
            <returns>whether the sought plane has a projection of this shape</returns>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.GetPlaneProjectionRecordIndex(u040.prespective.fact.RegionCutPlane)">
            <summary>
            Retrieves the record index for a particular cut plane
            </summary>
            <param name="_soughtPlane">the cut-through plane to check for records of this shape</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyRegionRecord.CloneOfPlane(u040.prespective.fact.RegionCutPlane)">
            <summary>
            makes clone of record for specific plane
            </summary>
            <param name="_plane">plane</param>
            <returns>clone</returns>
        </member>
        <member name="F:u040.prespective.fact.ABooleanBodyModifier.Main">
            <summary>
            main hull the subtractions are done on
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABooleanBodyModifier.Subtractions">
            <summary>
            subtraction hulls
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABooleanBodyModifier.storedMeshesData">
            <summary>
            stored mesh data
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABooleanBodyModifier.storedMainLocalToWorldMatrix">
            <summary>
            stored mesh data
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ABooleanBodyModifier.Get2DHull(u040.prespective.math.doubles.DPlane,System.Double,System.Int32,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}}@)">
            <summary>
            gets 2D hulls of Boolean on given plane with thickness
            </summary>
            <param name="_plane">plane</param>
            <param name="_thickness">thickness</param>
            <param name="_allowedCollisions">which subtraction hulls are part of the processing indicators</param>
            <param name="_intersections">the intersections with the plane</param>
            <returns>boolean hulls</returns>
        </member>
        <member name="M:u040.prespective.fact.ABooleanBodyModifier.getMeshPlaneIntersection(UnityEngine.MeshFilter,u040.prespective.math.doubles.DPlane,System.Double,u040.prespective.core.transformation.ADTransform,u040.prespective.math.doubles.DPolygon2D@,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}@)">
            <summary>
            gets the polygon on the plane depending on thickness
            </summary>
            <param name="_mf">mesh filter</param>
            <param name="_plane">plane to project on</param>
            <param name="_thickness">thickness of plane</param>
            <param name="_head">head of boolean</param>
            <param name="_result">resulting created polygon</param>
            <param name="_intersections">the intersections with the plane</param>
            <returns>if polygon was created on plane</returns>
        </member>
        <member name="M:u040.prespective.fact.ABooleanBodyModifier.UpdateManagedMeshTransforms">
            <summary>
            updates the internally stored managed meshes
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ABooleanBodyModifier.UpdateManagedMeshTransformsOffThread(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3)">
            <summary>
            updates the internally stored managed meshes off thread
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ABooleanBodyModifier.GetConcreteExplicitType">
            <summary>
            Retrieve the preferred Concrete Explicit Inheritance Class of ABooleanBodyModifier 
            (which is located in a different assembly, so we need to index it in runtime)
            </summary>
        </member>
        <member name="T:u040.prespective.fact.SubtractionData">
            <summary>
            description of subtraction colliders
            </summary>
        </member>
        <member name="F:u040.prespective.fact.SubtractionData.Collider">
            <summary>
            collider
            </summary>
        </member>
        <member name="F:u040.prespective.fact.SubtractionData.ColliderLevel">
            <summary>
            indicates collider level (when to use) empty string is assumed to be always used
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.CustomPhysicsRegionList">
            <summary>
            region in the physics controller
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.UseStableState">
            <summary>
            if uses stable state in physics
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.AmountOfStableFrames">
            <summary>
            amount frames until stable state is determined
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.UseMultiPass">
            <summary>
            if uses multi pass
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.AmountOfPasses">
            <summary>
            amount of passes in multi pass
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.SupportedShapeProfiles">
            <summary>
            shape profiles
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.CollisionSettings">
            <summary>
            collision matrix
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.BufferedProfiles">
            <summary>
            buffered profiles
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.collisionBehaviors">
            <summary>
            collision behaviours
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.environmentalForceBehaviours">
            <summary>
            environmental behaviours
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.collisionProperties">
            <summary>
            collision properties
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.frictionBehaviours">
            <summary>
            friction behaviours
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.postCollisionBehaviours">
            <summary>
            post collision behaviours
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicsController.customPhysicsRegionManagerStored">
            <summary>
            Manager for all Physical Bodies in the scene
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.CollisionBehaviours">
            <summary>
            collision behaviours
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.EnvironmentalForceBehaviours">
            <summary>
            environmental behaviours
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.CollisionProperties">
            <summary>
            collision properties
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.FrictionForceBehaviours">
            <summary>
            friction behaviours
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.PostCollisioneBehaviours">
            <summary>
            post collision behaviours
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.PhysicalBodyPropertiesDB">
            <summary>
            database material properties
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.customPhysicsRegionManager">
            <summary>
            region manager
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.onAwake">
            <summary>
            unity awake function
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.updateOutsidePlaymode">
            <summary>
            unity update function
            </summary>
            <returns>successful</returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.onFixedUpdate">
            <summary>
            unity fixed update
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.resetAcceleration(System.Collections.Generic.List{u040.prespective.prepair.Body})">
            <summary>
            resets given bodies acceleration to zero
            </summary>
            <param name="_bodies">bodies</param>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.onNewCustomRegionFound(u040.prespective.fact.ARegion)">
            <summary>
            
            </summary>
            <param name="_foundRegion"></param>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.onCreateNewCustomRegion(System.UInt32,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="_customPhysicsRegionIdentifier"></param>
            <param name="_params"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.onRemoveCustomRegion(System.UInt32,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="_customPhysicsRegionIdentifier"></param>
            <param name="_params"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.onUpdateCustomRegion(System.UInt32,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="_customPhysicsRegionIdentifier"></param>
            <param name="_event"></param>
            <param name="_params"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.onDuplicateCustomRegion(System.UInt32,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            
            </summary>
            <param name="_customPhysicsRegionIdentifier"></param>
            <param name="_params"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.generateUniqueCustomPhysicsRegionIdentifier(System.Collections.Generic.List{u040.prespective.fact.ARegion})">
            <summary>
            
            </summary>
            <param name="_current"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.generateUniqueCustomPhysicsRegionIdentifier(System.Collections.Generic.List{u040.prespective.fact.ARegion},System.UInt32)">
            <summary>
            Generates a unique physical body identifier for a newly added physical body
            </summary>
            <param name="_current">the currently present physical bodies</param>
            <param name="_pass">the # of times we failed to create a unique identifier, at 1000 it throws an error</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.getCustomPhysicsRegionIndexByID(System.Collections.Generic.List{u040.prespective.fact.ARegion},System.UInt32)">
            <summary>
            Explicit Index finder for the Physical Bodies
            </summary>
            <param name="_options"></param>
            <param name="_id"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.AddNewProfile(u040.prespective.fact.PhysicalBodyBehavior)">
            <summary>
            
            </summary>
            <param name="_profile"></param>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.RemoveProfile(u040.prespective.fact.PhysicalBodyBehavior)">
            <summary>
            
            </summary>
            <param name="_profile"></param>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.UpdateAllowedProfilesTable">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.SetProfileName(u040.prespective.fact.PhysicalBodyBehavior,System.String)">
            <summary>
            
            </summary>
            <param name="_profile"></param>
            <param name="_name"></param>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.SetAllowedProfile(u040.prespective.fact.PhysicalBodyBehavior,u040.prespective.fact.PhysicalBodyBehavior,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_allowed"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.bufferProfiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.OnBeforeSerialize">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicsController.OnAfterDeserialize">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicsController.GetConcreteExplicitType">
            <summary>
            Retrieve the preferred Concrete Explicit Inheritance Class of APhysicsController 
            (which is located in a different assembly, so we need to index it in runtime)
            </summary>
        </member>
        <member name="T:u040.prespective.fact.APhysicalBody">
            <summary>
            A Custom Physical Body is a Custom Body that is constrained via
            Physical Contacts (collisions) with its geometry
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.ShowDebuggingInfo">
            <summary>
            Identifier for this Compound Convex Shape
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.DebuggingOffsetTranslation">
            <summary>
            debugging translation offset
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.DebuggingOffsetRotationEuler">
            <summary>
            debugging rotation offset
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.IsTranslationStatic">
            <summary>
            if can be translated
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.IsRotationStatic">
            <summary>
            if it can be rotated
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.GoverningRegions">
            <summary>
            Custom Physics regions this shape is currently being governed by
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.WorldPosition">
            <summary>
            its world position
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.WorldRotation">
            <summary>
            its world rotation
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.FurthestCPVertDistance">
            <summary>
            Unique line signatures of collider meshes that make up this compound shape (used to create a convex hull projection)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.Intersections">
            <summary>
            collision properties information
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.StaticFriction">
            <summary>
            static friction
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.DynamicsFriction">
            <summary>
            dynamic friction
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.boolean2DGen">
            <summary>
            Boolean modifier of this body
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.rigidBody">
            <summary>
            rigid body of this body
            </summary>
        </member>
        <member name="F:u040.prespective.fact.APhysicalBody.appliedEnvironmentalForceBehaviorsThisTick">
            <summary>
            List with Environmental force behaviours that have been applied this tick (to make sure unique behaviour like gravity isn't applied twice)
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicalBody.CenterOfGravity">
            <summary>
            centre of gravity of physical body
            </summary>
        </member>
        <member name="P:u040.prespective.fact.APhysicalBody.RigidBody">
            <summary>
            rigid body connected to physical body
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.ApplyEnvironmentalForceBehavior(u040.prespective.fact.PhysicsBehavior)">
            <summary>
            Attempt to apply an Environmental force behaviour, only allowed if we do not exceed the max number of applications of this behaviour per tick
            </summary>
            <param name="_behavior"></param>
            <returns>whether the behaviour may be applied</returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.Start">
            <summary>
            unity start function
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.setFurthestVertDistanceFromCenter">
            <summary>
            Loops through the contained meshes and finds the vert furthest from the centre of the gameObject
            (we need this point to determine if objects run the risk of intersecting, and need to run a clipping algorithm)
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.init">
            <summary>
            initializes the stored components of this object
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.bufferPhysicalState">
            <summary>
            Enumerator that records the acceleration and velocity of this compound shapes' rigid body
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.UpdateOnThreadManagedWorldMeshes">
            <summary>
            updates projections on thread from DTransforms
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.UpdateTransformOffthread(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            updates projection off thread with given values
            </summary>
            <param name="_translation">translation</param>
            <param name="_rotation">rotation added</param>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.UpdateShapeTransformCausedByVelocity(System.Double,System.Boolean)">
            <summary>
            updates body with given velocity and acceleration
            </summary>
            <param name="_deltaTime">delta time</param>
            <param name="_updateManagedColliders"></param>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.UpdateShapeTransformCausedByMovement">
            <summary>
            reconnect stored position rotation to DTransform
            </summary>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.updateMatricesOffThread(u040.prespective.fact.ABooleanBodyModifier,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3)">
            <summary>
            updates stored matrices
            </summary>
            <param name="_boolean">boolean body modifier</param>
            <param name="_translation">added translation</param>
            <param name="_rotation">added rotation</param>
            <param name="_scale">scale of DTransform</param>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.HasEnteredRegion(u040.prespective.fact.ARegion,UnityEngine.Collider)">
            <summary>
            if entered region
            </summary>
            <param name="_region">region has entered</param>
            <param name="_c">collider that has entered</param>
            <returns>if has entered region</returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.HasExitedRegion(u040.prespective.fact.ARegion,UnityEngine.Collider)">
            <summary>
            if exited region
            </summary>
            <param name="_region">region has exited</param>
            <param name="_c">collider that has exited</param>
            <returns>if has exited region</returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.GetProjectionHullOnPlane(u040.prespective.fact.RegionCutPlane,System.Boolean,System.Boolean@,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}}@)">
            <summary>
            get projected hull on plane
            </summary>
            <param name="_planeWithProjection">plane</param>
            <param name="_debug">show debug</param>
            <param name="_hasIntersectionsOnPlane">has projection on plane</param>
            <param name="_shapeProjectionInfo"></param>
            <returns>body plane projection</returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.getCyclicPlanarIntersections(u040.prespective.fact.RegionCutPlane,u040.prespective.math.doubles.DVector3@,System.Boolean@,System.Boolean)">
            <summary>
            Returns the intersections a Compound Shape has with a DPlane (Cut-through)
            </summary>
            <param name="_cutPlane">the cut plane to intersect with</param>
            <param name="_projectedCompoundOrigin"></param>
            <param name="_hasIntersections"></param>
            <param name="_debug"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.APhysicalBody.Clone">
            <summary>
            clones physical body and the game object it is on
            </summary>
            <returns>clone</returns>
        </member>
        <member name="P:u040.prespective.fact.APhysicalBody.GetConcreteExplicitType">
            <summary>
            Retrieve the preferred Concrete Explicit Inheritance Class of APhysicalBody 
            (which is located in a different assembly, so we need to index it in runtime)
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyIntersection.IntersectionObject">
            <summary>
            intersection object
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyIntersection.Contact">
            <summary>
            contact data
            </summary>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyIntersection.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyIntersection.#ctor(u040.prespective.fact.APhysicalBody)">
            <summary>
            constructor
            </summary>
            <param name="_dummyIntersectionObject">intersection object</param>
        </member>
        <member name="F:u040.prespective.fact.ContactData.OverlapArea2D">
            <summary>
            overlap area
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ContactData.ContactObject">
            <summary>
            contact object
            </summary>
        </member>
        <member name="T:u040.prespective.fact.BodyPlaneProjectionRecord">
            <summary>
            Record of a single Custom Physical body on a single plane in a single Custom Physics region
            Used to calculate shape-shape collisions on that plane
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjectionRecord.PlaneWithProjection">
            <summary>
            The plane containing the projection
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjectionRecord.IsOnPlane">
            <summary>
            is on plane
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjectionRecord.shapeProjections2D">
            <summary>
            Reference to all Projection Hulls from old to new
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjectionRecord.originalPlanarTranslationVector">
            <summary>
            original translation done
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjectionRecord.newTranslationDirection">
            <summary>
            new translation direction
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjectionRecord.remainingMagnitudeOverride">
            <summary>
            magnitude of new translation
            </summary>
        </member>
        <member name="F:u040.prespective.fact.BodyPlaneProjectionRecord.projectionTransformHulls">
            <summary>
            Set of Convex Hulls describing how the different previous projection hulls transformed into the different current projection hulls
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.PreviousBodyProjection">
            <summary>
            2D Previous Projection Hulls
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.CurrentBodyProjection">
            <summary>
            2D Current Projection Hulls
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.PreviousProjectedOrginInWorldSpace">
            <summary>
            gets previous projected origin in world space
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.CurrentProjectedOrginInWorldSpace">
            <summary>
            gets current projected origin in world space
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.ProjectMovementVectorFromCurrentAndPrevious">
            <summary>
            gets the projected movement vector in world space from the current en previous projections
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.CurrentProjectionTransformHulls">
            <summary>
            movement hulls of body
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.CurrentWorldShapeOrigin">
            <summary>
            Transformation to world space of the shape origin as projected on this plane
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.PlanarTranslationVector">
            <summary>
            Translation vector on this shape
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.OriginalPlanarTranslationVector">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.fact.BodyPlaneProjectionRecord.RemainingPlanarTranslationVector">
            <summary>
            remaining translation vector
            </summary>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.WorldVector(u040.prespective.math.doubles.DVector2)">
            <summary>
            get vector in world space
            </summary>
            <param name="_planarVector"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.WorldPoint(u040.prespective.math.doubles.DVector2)">
            <summary>
            gets point in world space
            </summary>
            <param name="_planarPoint"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.AddShapeIntersectionProjection2D(u040.prespective.fact.BodyPlaneProjection,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double)">
            <summary>
            During a solver pass shape projections may be added to divert the path of the shape due to intersections
            The first time this happens the current shape projection is buffered to 
            </summary>
            <param name="_bodyProjection"></param>
            <param name="_newDirection"></param>
            <param name="_perpendicularOffset"></param>
            <param name="_margin"></param>
            <param name="_magnitudeOverride"></param>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.RebuildProjectionOnCollisionOnOtherPlane(u040.prespective.fact.APhysicalBody,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,System.Double,System.Double)">
            <summary>
            rebuilds projections on other planes after transform change
            </summary>
            <param name="_shape">body</param>
            <param name="_translationDelta">translation done</param>
            <param name="_rotationDelta">rotation done</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.UpdateProjection(u040.prespective.fact.APhysicalBody,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion,System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Update this projection record
            
            OPTIMIZATION : currently this script requires about 4.75ms per calculation, resulting in about 40% of tick costs
            </summary>
            <param name="_shape"></param>
            <param name="_shapePosition"></param>
            <param name="_translationDelta"></param>
            <param name="_rotationDelta"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_debug"></param>
            <param name="_forceNotManual">force the update to be done non manual</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.resetProjectionRecord">
            <summary>
            resets projections
            </summary>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.createNewMovementHull(u040.prespective.fact.BodyPlaneProjection,u040.prespective.fact.BodyPlaneProjection,System.Double)">
            <summary>
            creates new movement hull between projections
            </summary>
            <param name="_from">from projection</param>
            <param name="_to">to projection</param>
            <param name="_margin">margin</param>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.hasRotatableProjection(u040.prespective.math.doubles.DQuaternion,System.Double,System.Double@)">
            <summary>
            Whether the rotation this shape has made this tick can be resolved for this projection simply by manual translation (Vector Quaternion multiplication)
            This is only true when the shape has only rotated perpendicularly on the projection plane
            </summary>
            <param name="_plane">the plane this projection is on</param>
            <param name="_rotation">the rotation this shape made in world space this tick</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.hasTranslatableProjection(u040.prespective.math.doubles.DVector3,System.Double,u040.prespective.math.doubles.DVector3@)">
            <summary>
            
            </summary>
            <param name="_translationDeltaInLastTick"></param>
            <param name="_margin"></param>
            <param name="_planarTranslation"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.BodyPlaneProjectionRecord.Clone">
            <summary>
            makes clone of 
            </summary>
            <returns>clone</returns>
        </member>
        <member name="T:u040.prespective.fact.PhysicalBodyBehavior">
            <summary>
            Behaviour Profile for shapes targeted on a particular profile
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.ProfileName">
            <summary>
            Description of this profile 
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.AppliedEnvironmentalForceBehaviors">
            <summary>
            List of the environmental force behaviours that are applied to shapes fitting this profile every tick
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.AppliedCollisionBehaviour">
            <summary>
            collision behaviour that are applied to shapes fitting this profile every tick
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.AppliedCollisionProperties">
            <summary>
            List of the environmental force behaviours that are applied to shapes fitting this profile every tick
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.AppliedFrictionBehaviours">
            <summary>
            List of the friction behaviours that are applied to shapes fitting this profile every tick
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.AppliedPostCollsionBehaviours">
            <summary>
            List of the post collision behaviours that are applied to shapes fitting this profile every tick
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.bufferedEnvironmentalForceBehaviors">
            <summary>
            buffered environmental behaviours functions
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.bufferedCollisionBehavior">
            <summary>
            buffered collision behaviours functions
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.bufferedCollisionProperties">
            <summary>
            buffered collision properties functions
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.bufferedFrictionBehaviours">
            <summary>
            buffered friction behaviour functions
            </summary>
        </member>
        <member name="F:u040.prespective.fact.PhysicalBodyBehavior.bufferedPostCollisionBehaviours">
            <summary>
            buffered post collision behaviour functions
            </summary>
        </member>
        <member name="P:u040.prespective.fact.PhysicalBodyBehavior.BufferedEnvironmentalForceBehaviors">
            <summary>
            Lazy loader for the Environmental Force Instance behaviours that should affect this profile
            </summary>
        </member>
        <member name="P:u040.prespective.fact.PhysicalBodyBehavior.BufferedCollisionBehavior">
            <summary>
            Lazy loader for the Collision Instance behaviours that should affect this profile
            </summary>
        </member>
        <member name="P:u040.prespective.fact.PhysicalBodyBehavior.BufferedCollisionProperties">
            <summary>
            Lazy loader for the Environmental Force Instance behaviours that should affect this profile
            </summary>
        </member>
        <member name="P:u040.prespective.fact.PhysicalBodyBehavior.BufferedFrictionBehaviours">
            <summary>
            Lazy loader for the Friction Instance behaviours that should affect this profile
            </summary>
        </member>
        <member name="P:u040.prespective.fact.PhysicalBodyBehavior.BufferedPostCollisionBehaviours">
            <summary>
            Lazy loader for the Post Collision Instance behaviours that should affect this profile
            </summary>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyBehavior.EnactEnvironmentalForce(u040.prespective.fact.BodyRegionRecord,System.Double,System.Double,System.Double)">
            <summary>
            Enact the environmental force behaviours in this profile on a shape in this region
            </summary>
            <param name="_requestingBody"></param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyBehavior.EnactCollisionBehaviors(u040.prespective.fact.collision.CollisionComparisonRecord,System.Double,System.Double,System.Collections.Generic.List{u040.prespective.prepair.IntentData}@)">
            <summary>
            Enact the Collision behaviours in this profile on a shape in this region
            </summary>
            <param name="_collisionComparisonRecord"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <param name="_intentList"></param>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyBehavior.mergeIntentLists(System.Collections.Generic.List{u040.prespective.fact.collision.CollisionIntentData},System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.prepair.IntentData}},System.Collections.Generic.List{System.Int32})">
            <summary>
            merges the intents after post collision
            </summary>
            <param name="_intent">original intents of collision</param>
            <param name="_postCollisionIntents">intents of the post collisions</param>
            <param name="_postCollisionAmountIntents">the amount of intents per post collision</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyBehavior.EnactCollisionProperties(u040.prespective.fact.APhysicalBody,u040.prespective.fact.BodyPlaneProjection[],u040.prespective.fact.APhysicalBody[],u040.prespective.fact.BodyPlaneProjection[][],System.Double,System.Double)">
            <summary>
            enacts getting collision properties
            </summary>
            <param name="_bodySelf">body with collision property</param>
            <param name="_selfProjection">projections of body with collision property</param>
            <param name="_bodiesOther">other bodies</param>
            <param name="_otherProjections">projections of other bodies</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyBehavior.EnactFrictionBehaviourMovement(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            enacts movement friction
            </summary>
            <param name="_bodySelf">body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="M:u040.prespective.fact.PhysicalBodyBehavior.EnactFrictionBehaviourVelocity(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            enacts velocity friction
            </summary>
            <param name="_bodySelf">body</param>
            <param name="_deltaTime">delta time</param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.lastPosition">
            <summary>
            position of previous measurement
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.lastVelicoty">
            <summary>
            velocity of previous measurement
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.lastRotation">
            <summary>
            rotation of previous measurement
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.lastAngularVelicoty">
            <summary>
            angular velocity of previous measurement
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.position">
            <summary>
            current position
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.velocity">
            <summary>
            current velocity
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.acceleration">
            <summary>
            current acceleration
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.rotation">
            <summary>
            current rotation
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.angularVelocity">
            <summary>
            current angular velocity
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.angularAcceleration">
            <summary>
            current angular acceleration
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ABasicProbe.dtransform">
            <summary>
            double transform
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.init">
            <summary>
            initializes values on start
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.getValues(System.Double)">
            <summary>
            gets the values measured here
            </summary>
            <param name="_deltaTime">amount of time between measurements</param>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.getVelocity(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            gets the velocity here
            </summary>
            <param name="_currentPosition">current position</param>
            <param name="_deltaTime">amount of time between measurements</param>
            <returns>speed</returns>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.getAcceleration(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            gets the acceleration here
            </summary>
            <param name="_currentVelocity">current velocity</param>
            <param name="_deltaTime">amount of time between measurements</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.getAngularVelocity(u040.prespective.math.doubles.DQuaternion,System.Double)">
            <summary>
            gets the angular velocity here
            </summary>
            <param name="_currentRotation">current rotation</param>
            <param name="_deltaTime">amount of time between measurements</param>
            <returns>angular velocity</returns>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.getAngularAcceleration(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            gets angular acceleration here
            </summary>
            <param name="_currentVelocity">current velocity</param>
            <param name="_deltaTime">amount of time between measurements</param>
            <returns>angular acceleration</returns>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.show(System.Double)">
            <summary>
            shows the values
            </summary>
            <param name="_deltaTime">amount of time between measurements</param>
        </member>
        <member name="M:u040.prespective.fact.ABasicProbe.syncValues">
            <summary>
            stores current values as previous values
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ABasicProbe.GetConcreteExplicitType">
            <summary>
            Retrieve the preferred Concrete Explicit Inheritance Class of ABasicProbe 
            (which is located in a different assembly, so we need to index it in runtime)
            </summary>
        </member>
        <member name="M:u040.prespective.fact.FrictionBehaviour.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:u040.prespective.fact.FrictionBehaviour.BehaviorName">
            <summary>
            friction name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.FrictionBehaviour.MovementFrictionUpdate(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            basic function what to do with friction when other body is moved but not by velocity
            </summary>
            <param name="_body"></param>
            <param name="_deltaTime"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="M:u040.prespective.fact.FrictionBehaviour.VelocityFrictionUpdate(u040.prespective.fact.APhysicalBody,System.Double,System.Double,System.Double)">
            <summary>
            basic function what to do with friction if other body is moved through speed, acceleration
            </summary>
            <param name="_body"></param>
            <param name="_deltaTime"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
        </member>
        <member name="F:u040.prespective.fact.StableState.PhysicalBodyID">
            <summary>
            id
            </summary>
        </member>
        <member name="F:u040.prespective.fact.StableState.PhysicalBodyName">
            <summary>
            name
            </summary>
        </member>
        <member name="F:u040.prespective.fact.StableState.AmountOfStableFrames">
            <summary>
            amount of stable frames
            </summary>
        </member>
        <member name="F:u040.prespective.fact.StableState.ConnectedBodies">
            <summary>
            connected bodies
            </summary>
        </member>
        <member name="M:u040.prespective.fact.StableState.#ctor(System.UInt32,System.UInt32,System.Collections.Generic.List{System.UInt32})">
            <summary>
            constructor
            </summary>
            <param name="_physicalBodyId">physical body id</param>
            <param name="_amountOfStableFrames">amount of frames seen stable state</param>
            <param name="_connectedBodies">connected bodies</param>
        </member>
        <member name="M:u040.prespective.fact.StableState.#ctor(System.UInt32,System.String,System.UInt32,System.Collections.Generic.List{System.UInt32})">
            <summary>
            constructor
            </summary>
            <param name="_physicalBodyId">physical body id</param>
            <param name="_physicalBodyName">body name</param>
            <param name="_amountOfStableFrames">amount of frames seen stable state</param>
            <param name="_connectedBodies">connected bodies</param>
        </member>
        <member name="M:u040.prespective.fact.StableState.Reset">
            <summary>
            reset stable state
            </summary>
        </member>
        <member name="M:u040.prespective.fact.StableState.IsStable(System.UInt32)">
            <summary>
            check if stable
            </summary>
            <param name="_limitFrames">amount frames already stable</param>
            <returns>if stable</returns>
        </member>
        <member name="T:u040.prespective.fact.PhysicsBehavior">
            <summary>
            <description>
            Abstract class to get environmental behaviour
            </description>
            <version 
                version="1.0.0" 
                author="TGE" 
                date="200611">
                //first version
            </version>
            </summary>
        </member>
        <member name="M:u040.prespective.fact.PhysicsBehavior.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="P:u040.prespective.fact.PhysicsBehavior.MaxApplicationsPerTick">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.fact.PhysicsBehavior.BehaviorName">
            <summary>
            behaviour name
            </summary>
        </member>
        <member name="M:u040.prespective.fact.PhysicsBehavior.EnactBehavior(u040.prespective.fact.BodyRegionRecord,System.Double,System.Double,System.Double)">
            <summary>
            basic function to do a environmental behaviour
            </summary>
            <param name="_projection"></param>
            <param name="_deltaTime"></param>
            <param name="_distanceMargin"></param>
            <param name="_angleMargin"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.debugging.DebuggingDrawingPhysics.AddDrawing(u040.prespective.utility.editorui.scenewindow.DebuggingCanvasPolygon2D,System.String,System.String,u040.prespective.fact.BodyPlaneProjection,UnityEngine.Color,System.Int32)">
            <summary>
            adds a physics drawing to canvas
            </summary>
            <param name="_canvas">canvas</param>
            <param name="_canvasName">canvas name</param>
            <param name="_drawingName">drawing name</param>
            <param name="_bodyProjection">body projection want to draw</param>
            <param name="_colour">colour of drawing</param>
            <param name="_layerIndex">layer index</param>
        </member>
        <member name="F:u040.prespective.fact.ARegion.PhysicsRegionID">
            <summary>
            Physics Region Unique Identifier
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.Priority">
            <summary>
            Priority of physics region 
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.ShowInSceneWhenNotselected">
            <summary>
            Whether to show the projections in the scene when this game object is not selected
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.ShowCutPlaneFills">
            <summary>
            if cut plane are filled in inspector
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.CutProjections">
            <summary>
            List with Planes that provide a Cut-through Convex Hull to test intersections against
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.ActiveProjections">
            <summary>
            A list with projections of shapes that are controlled by this physics region
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.AngleMargin">
            <summary>
            angle margin used in region
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.DistanceMargin">
            <summary>
            distance margin used in region
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.storedPosition">
            <summary>
            The last tracked position of this transform
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.storedRotation">
            <summary>
            The last tracked rotation of this transform
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.kineticChains">
            <summary>
            Kinematic Chains per direction per kinematic object
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.dtransform">
            <summary>
            connected DTransform
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.regionCornerPointsStored">
            <summary>
            Buffered list with region corner points (for Cut-projection drawing); updated when this transform changes
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.regionCollider">
            <summary>
            Reference to the collider describing this region
            </summary>
        </member>
        <member name="F:u040.prespective.fact.ARegion.kinematicPhysicsBodyConnections">
            <summary>
            stores the kinematic body connections to physical bodies
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.Controller">
            <summary>
            Linkage to the Physics Controller
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.CurrentCollisions">
            <summary>
            current collisions
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.DTransform">
            <summary>
            its DTransform
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.activeCutProjections">
            <summary>
            active cut plane projections in this region
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.sortedProjections">
            <summary>
            sorted projections
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.regionCornerPoints">
            <summary>
            Retrieves the world position region corner points; only regenerates when the region transforms
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.RegionCollider">
            <summary>
            box collider region
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.Size">
            <summary>
            size region
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.stableStateList">
            <summary>
            list of stable states
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.OnEnable">
            <summary>
            unity on enabled
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.OnDisable">
            <summary>
            unity on disabled
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.Update">
            <summary>
            unity update
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.GetPlaneRegionIntersectionPoints(System.Int32)">
            <summary>
            Returns a list of global Vertices describing the cyclic hull where they intersect
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.GetPlaneRegionIntersectionPoints(u040.prespective.math.doubles.DPlane)">
            <summary>
            Returns a list of global Vertices describing the cyclic hull where they intersect
            </summary>
            <param name="_plane"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getProjectionPlane(System.Int32)">
            <summary>
            gets projection plane on given index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.Start">
            <summary>
            unity start function
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.OnTriggerEnter(UnityEngine.Collider)">
            <summary>
            Actions performed when a collider comes into contact with this region trigger
            </summary>
            <param name="_other">the collider entering this region</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.OnTriggerExit(UnityEngine.Collider)">
            <summary>
            Actions performed when a Collider leaves this region trigger
            </summary>
            <param name="_other">the collider leaving this region</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.includeShapeInProjection(UnityEngine.Collider,u040.prespective.fact.APhysicalBody)">
            <summary>
            On entering the region, include a Compound Convex Shape in the calculation loop as projection(s)
            </summary>
            <param name="_shapeCollider"></param>
            <param name="_newShape"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.removeShapeFromProjection(UnityEngine.Collider,u040.prespective.fact.APhysicalBody)">
            <summary>
            On leaving the region, remove aCustomPhysicalBody from the calculation loop as projection(s)
            </summary>
            <param name="_shapeCollider"></param>
            <param name="_shapeToRemove"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getActiveProjectionIndexForCustomPhysicalBody(u040.prespective.fact.APhysicalBody)">
            <summary>
            Get the index of a Projected Compound Convex shape participating in the loop
            </summary>
            <param name="_soughtShape"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.sortProjectionList(System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord},u040.prespective.math.doubles.DVector3,u040.prespective.fact.BodyRegionRecord)">
            <summary>
            Sort the projections for the order of collision solving
            </summary>
            <param name="_projections"></param>
            <param name="_directionDVector3"></param>
            <param name="_activeBody"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.UpdateRegion(System.Double)">
            <summary>
            Updates the this region's collision caused by (kinematic) movement
            </summary>
            <param name="_deltaTime"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.UpdateRegionEnvForce(System.Collections.Generic.List{u040.prespective.prepair.IntentData},System.Double)">
            <summary>
            Updates the region by enacting environmental forces and solve collisions caused by environmental forces
            </summary>
            <param name="_previousAppliedEvironmentalForces"></param>
            <param name="_deltaTime"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.enactCustomEnvironmentalForces(System.Collections.Generic.List{u040.prespective.prepair.IntentData},System.Double,System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord}@,System.Collections.Generic.List{u040.prespective.prepair.IntentData}@)">
            <summary>
            Applies Environmental forces
            </summary>
            <param name="_deltaTime"></param>
            <param name="_previousAppliedEvironmentalForces"></param>
            <param name="_appliedForcesShapeRegionRecords"></param>
            <param name="_appliedEnvironmentalForces"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getCollisionProperties(System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord},System.Collections.Generic.List{u040.prespective.fact.PhysicalBodyBehavior})">
            <summary>
            gets the collision properties
            </summary>
            <param name="_records">records of the region</param>
            <param name="_shapes">physical bodies shapes</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.updateRegionTransformDelta">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.syncActiveProjectionsWithWorldTransform(System.Boolean)">
            <summary>
            
            </summary>
            <param name="_onlySyncDtransformBuffer"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.transformHasChanged(u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DQuaternion@)">
            <summary>
            Test whether the transform has changed since the last test
            </summary>
            <param name="_translation">the translation that has been made</param>
            <param name="_rotation">the rotation that has been made</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.updateAfterChangedTransform(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Perform the required updates after this transform has changed
            </summary>
            <param name="_translation">the translation that was made</param>
            <param name="_rotation">the rotation that was made</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.regenerateRegionCornerPoints">
            <summary>
            Force the region corner points to regenerate (performed after a transform)
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.solveCollisions(System.Collections.Generic.List{u040.prespective.fact.RegionCutPlane},System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord},System.Collections.Generic.List{u040.prespective.prepair.IntentData},System.Double)">
            <summary>
            Resolve collisions in (optionally) multiple passes
            </summary>
            <param name="_planes">the planes to resolve collisions on</param>
            <param name="_currentProjections">the projections to use</param>
            <param name="_appliedEnvironmentalForces">intents of environmental behaviours</param>
            <param name="_deltaTime">delta time</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.kineticChainAddOrUpdate(u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.fact.BodyRegionRecord,u040.prespective.math.doubles.DVector3)">
            <summary>
            Add or update colliding objects to the kinetic chain
            </summary>
            <param name="_currentCollision"></param>
            <param name="_projection"></param>
            <param name="_direction"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.kineticChainBlocked(System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord},System.Collections.Generic.List{u040.prespective.prepair.IntentData},System.Collections.Generic.List{u040.prespective.prepair.IntentData},u040.prespective.fact.collision.CollisionComparisonRecord,u040.prespective.math.doubles.DVector3,u040.prespective.fact.BodyRegionRecord)">
            <summary>
            Checks whether the kinetic chain is blocked and fire the block4d event to the kinematic body 
            </summary>
            <param name="_currentProjections"></param>
            <param name="_appliedEnvironmentalForces"></param>
            <param name="_intentList"></param>
            <param name="_currentCollision"></param>
            <param name="_direction"></param>
            <param name="_projection"></param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.UpdateStableState(System.Collections.Generic.List{u040.prespective.prepair.IntentData},System.Boolean)">
            <summary>
            Updates the stable state of all bodies from the intent data list
            </summary>
            <param name="_intentList">intent list to check for stable state</param>
            <param name="_environmentalUpdate">boolean that shows update comes from environmental force region update</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.checkBody(u040.prespective.prepair.Body,u040.prespective.prepair.IntentData,System.Boolean)">
            <summary>
            Checks body for being stable
            </summary>
            <param name="_bodyToCheck">Body to check</param>
            <param name="_intentData">intent list to check for stable state</param>
            <param name="_environmentalUpdate">boolean that shows update comes from environmental force region update</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getChildBodies(System.UInt32)">
            <summary>
            retrieves a list of uints of connected bodies
            </summary>
            <param name="_parentBodyID"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getBodyFromBodyId(System.UInt32)">
            <summary>
            Get body from specified ID
            </summary>
            <param name="_bodyID"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.generateStableStateIntentInfo(System.Collections.Generic.List{u040.prespective.prepair.IntentData},System.Collections.Generic.List{u040.prespective.prepair.IntentData})">
            <summary>
            Match the intent data from the environmental forces with the environmental force solving and return resultant intent
            </summary>
            <param name="_forceData">intent data coming from environmental forces</param>
            <param name="_solverData">intent data coming from the solving of the environmental forces</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.ResetInConnectedBodies(System.UInt32)">
            <summary>
            Reset Stable state also in connected bodies
            </summary>
            <param name="_bodyID">body ID</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getStableState(System.UInt32)">
            <summary>
            Returns the stable state for a given body ID
            </summary>
            <param name="_bodyID">Body ID</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getMostActiveShape(System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord})">
            <summary>
            Returns the shape with the highest world delta
            </summary>
            <param name="_projections">List of Body Region Records</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getActiveProjectionNameForCustomPhysicalBody(System.UInt32)">
            <summary>
            Get the name of the Custom Physical body by index
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getComparedCollision(System.Collections.Generic.List{u040.prespective.fact.RegionCutPlane},u040.prespective.fact.BodyRegionRecord,System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord},System.Int32,System.Double)">
            <summary>
            get collision comparison records
            </summary>
            <param name="_planes"></param>
            <param name="_projection"></param>
            <param name="_currentProjections"></param>
            <param name="_projectionIndex"></param>
            <param name="_deltaTime"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getAllCollisionsUpTo(System.Collections.Generic.List{u040.prespective.fact.RegionCutPlane},u040.prespective.fact.BodyRegionRecord,System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord},System.Int32)">
            <summary>
            Get all current collisions
            </summary>
            <param name="_projectionPlanes"></param>
            <param name="_sender"></param>
            <param name="_projections"></param>
            <param name="_max"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getProjectedHullCollisions(u040.prespective.fact.RegionCutPlane,u040.prespective.fact.BodyRegionRecord,u040.prespective.fact.BodyPlaneProjectionRecord,u040.prespective.fact.BodyRegionRecord,u040.prespective.fact.BodyPlaneProjectionRecord,u040.prespective.fact.collision.BodyCollisionRecord@)">
            <summary>
            Check if the collision is valid and return the found collision list
            </summary>
            <param name="_plane"></param>
            <param name="_projection1"></param>
            <param name="_pRecord1"></param>
            <param name="_projection2"></param>
            <param name="_pRecord2"></param>
            <param name="_foundCollisions"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getShapeProfileIndex(System.String)">
            <summary>
            Get the index of a group (ID) that should participate in this regions' simulations; returns -1 if not found
            </summary>
            <param name="_shapeResponseGroupID">ID to look for</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.normalizedDirectionVector(u040.prespective.math.doubles.DVector3)">
            <summary>
            
            </summary>
            <param name="_rawDVector3"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.doMultiPass(System.Int32,u040.prespective.fact.collision.CollisionComparisonRecord,System.Collections.Generic.List{u040.prespective.fact.BodyRegionRecord},System.Collections.Generic.List{u040.prespective.prepair.IntentData},u040.prespective.fact.RegionCutPlane,System.Int32,System.Double)">
            <summary>
            does a multi pass of given collision (it is assumed the first pass is already done)
            </summary>
            <param name="_maxPasses">maximum amount of passes</param>
            <param name="_collision">original collision</param>
            <param name="_currentProjections">body records</param>
            <param name="_intentList">intents of collision first pass</param>
            <param name="_plane">plane of collision</param>
            <param name="_uptoLevel">up to level</param>
            <param name="_deltaTime">plane of collision</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getPhysicsID(u040.prespective.prepair.kinematics.KinematicBody)">
            <summary>
            gets kinematic body physics body id
            </summary>
            <param name="_body">kinematic body</param>
            <returns>physics body id</returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getPhysicsProfile(u040.prespective.prepair.kinematics.KinematicBody)">
            <summary>
            gets kinematic body physics profile
            </summary>
            <param name="_body">kinematic body</param>
            <returns>profile</returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getPhysicsBody(u040.prespective.prepair.kinematics.KinematicBody)">
            <summary>
            gets kinematics body connected physics body
            </summary>
            <param name="_body">kinematic body</param>
            <returns>physics body</returns>
        </member>
        <member name="P:u040.prespective.fact.ARegion.GetConcreteExplicitType">
            <summary>
            Retrieve the preferred Concrete Explicit Inheritance Class of ARegion 
            (which is located in a different assembly, so we need to index it in runtime)
            </summary>
        </member>
        <member name="P:u040.prespective.fact.ARegion.SupportedShapeProfiles">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.getBufferedProfiles(u040.prespective.fact.RegionCutPlane)">
            <summary>
            gets the buffered profiles to use here
            </summary>
            <param name="_plane">cut plane</param>
            <returns>buffered profiles</returns>
        </member>
        <member name="M:u040.prespective.fact.ARegion.BufferProfiles">
            <summary>
            buffers profiles
            </summary>
        </member>
        <member name="M:u040.prespective.fact.ARegion.UpdatePlaneCollisionMatrices(u040.prespective.fact.APhysicsController)">
            <summary>
            updates the overridden collision matrices of planes
            </summary>
            <param name="_controller">controller</param>
        </member>
        <member name="M:u040.prespective.fact.ARegion.UpdateProfileNamesCollisionMatrices(System.String,System.String)">
            <summary>
            applies new name to collision matrices of cut planes
            </summary>
            <param name="_oldName">old profile name</param>
            <param name="_newName">new profile name</param>
        </member>
    </members>
</doc>
