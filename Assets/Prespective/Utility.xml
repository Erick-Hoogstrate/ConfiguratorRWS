<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Utility</name>
    </assembly>
    <members>
        <member name="F:u040.prespective.math.spline.singles.PolynomialTensor2D.PolynominalX">
            <summary>
            
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.PolynomialTensor2D.PolynominalY">
            <summary>
            
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.PolynomialTensor2D.PolynominalPoints">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.PolynomialTensor2D.GetDifferntial">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolynomialTensor2D.#ctor(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            constructor
            </summary>
            <param name="_limitPoints"></param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolynomialTensor2D.Intersect(u040.prespective.math.spline.singles.PolynomialTensor2D,System.Collections.Generic.List{UnityEngine.Vector3}@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_other"></param>
            <param name="_intersections"></param>
            <param name="_allowStraightUpSections"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolynomialTensor2D.GetPointOnTensor(System.Single)">
            <summary>
            
            </summary>
            <param name="_x"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolynomialTensor2D.GetTesselatedTensor(System.Int32)">
            <summary>
            
            </summary>
            <param name="_sections"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolynomialTensor2D.PTensorFromNurbsCurve2D(u040.prespective.math.spline.singles.NURBSCurve2D)">
            <summary>
            
            </summary>
            <param name="_curve"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.math.spline.singles.CurveTraversalEvent">
            <summary>
            Events that may occur in curve traversal
            </summary>
        </member>
        <member name="T:u040.prespective.math.spline.singles.TesselationMode">
            <summary>
            which type of tesselation
            </summary>
        </member>
        <member name="T:u040.prespective.math.spline.singles.PolyNURBSTraversalManager">
            <summary>
            @CLASS : PolyNURBSTraversalManager
            
            @ABOUT : Abstract Class to manage Traversal of objects over a PolyBezier curve in a equidistant percentual fashion.
                     This class is required since this is not the default for PolyBezier traversal, by default the _u (curve time) value
                     leads to slower travel in curve areas with more control points closer together, and faster travel in areas with less
                     control points
                     
            @AUTHOR : Pieter (Unit040)
            
            @VERSION : V1.00
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.TesselationMode">
            <summary>
            The Tesselation mode to use
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.TesselationSamples">
            <summary>
            When tesselating, what sample ratio to use for tesselation
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.OnControlPolyChanged(u040.prespective.math.spline.singles.NURBSCurve3D,System.Int32,System.Int32)">
            <summary>
            Called when the control polygon changed
            </summary>
            <param name="_changedVerts"></param>
            <param name="_startIndex"></param>
            <param name="_endIndex"></param>
        </member>
        <member name="P:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.CurveLength">
            <summary>
            Returns the lenght of the curve in world units
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.GetPointAtEquidistantPerc(System.Single)">
            <summary>
            Get the point in world space at equidistant curve perc  
            </summary>
            <param name="_perc"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.GetEqPercFromDistance(System.Single)">
            <summary>
            Get the equidistant percentage after traversing 
            </summary>
            <param name="_distance"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.TranslateByEqPerc(System.Single,System.Single,UnityEngine.Vector3@,System.Single@)">
            <summary>
            Translate over a curve by equidistant percentage
            </summary>
            <param name="_currEqPerc">the equidistant percentage at the start of the translation</param>
            <param name="_pos">the resulting position in world space</param>
            <param name="_posEqPerc">the resulting equidistant percentage</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.TranslateByDistance(System.Single,System.Single,UnityEngine.Vector3@,System.Single@,System.Boolean)">
            <summary>
            Translate over a curve by distance
            </summary>
            <param name="_currEqPerc">the equidistant percentage at the start of the translation</param>
            <param name="_dist">the distance in worldspace to travel (over the curve)</param>
            <param name="_pos">the resulting position in world space</param>
            <param name="_posEqPerc">the resulting equidistant percentage</param>
            <param name="_outputRecordByDistance">Whether the key of the output record should be in distance or equidistant curve perc, default is perc</param>
            <returns>a record of traversal events occured during the translation (e.g. did we cross a curve boundary? and how many times)</returns>
        </member>
        <member name="F:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.DEBUG_Colors">
            <summary>
            Default Colors used to color the spans when visualized
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.DEBUGDrawCurve(UnityEngine.Color[])">
            <summary>
            Function called to visualize the curve
            Implementations and effect on performance may vary (based on implementation)
            </summary>
            <param name="_colorOverride">Colors to use as an override for span visualization, optional</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.SetTesselatedSample(System.Int32)">
            <summary>
            function to set the amount of tesselated samples
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.DEBUGGetTesselatedCurve">
            <summary>
            function to debug tesseleated curve
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.PolyNURBSTraversalManager.GetClosestPointOnLine(UnityEngine.Vector3,System.Single@,System.Single@)">
            <summary>
            A spline
            </summary>
        </member>
        <member name="T:u040.prespective.math.spline.singles.NURBSCurve2D">
            <summary>
            @CLASS : NURBSCurve2D
            
            @ABOUT : Class for generating a 2D NURBS basis curve (i.e. hard corners, and point weighting not (yet) supported)
                     Supports ring shaping via control polygon point copying and limiting the traversion range (i.e. _u less than range [0,1])
            
                     NOTE : weighting is not (yet) supported, since it would break the direct convertion to Parametric Basis Curve)
            
            @AUTHOR: Tymen, Pieter (Unit040)
            
            @VERSION: v1.00 - Implemented based on the uPBSpline class in the u040 Procedural Toolkit
            @VERSION: v1.10 - Implemented de casteljau algorithm intersection between 2 nurbs second orde curves
            @VERSION: v1.20 - Refactoring(15/03/2019)
            @VERSION: v1.30 - Bugfixing casteljau (17/05/2019)
            @VERSION: v1.31 - Casteljau now changes a bounding box with a zero size length to 0.001 (else the lines need to intersect perfectly)(20/05/2019)
            @VERSION: v1.32 - Casteljau made multi threaded(04/07/2019)
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.controlPoints">
            <summary>
            Contains the 'complete' control polygon; this polygon is different from the 'core control polygon' when dealing with
            a ring shaped curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.curveorder">
            <summary>
            The order of this curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.knotvector">
            <summary>
            Buffers the Basis Knot vector, describing the influence of each control point at a given time
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.NURBSCurveIsRing">
            <summary>
            Whether this Curve describes a ring
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.curveprecentagenotused">
            <summary>
            The share of 'bezier time' not used (i.e. _u less than range [0,1])
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.#ctor">
            <summary>
            empty contructor
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.#ctor(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Boolean)">
            <summary>
            constructor
            </summary>
            <param name="_controlPoints">control point</param>
            <param name="_order">orde</param>
            <param name="_isRing">if closed</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.initSettings(System.Collections.Generic.List{UnityEngine.Vector2},System.Int32,System.Boolean)">
            <summary>
            Actually setup the NURBSCurve; it has been seperated from the constructor since every
            setting requires a recalculation of the local variables
            </summary>
            <param name="_controlPoints">the control polygon to use</param>
            <param name="_order">the order of the nurbs curve</param>
            <param name="_isRing">whether the curve should be a ring</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.makeRingControlPoints(System.Collections.Generic.List{UnityEngine.Vector2}@,System.Int32)">
            <summary>
            Converts a controlPolygon to a Control Polygon usable as ring
            
            This effectively means adding # _order points from the start of the control polygon to the end of the control polygon
            and adding # _order points from the end of the control polygon to the start of the polygon
            
            (NB!. don't forget that, in order to move an object over the curve, you will need to use 
            the _t range [(1f/ _controlPolygon.Count (input) + _order), 1f - (1f/ _controlPolygon.Count (input) + _order)])
            
            </summary>
            <param name="_controlPoints"></param>
            <param name="_order"></param>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve2D.ControlPoints">
            <summary>
            The control points
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.needsCPRecalc(System.Collections.Generic.List{UnityEngine.Vector2},System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Determine if the controlpolygon has changed 'too much'; meaning the nurbs needs to be recalculated
            </summary>
            <param name="_new">the new control polygon</param>
            <param name="_oldCore">the old core control polygon (excluding the adds from making it a ring</param>
            <returns></returns>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve2D.Order">
            <summary>
            The order of the BSpline
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve2D.IsRing">
            <summary>
            Whether the Curve should represent a ring
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve2D.SpanCount">
            <summary>
            Returns the Number of Spans this Nurbs Curve Contains
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve2D.KnotVector">
            <summary>
            Returns the Current Knot Vector of this NURBS Curve
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.Clamp(UnityEngine.Vector2)">
            <summary>
            clamp curve between range
            </summary>
            <param name="_clampingRange">range</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.clampIteration(u040.prespective.math.spline.singles.NURBSCurve2D,u040.prespective.math.spline.singles.NURBSCurve2D,u040.prespective.math.spline.singles.NURBSCurve2D)">
            <summary>
            makes one itteration of the clamp function
            </summary>
            <param name="_curveToClamp">NURBS curve that is being clamped</param>
            <param name="_lowerBoundCurve">NURBS curve of lower bounds (straight line)</param>
            <param name="_upperBoundCurve">NURBS curve of upper bounds (straight line)</param>
            <returns>if done clamping</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.closestPointOnControlPoints(UnityEngine.Vector2,System.Int32@,System.Single@)">
            <summary>
            finds the closed point on a line between 2 control points of this curve of a point
            </summary>
            <param name="_point">point to check</param>
            <param name="_closedBeginSectionControlPointIndex">being index of control point of line to find clossed point on</param>
            <param name="_closestDistance">smallest distance find for clossed point</param>
            <returns>closed point</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve2D.clampBetweenBounds(System.Boolean,u040.prespective.math.spline.singles.NURBSCurve2D,u040.prespective.math.spline.singles.NURBSCurve2D,System.Collections.Generic.List{UnityEngine.Vector2})" -->
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.xRange">
            <summary>
            Returns the X-range of this nurbs curve [min-x, max-x]
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.yRange">
            <summary>
            Returns the Y-range of this nurbs curve [min-y, max-y]
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.Intersect(u040.prespective.math.spline.singles.NURBSCurve2D,System.Collections.Generic.List{UnityEngine.Vector2}@,System.Boolean)">
            <summary>
            test for intersections with other NURBSBasisCurve2Ds
            </summary>
            <param name="_curveToInstersectWith">the curve to intersect with</param>
            <param name="_foundIntersections">the found intersections</param>
            <param name="_allowStraightUpSections">whether to allow intersection with non-valid sections with a straight up (0,1) vector
            in math these sections are more regularly used for making sure the curve is continuous, but serve no further function</param>
            <returns>whether intersections were found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.intersectLinear(u040.prespective.math.spline.singles.NURBSCurve2D,UnityEngine.Vector2,System.Collections.Generic.List{UnityEngine.Vector2}@,System.Boolean)">
            <summary>
            test for intersections with other NURBSBasisCurve2Ds
            </summary>
            <param name="_curveToIntersectWith">the curve to intersect with</param>
            <param name="_minEndPointDist"></param>
            <param name="_intersections">the found intersections</param>
            <param name="_allowStraightUpSections">whether to allow intersection with non-valid sections with a straight up (0,1) vector
            in math these sections are more regularly used for making sure the curve is continuous, but serve no further function</param>
            <returns>whether intersections were found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.SecondOrder2DNURBSCurveIntersection(u040.prespective.math.spline.singles.NURBSCurve2D,System.Int32,System.Double,System.Collections.Generic.List{UnityEngine.Vector2}@)">
            <summary>
            gets the intersect point of 2 nurbscurves through bounding boxes (de casteljau algorithm)
            </summary>
            <param name="_intersectionCurve">to check intersection with</param>
            <param name="_numberOfPasses">number of bounding passes before stopping</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <param name="_intersectPoints">resulting intersect points</param>
            <returns>if found intersection</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.getBezierPointsSpline(u040.prespective.math.spline.singles.NURBSCurve2D)">
            <summary>
            get the bezier curves points of a nurbs curve
            </summary>
            <param name="_nurbsCurve">nurbs curve</param>
            <returns>bezier curves points</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.findBoudingBox(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2},System.Double,System.Double)">
            <summary>
            finds the bounding box of this bezier curve
            </summary>
            <param name="_bezierPoints">bezier curve points in orde</param>
            <param name="_tbegin">begin t point bezier curve</param>
            <param name="_tend">end t point bezier curve</param>
            <returns>bouding box</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.getFurthesAwayFromPoint(System.Double,System.Double,System.Double)">
            <summary>
            finds out which of 2 values is furthes away from given point
            </summary>
            <param name="_givenPoint">given point</param>
            <param name="_firstCompare">first compare value</param>
            <param name="_secondCompare">second compare value</param>
            <returns>which compare value is furthes away</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.findMaxMinValue(System.Collections.Generic.List{System.Double})">
            <summary>
            find minimum and maximum value of given list
            </summary>
            <param name="_toCheck">list</param>
            <returns>minimum maximum value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.checkBounds(u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect[])">
            <summary>
            checks if bounds are inside eachother (fully or partialy)
            </summary>
            <param name="_intersects">list of bounds to check</param>
            <returns>resulting bounds that have intersects</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.diffToZeroSecondOrde(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double)">
            <summary>
            finds 3 orde bezier curve differential is zero points
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.findDSingle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            finds D value for abc-formula
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <returns>D value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.diffToZeroFirstOrde(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double)">
            <summary>
            finds 2 orde bezier curve differential is zero point
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.halfTheBounds(System.Collections.Generic.List{u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect})">
            <summary>
            cuts the bezier curve in half using De Casteljau's algorithm and gets the new bounding box data
            </summary>
            <param name="_intersectsToHalf">original curve to cut in half</param>
            <returns>result of cutting in half</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.processIntersectPoints(System.Collections.Generic.List{u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect},System.Double)">
            <summary>
            process the intersect points to average out the ones that are probally the same
            </summary>
            <param name="_intersects">unprocessed intersect points</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <returns>processed intersect points</returns>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect.Bounds">
            <summary>
            bounds castlejau
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect.BezierPoints">
            <summary>
            bezier points
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect.Tbegin">
            <summary>
            percentage begin
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect.Tend">
            <summary>
            percentage end
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect.Tdifference">
            <summary>
            percentage difference
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect.Order">
            <summary>
            curve orde
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve2D.DataInterSect.CurveNumber">
            <summary>
            curve number
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.#ctor(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.BezierValueAt(System.Double,System.Double,System.Double)">
            <summary>
            gets the bezier point of curve for casteljau
            </summary>
            <param name="_t">t value bezier</param>
            <param name="_tbegin">t begin bezier</param>
            <param name="_tend">t end bezier</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.getB(System.Int32,System.Int32,System.Double)">
            <summary>
            gets the bernstein basis polynomial
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <param name="_t">t</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.binomialCoefficient(System.Int32,System.Int32)">
            <summary>
            gets a binomial coefficient (n over i)
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>binomial coefficient</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.factorial(System.Int32)">
            <summary>
            get factoral of n
            </summary>
            <param name="_n">n</param>
            <returns>factoral</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.BezierDifferentialValueAt(System.Double)">
            <summary>
            get differential of bezier curve at point (experimental should not use)
            </summary>
            <param name="_t">percentage</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.getA(System.Int32,System.Int32)">
            <summary>
            special self made coefficient for differential
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.GetPoint(System.Single,System.Boolean)">
            <summary>
            Returns a point on this NURBS Curve
            </summary>
            <param name="_curvePercentage">Returns a point on this curve in range [0,1]</param>
            <param name="_useAdaptiveRange">Whether or not we want to use the adaptive range maintained for easy traversion over a ring spline</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.GetTesselatedCurve(System.Int32)">
            <summary>
            Returns a Tesselated variant of this Curve
            </summary>
            <param name="_sections">the number of sections the tesselated curve should have</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve2D.GetSpanLimits(System.Int32)">
            <summary>
            Returns the Span Limits (which may be used to generate a Parametric (Basis) Curve for intersection calculation)
            </summary>
            <param name="_nSpan">the span # to get the limits for</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve2D.getKnotVectorNURBS(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve2D.getNURBSCurvePoint(System.Int32,System.Collections.Generic.List{System.Single},System.Collections.Generic.List{UnityEngine.Vector2},System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve2D.findBSplineSpan(System.Int32,System.Int32,System.Single,System.Collections.Generic.List{System.Single})" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve2D.nurbsFunction(System.Int32,System.Single,System.Int32,System.Collections.Generic.List{System.Single})" -->
        <member name="T:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager">
            <summary>
            @CLASS : ExplicitPolyNURBSTraversalManager
            
            @ABOUT : Traversal Manager that tessalates the NURBS Curve (*makes explicit*) and allows objects
                     to traverse the curve in an equidistant percentual manner by calculating the distance travelled between
                     these (buffered) explicit points.
                     
                     This type of Traversal Manager is more precise (since all objects move over the explicit variant of the NURBS curve, and the lenght of this variant is exactly known)
                     But this variant is more performance heavy; particularly when moving control points of the NURBS Curve (since the affected section will need to be made explicit again)
                     
            @AUTHOR : Pieter, Tymen (Unit040)
            
            @VERSION: V1.00 - 10/10/2018 - Implemented as defaul Traversal manager for PolyBezier v1.0
            @VERSION: V1.10 - 12/03/2019 - Refactoring
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.spanRecords">
            <summary>
            Buffer with explicit results for position calculation
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.totalCurveLength">
            <summary>
            Buffer with the total curve length
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.targetSamplesPerUnit">
            <summary>
            target number of curve samples to use per world unit (i.e. meter)
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.MinSamplesPerSpan">
            <summary>
            minimum number of curve samples to use per span
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.OnControlPolyChanged(u040.prespective.math.spline.singles.NURBSCurve3D,System.Int32,System.Int32)">
            <summary>
            Called when the Control Polygon changed
            Since this curve is explicitly managed, we will need to recalculate the section that was affected by the change
            </summary>
            <param name="_curve">NURBS curve we are managing</param>
            <param name="_startIndex">first Control Polygon Vert Index affected by the change</param>
            <param name="_endIndex">last Control Polygon Vert Index affected by the change</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.expressParamCurve(u040.prespective.math.spline.singles.ParametricBasisCurve)">
            <summary>
            Make a ParametricBasisCurve Explicit (i.e. tesselate)
            and buffer the results for translation calculations later
            </summary>
            <param name="_curve">the parametric curve to tesselate</param>
            <returns>explicit record of the span</returns>
        </member>
        <member name="P:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.CurveLength">
            <summary>
            After expressing the curve explicitly, the total curvelength == totalCurveLength
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.GetEqPercFromDistance(System.Single)">
            <summary>
            Simply divide the distance by total curve length
            </summary>
            <param name="_distance"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.GetPointAtEquidistantPerc(System.Single)">
            <summary>
            Returns the point at equidistant percentage on this curve
            </summary>
            <param name="_perc">the percentage to look for</param>
            <returns>a point on this curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.DEBUGDrawCurve(UnityEngine.Color[])">
            <summary>
            Override for making this curve visible in the inspector
            (we have an explicit variant of the curve anyway, so turning this off/on has no noticable effect on performance)
            </summary>
            <param name="_colorOverride">Colors to use as an override for span visualization, optional</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.DEBUGGetTesselatedCurve">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.GetClosestPointOnLine(UnityEngine.Vector3,System.Single@,System.Single@)">
            <summary>
            get closed point on line of given point
            </summary>
            <param name="_worldPoint">given point</param>
            <param name="_distance">distance betwen point and found point</param>
            <param name="_eqPerc">percentage</param>
            <returns>clossed point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ExplicitPolyNURBSTraversalManager.SetTesselatedSample(System.Int32)">
            <summary>
            set tesselated samples
            </summary>
            <param name="_value">amount of samples</param>
        </member>
        <member name="T:u040.prespective.math.spline.singles.ExplicitSpanRecord">
            <summary>
            @STRUCT : ExplicitSpanRecord
            
            @ABOUT : A struct used for storing explicit results describing a Parametric Basis Curve
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: V1.00 - 10/10/2018 - Implemented Explicit Traversal Manager Buffer (to limit processing impact of traversing an object accross the curve) 
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitSpanRecord.SpanCurve">
            <summary>
            Parametric Basis Curve Describing this span of the NURBS curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitSpanRecord.ExplicitPointRecord">
            <summary>
            Buffer with explicit coordinates on this span of the NURBS Curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitSpanRecord.IntervalRecord">
            <summary>
            Buffer with explicit distances between coordinates on this span of the nurbs curve (section #0 is interval between explicitPointRecord #0 and #1)
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ExplicitSpanRecord.SpanLength">
            <summary>
            Total length of this span of the NURBS Curve
            </summary>
        </member>
        <member name="T:u040.prespective.math.spline.singles.ParametricBasisCurve">
            <summary>
            @CLASS : ParametricBasisCurve
            
            @ABOUT : Class for creating a Parametric Basis Curve
                     A Curve described by quadratic or linear functions for the x, y and z components
                     
            @AUTHOR: Tymen, Pieter (Unit040)
            
            @VERSION: V1.00
            @VERSION: v1.10 - Refactored (12/03/2019)
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ParametricBasisCurve.functionParametersX">
            <summary>
            Ax^2 + BX + C parameters for the x-parabola
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ParametricBasisCurve.functionParametersY">
            <summary>
            Ax^2 + BX + C parameters for the y-parabola
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.ParametricBasisCurve.functionParametersZ">
            <summary>
            Ax^2 + BX + C parameters for the z-parabola
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.#ctor(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            Generates a Parametric Basis Curve based on 3 limit points
            Generally used to convert a NURBS curve to a Parametric Basis Curve
            </summary>
            <param name="_limitPoints"></param>
        </member>
        <member name="P:u040.prespective.math.spline.singles.ParametricBasisCurve.XFParams">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.ParametricBasisCurve.YFParams">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.ParametricBasisCurve.ZFParams">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.GetPoint(System.Single)">
            <summary>
            get point at percentage
            </summary>
            <param name="_curvePercentage">percentage</param>
            <returns>point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.GetTesselatedCurve(System.Int32)">
            <summary>
            get tesselated curve
            </summary>
            <param name="_numberOfTesselationPoints">number of tesselation points</param>
            <returns>resselated curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.getcurveLength(System.Single,System.Single,System.Single)">
            <summary>
            Retrieves the curve length through integration
            </summary>
            <param name="_startPercentageCurve">the start _t for integration</param>
            <param name="_endPercentageCurve">the end _t for integration</param>
            <param name="_stepsizeOfPercentageOnCurve">the stepsize for integration</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.CreateParametricCurveSetFromNurbsCurve(u040.prespective.math.spline.singles.NURBSCurve3D)">
            <summary>
            
            </summary>
            <param name="_nCurve"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.CreateParametricCurveSetFromBasisNurbs(u040.prespective.math.spline.singles.NURBSCurve3D,System.Collections.Generic.List{System.Collections.Generic.List{UnityEngine.Vector3}}@,System.Int32)">
            <summary>
            
            </summary>
            <param name="_nCurve"></param>
            <param name="_tesselatedResults"></param>
            <param name="_tSections"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.integrateParabola(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3,System.Single,System.Single,System.Single)">
            <summary>
            Calculates the length of a Parabola Line (segment), default in range [0, 1] using 0.01f as stepsize (i.e. 100 samples)
            Integral Under Parabola Line (not middle or over)
            </summary>
            <param name="_xparameters">the x functional parameters</param>
            <param name="_yparameters">the y functional parameters</param>
            <param name="_zparameters">the z functional parameters</param>
            <param name="startPercentageCurve">the start of the range to integrate, default 0</param>
            <param name="_endPercentageCurve">the end of the range to integrate, default 1</param>
            <param name="_stepSizeofPercentageOnCurve">the step size</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.parabolFrom3Points(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Function to calculate a parabola from 3 (equally weighted) points
            </summary>
            <param name="_p1">first limit</param>
            <param name="_p2">second limit</param>
            <param name="_p3">third limit</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.ParametricBasisCurve.determinant(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Determinant calculation function
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_c"></param>
            <param name="_d"></param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.math.spline.singles.polynominalForm.Start">
            <summary>
            Start time of the polynomial
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.polynominalForm.End">
            <summary>
            End time of the polynomial
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.polynominalForm.FunctionParameters">
            <summary>
            The polynomial coefficients : f(X) = A0X^(Coef[0]) + A1X^(Coef[1]) .. + A(Coef[n-1])X^1 + Coef[n]
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.polynominalForm.Degree">
            <summary>
            Returns the degree of this polynomial formula
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.CreatePolynomialCurveSetFromNurbsCurve2D(u040.prespective.math.spline.singles.NURBSCurve2D)">
            <summary>
            creates the polynominals of a nurbs curve
            </summary>
            <param name="_nurbsCurve">nurbs curve</param>
            <returns>the polynominal descriptions of the nurbs curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.GetDifferential">
            <summary>
            gets the differential polynominal of the polynominal
            </summary>
            <returns>differential polynominal</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.GetPointOnPolynominal(System.Single)">
            <summary>
            gets the point of polynominal at x
            </summary>
            <param name="_x">x</param>
            <returns>point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.Intersect(u040.prespective.math.spline.singles.polynominalForm,System.Collections.Generic.List{UnityEngine.Vector2}@,System.Boolean)">
            <summary>
            finds intersection between this polynominal and other polynominal
            </summary>
            <param name="_other">other polynominal</param>
            <param name="_intersections">found intersections</param>
            <param name="_allowStraightUpSections"></param>
            <returns>if found intersections</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.intersect1(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{UnityEngine.Vector2}@,System.Boolean)">
            <summary>
            test for linear intersection
            </summary>
            <param name="_lineACoeficients">coefficient params for formula A</param>
            <param name="_lineBCoeficients">coefficient params for formula B</param>
            <param name="_intersections">found intersections</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.intersect2(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{UnityEngine.Vector2}@)">
            <summary>
            test for Quadratic intersections
            </summary>
            <param name="_polynomialCoefficientsA">coefficient params for formula A</param>
            <param name="_polynomialCoefficientsB">coefficient params for formula B</param>
            <param name="_intersections">found intersections</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.intersect3(System.Collections.Generic.List{System.Single},System.Collections.Generic.List{System.Single},System.Collections.Generic.List{UnityEngine.Vector2}@)">
            <summary>
            Test for Cubic intersections
            </summary>
            <param name="_polynomialCoefficientsA">coefficient params for formula A</param>
            <param name="_polynomialCoefficientsB">coefficient params for formula B</param>
            <param name="_intersections">found intersections</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.PolynomialFromNPoints(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            creates a polynominal of given points
            </summary>
            <param name="_points">points</param>
            <returns>polynominal</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.polynomialFrom1Point(UnityEngine.Vector2)">
            <summary>
            Creates a LINEAR polynomial from 
            </summary>
            <param name="_point"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.polynomialFrom2Points(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Function to calculate a linear polynomial from 2 (equally weighted) points
            </summary>
            <param name="_point1">first point on line</param>
            <param name="_point2">second point on line</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.polynomialFrom3Points(UnityEngine.Vector2,UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Function to calculate a quadric polynomial from 3 (equally weighted) points
            </summary>
            <param name="_point1">first limit</param>
            <param name="_point2">second limit</param>
            <param name="_point3">third limit</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.polynominalForm.determinant(System.Single,System.Single,System.Single,System.Single)" -->
        <member name="M:u040.prespective.math.spline.singles.polynominalForm.getValueAtForPolynominal(System.Single,System.Collections.Generic.List{System.Single})">
            <summary>
            Calculate the y-coord for a polynomial with coeficients y = A0 * x^(n) + A1 * x^(n-1) .. + A(n-1) * x + An using Horner's method
            
            https://www.youtube.com/watch?v=39pu-z3KpAQ
            </summary>
            <param name="_x">the X to find the Y for</param>
            <param name="_polynominalCoefficients">the coefficients starting at the highest order</param>
            <returns>y</returns>
        </member>
        <member name="T:u040.prespective.math.spline.singles.NURBSCurve3D">
            <summary>
            @CLASS : NURBSCurve3D
            
            @ABOUT : Class for generating a NURBS basis curve (i.e. hard corners, and point weighting not (yet) supported)
                     Supports ring shaping via control polygon point copying and limiting the traversion range (i.e. _u less than range [0,1])
            
                     NOTE : weighting is not (yet) supported, since it would break the direct convertion to Parametric Basis Curve)
            
            @AUTHOR: Tymen, Pieter (Unit040)
            
            @VERSION: v1.00 - Implemented based on the uPBSpline class in the u040 Procedural Toolkit
            @VERSION: v1.10 - Refactored (12/03/2019)
            @VERSION: v1.20 - Bugfixing casteljau (17/05/2019)
            @VERSION: v1.21 - Casteljau now changes a bounding box with a zero size length to 0.001 (else the lines need to intersect perfectly)(20/05/2019)
            @VERSION: v1.22 - Casteljau made multi threaded(04/07/2019)
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.controlpoints">
            <summary>
            Contains the 'complete' control polygon; this polygon is different from the 'core control polygon' when dealing with
            a ring shaped curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.curveorder">
            <summary>
            The order of this curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.knotvector">
            <summary>
            Buffers the Basis Knot vector, describing the influence of each control point at a given time
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.NURBSCurveIsRing">
            <summary>
            Whether this Curve describes a ring
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.curveprecentagenotused">
            <summary>
            The share of 'bezier time' not used (i.e. _u less than range [0,1])
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.#ctor(System.Collections.Generic.List{UnityEngine.Vector3},System.Int32,System.Boolean)">
            <summary>
            constructor
            </summary>
            <param name="_controlPolygon">control polygon</param>
            <param name="_order">orde</param>
            <param name="_isRing">is clossed</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.initSettings(System.Collections.Generic.List{UnityEngine.Vector3},System.Int32,System.Boolean)">
            <summary>
            Actually setup the NURBSCurve; it has been seperated from the constructor since every
            setting requires a recalculation of the local variables
            </summary>
            <param name="_controlPolygon">the control polygon to use</param>
            <param name="_order">the order of the nurbs curve</param>
            <param name="_isRing">whether the curve should be a ring</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.makeRingControlPoints(System.Collections.Generic.List{UnityEngine.Vector3}@,System.Int32)">
            <summary>
            Converts a controlPolygon to a Control Polygon usable as ring
            
            This effectively means adding # _order points from the start of the control polygon to the end of the control polygon
            and adding # _order points from the end of the control polygon to the start of the polygon
            
            (NB!. don't forget that, in order to move an object over the curve, you will need to use 
            the _t range [(1f/ _controlPolygon.Count (input) + _order), 1f - (1f/ _controlPolygon.Count (input) + _order)])
            
            </summary>
            <param name="_contolpoints"></param>
            <param name="_order"></param>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve3D.ControlPoints">
            <summary>
            The control polygon described by the control points
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.needsCPRecalc(System.Collections.Generic.List{UnityEngine.Vector3},System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            Determine if the controlpolygon has changed 'too much'; meaning the nurbs needs to be recalculated
            </summary>
            <param name="_new">the new control polygon</param>
            <param name="_oldCore">the old core control polygon (excluding the adds from making it a ring</param>
            <returns></returns>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve3D.Order">
            <summary>
            The order of the BSpline
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve3D.IsRing">
            <summary>
            Whether the Curve should represent a ring
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve3D.SpanCount">
            <summary>
            Returns the Number of Spans this Nurbs Curve Contains
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.singles.NURBSCurve3D.KnotVector">
            <summary>
            Returns the Current Knot Vector of this NURBS Curve
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.SecondOrder3DNURBSCurveIntersection(u040.prespective.math.spline.singles.NURBSCurve3D,System.Int32,System.Double,System.Collections.Generic.List{UnityEngine.Vector3}@)">
            <summary>
            gets the intersect point of 2 nurbscurves through bounding boxes (de casteljau algorithm)
            </summary>
            <param name="_intersectionCurve">to check intersection with</param>
            <param name="_numberOfPasses">number of bounding passes before stopping</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <param name="_intersectPoints">resulting intersect points</param>
            <returns>if found intersection</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.getBezierPointsSpline(u040.prespective.math.spline.singles.NURBSCurve3D)">
            <summary>
            get the bezier curves points of a nurbs curve
            </summary>
            <param name="_nurbsCurve">nurbs curve</param>
            <returns>bezier curves points</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.findBoudingBox(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Double,System.Double)">
            <summary>
            finds the bounding box of this bezier curve
            </summary>
            <param name="_bezierPoints">bezier curve points in orde</param>
            <param name="_tbegin">begin t point bezier curve</param>
            <param name="_tend">end t point bezier curve</param>
            <returns>bouding box</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.getFurthesAwayFromPoint(System.Double,System.Double,System.Double)">
            <summary>
            finds out which of 2 values is furthes away from given point
            </summary>
            <param name="_givenPoint">given point</param>
            <param name="_firstCompare">first compare value</param>
            <param name="_secondCompare">second compare value</param>
            <returns>which compare value is furthes away</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.findMaxMinValue(System.Collections.Generic.List{System.Double})">
            <summary>
            find minimum and maximum value of given list
            </summary>
            <param name="_toCheck">list</param>
            <returns>minimum maximum value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.checkBounds(u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect[])">
            <summary>
            checks if bounds are inside eachother (fully or partialy)
            </summary>
            <param name="_intersects">list of bounds to check</param>
            <returns>resulting bounds that have intersects</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.diffToZeroSecondOrde(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double,System.Double)">
            <summary>
            finds 3 orde bezier curve differential is zero points
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.findDSingle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            finds D value for abc-formula
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <returns>D value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.diffToZeroFirstOrde(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double,System.Double)">
            <summary>
            finds 2 orde bezier curve differential is zero point
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.halfTheBounds(System.Collections.Generic.List{u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect})">
            <summary>
            cuts the bezier curve in half using De Casteljau's algorithm and gets the new bounding box data
            </summary>
            <param name="_intersectsToHalf">original curve to cut in half</param>
            <returns>result of cutting in half</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.processIntersectPoints(System.Collections.Generic.List{u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect},System.Double)">
            <summary>
            process the intersect points to average out the ones that are probally the same
            </summary>
            <param name="_intersects">unprocessed intersect points</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <returns>processed intersect points</returns>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect.Bounds">
            <summary>
            bounds castlejau
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect.BezierPoints">
            <summary>
            bezier points
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect.Tbegin">
            <summary>
            percentage begin
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect.Tend">
            <summary>
            percentage end
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect.Tdifference">
            <summary>
            percentage difference
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect.Order">
            <summary>
            curve orde
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.singles.NURBSCurve3D.DataInterSect.CurveNumber">
            <summary>
            curve number
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.#ctor(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.bezierValueAt(System.Double,System.Double,System.Double)">
            <summary>
            gets the bezier point of curve for casteljau
            </summary>
            <param name="_t">t value bezier</param>
            <param name="_tbegin">t begin bezier</param>
            <param name="_tend">t end bezier</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.getB(System.Int32,System.Int32,System.Double)">
            <summary>
            gets the bernstein basis polynomial
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <param name="_t">t</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.binomialCoefficient(System.Int32,System.Int32)">
            <summary>
            gets a binomial coefficient (n over i)
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>binomial coefficient</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.factorial(System.Int32)">
            <summary>
            get factoral of n
            </summary>
            <param name="_n">n</param>
            <returns>factoral</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.bezierDifferentialValueAt(System.Double)">
            <summary>
            get differential of bezier curve at point (experimental should not use)
            </summary>
            <param name="_t">percentage</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.getA(System.Int32,System.Int32)">
            <summary>
            special self made coefficient for differential
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.GetPoint(System.Single,System.Boolean)">
            <summary>
            Returns a point on this NURBS Curve
            </summary>
            <param name="_curvePercentage">Returns a point on this curve in range [0,1]</param>
            <param name="_useAdaptiveRange">Whether or not we want to use the adaptive range maintained for easy traversion over a ring spline</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.singles.NURBSCurve3D.GetSpanLimits(System.Int32)">
            <summary>
            Returns the Span Limits (which may be used to generate a Parametric (Basis) Curve for intersection calculation)
            </summary>
            <param name="_nSpan">the span # to get the limits for</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve3D.getKnotVectorNURBS(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve3D.GetNURBSCurvePoint(System.Int32,System.Collections.Generic.List{System.Single},System.Collections.Generic.List{UnityEngine.Vector3},System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve3D.findBSplineSpan(System.Int32,System.Int32,System.Single,System.Collections.Generic.List{System.Single})" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.singles.NURBSCurve3D.NURBSFunction(System.Int32,System.Single,System.Int32,System.Collections.Generic.List{System.Single})" -->
        <member name="T:u040.prespective.math.spline.doubles.DNURBSCurve2D">
            <summary>
            <description>
            Class for generating a 2D NURBS basis curve with double precision (i.e. hard corners, and point weighting not (yet) supported)
                     Supports ring shaping via control polygon point copying and limiting the traversal range (i.e. _u less than range [0,1])
            </description>
            <version 
                ver="1.0.0" 
                author="TDK" 
                date="191119">
                Refactored from the original spline tooling
            </version>
            <version 
                ver="1.0.1" 
                author="TGE" 
                date="090120">
                Made the Knot vector an array instead of a list (for performance)
            </version>
            <version 
                ver="1.1.0" 
                author="TGE, PWS" 
                date="180820">
                Added Limiter function and Clamping Algorithm
            </version>
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.controlPoints">
            <summary>
            Contains the 'complete' control polygon; this polygon is different from the 'core control polygon' when dealing with
            a ring shaped curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.curveOrder">
            <summary>
            The order of this curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.knotVector">
            <summary>
            Buffers the Basis Knot vector, describing the influence of each control point at a given time
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.nurbsCurveIsRing">
            <summary>
            Whether this Curve describes a ring
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.curvePercentageNotUsed">
            <summary>
            The share of 'bezier time' not used (i.e. _u less than range [0,1])
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.#ctor(u040.prespective.math.doubles.DVector2[],System.Int32,System.Boolean,System.Double[])">
            <summary>
            constructor
            </summary>
            <param name="_controlPoints">Control points</param>
            <param name="_order">Nth order system</param>
            <param name="_isRing">If the carve is a closed loop/ring</param>
            <param name="_preCalculatedKnotVector">DNURBSCurve2D will calculate the KnotVector based on the other parameters, but also accepts precalculated vectors by overriding this parameter</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Clone">
            <summary>
            Clone this Nurbscurve2D
            (Included as part of DES)
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.initSettings(u040.prespective.math.doubles.DVector2[],System.Int32,System.Boolean,System.Double[])">
            <summary>
            Actually setup the NURBSCurve; it has been separated from the constructor since every
            setting requires a recalculation of the local variables
            </summary>
            <param name="_controlPoints">the control polygon to use</param>
            <param name="_order">the order of the NURBS curve</param>
            <param name="_isRing">whether the curve should be a ring</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.makeRingControlPoints(u040.prespective.math.doubles.DVector2[],System.Int32)">
            <summary>
            Converts a controlPolygon to a Control Polygon usable as ring
            
            This effectively means adding # _order points from the start of the control polygon to the end of the control polygon
            and adding # _order points from the end of the control polygon to the start of the polygon
            
            (NB!. don't forget that, in order to move an object over the curve, you will need to use 
            the _t range [(1f/ _controlPolygon.Count (input) + _order), 1f - (1f/ _controlPolygon.Count (input) + _order)])
            
            </summary>
            <param name="_controlPoints"></param>
            <param name="_order"></param>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve2D.EndControlPoint">
            <summary>
            Returns the End Control Point of this Curve
            (Included as part of DES)
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve2D.StartControlPoint">
            <summary>
            Returns the Start Control Point of this Curve
            (Included as part of DES)
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve2D.ControlPoints">
            <summary>
            The control points
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.needsCPRecalc(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[])">
            <summary>
            Determine if the control polygon has changed 'too much'; meaning the NURBS needs to be recalculated
            </summary>
            <param name="_new">the new control polygon</param>
            <param name="_oldCore">the old core control polygon (excluding the adds from making it a ring</param>
            <returns></returns>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve2D.Order">
            <summary>
            The order of the BSpline
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve2D.IsRing">
            <summary>
            Whether the Curve should represent a ring
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve2D.SpanCount">
            <summary>
            Returns the Number of Spans this NURBS Curve Contains
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve2D.KnotVector">
            <summary>
            Returns the Current Knot Vector of this NURBS Curve
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.GetLastRelevantControlPointVector(u040.prespective.math.doubles.DVector2@,System.Boolean,System.Double)">
            <summary>
            Returns the Last Relevant (non-zero magnitude) Vector between control points in this Curve
            (Included as part of DES)
            </summary>
            <param name="_result">The found relevant vector</param>
            <param name="_allowStraightUp">Whether straight up sections should also be seen as valid (default is no since they are used to create clamping)</param>
            <param name="_precision">Precision override for checking how far apart points x coordinates are if _allowStraightUp is false (default = 1E-10d)</param>
            <returns>A boolean indicating if the last relevant CP vector was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Bounds(u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2@)">
            <summary>
            Returns the Control Point Bounds that encapsulate this graph
            (Included as part of DES)
            </summary>
            <param name="_min">The minimum point on the containing rectangle</param>
            <param name="_max">The maximum point on the containing rectangle</param>
            <returns>A boolean indicating if the bounds were found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.GetOffsetCurve(System.Double)">
            <summary>
            Creates a new curve with the control point Y-value offset by _offset
            (Included as part of DES)
            </summary>
            <param name="_offset"></param>
            <returns>A new curve with the control point Y-value offset by _offset</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.OffsetCurve(u040.prespective.math.doubles.DVector2)">
            <summary>
            Creates an offset of _offset on this curve
            (Included as part of DES)
            </summary>
            <param name="_offset">The offset to create</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Trim(u040.prespective.math.doubles.DVector2,u040.prespective.math.spline.doubles.DNURBSCurve2D@)">
            <summary>
            Trims the Curve over the X-axis (removes the parts with a lower and/or higher x than the _xlimits), 
            </summary>
            <param name="_xLimits">the minimum- and maximum x values for trimming</param>
            <param name="_result">the resulting curve</param>
            <returns>if something was trimmed (and thus returned)</returns>
            ToDo: Change return type to _result instead of bool
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.trimX(u040.prespective.math.spline.doubles.DNURBSCurve2D,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Trim the Curve over the X-axis (removes the parts with a lower and/or higher x than the _xlimits), 
            </summary>
            <param name="_curve">the curve to trim</param>
            <param name="_xRange">the minimum- and maximum x values for trimming</param>
            <param name="_margin">margin</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.trimY(u040.prespective.math.spline.doubles.DNURBSCurve2D,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[]@,System.Boolean,System.Double)">
            <summary>
            Trims a Curve to limit its Y-range to the _acceptedYRange, the result is returned as _trimmedPoints
            (NOTE: for now only 1st order curves are supported)
            </summary>
            <param name="_curve">the curve to be limited</param>
            <param name="_acceptedYRange"></param>
            <param name="_trimmedPoints"></param>
            <param name="_retainXRange"></param>
            <param name="_precision"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Clip(u040.prespective.math.doubles.DVector2,u040.prespective.math.spline.doubles.DNURBSCurve2D[]@,System.Double)">
            <summary>
            clips out the given x limits
            </summary>
            <param name="_xLimits">x limits</param>
            <param name="_result">clipped curves</param>
            <param name="_margin">margin</param>
            <returns>if could clip</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.clipX(u040.prespective.math.doubles.DVector2,u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Double)">
            <summary>
            clipping over x range
            </summary>
            <param name="_xRange">x range to clip</param>
            <param name="_curve">curve to clip</param>
            <param name="_margin">margin</param>
            <returns>clipped parts</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.yRange">
            <summary>
            Returns the Y-range of this NURBS curve [min-y, max-y]
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.YBounds">
            <summary>
            Public Accessors of the Y-range
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Unclamp(System.Double)">
            <summary>
            Removes the clamping of this Curve
            
            NO UNITTEST YET
            </summary>
            <param name="_distanceMargin">the x distance margin to use for checking a clamped limit</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Clamp(u040.prespective.math.doubles.DVector2,System.Boolean,System.Double)">
            <summary>
            does clamping with range of first order equation
            could cause problem with points that are within distance margin of each other because those are clean out
            </summary>
            <param name="_clampingRange">clamping range</param>
            <param name="_skipForwardTest">use forward check</param>
            <param name="_distanceMargin">distance margin</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.clampPoint(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double)">
            <summary>
            clamps the point if necessary
            </summary>
            <param name="_point">point</param>
            <param name="_range">clamping range</param>
            <param name="_clampingDiff">difference of range</param>
            <param name="_margin">margin</param>
            <returns>clamped point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.LimitCurve(u040.prespective.math.spline.doubles.DNURBSCurve2D,u040.prespective.math.doubles.DVector2@,System.Boolean,System.Boolean,System.Boolean,u040.prespective.math.doubles.DVector2,System.Boolean,System.Double,System.Double)">
            <summary>
            limits this curve based on given curve
            </summary>
            <param name="_limitingCurve">curve to limit with</param>
            <param name="_beginLimitValue">value limiting starts</param>
            <param name="_movingForward">if curve moving forward</param>
            <param name="_hasWeigthing">if weight of limiting must be applied</param>
            <param name="_isClamped">if clamped</param>
            <param name="_clampingRange">clamping range</param>
            <param name="_skipForwardTest">skip check if always moving forward in time</param>
            <param name="_distanceMargin">distance margin</param>
            <param name="_angleMargin">angle margin</param>
            <returns>if curve was limited</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.checkCurveDirectionIsValid(u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Double)">
            <summary>
            Checks a curve for continuity in the x-direction
            </summary>
            <param name="_curve">The curve to check for continuity</param>
            <param name="_margin">margin</param>
            <returns>True if continuous, otherwise false</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.makeWeightedLinePoints(System.Int32,System.Int32,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Int32,System.Double)">
            <summary>
            makes the weighted curve over the limit line
            </summary>
            <param name="_startIndex">start index curve</param>
            <param name="_startIndexLimit">index first point that needs to be weighted of the limit curve</param>
            <param name="_intersectionPoint">intersection point</param>
            <param name="_curve">curve</param>
            <param name="_limitCurve">limit curve</param>
            <param name="_amountLimitPoints">amount limit points</param>
            <param name="_distanceMargin">distance margin</param>
            <returns>weighted line</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Intersect(u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Test for intersections with other NURBSBasisCurve2Ds
            (DES included precision override for 1st order curves)
            </summary>
            <param name="_curveToIntersectWith">The curve to intersect with</param>
            <param name="_foundIntersections">the found intersections</param>
            <param name="_allowStraightUpSections">Whether to allow intersection with non-valid sections with a straight up (0,1) vector.
            In math these sections are more regularly used for making sure the curve is continuous, but serve no further function</param>
            <param name="_precisionOverride">Override the decimal precision (default = 7 decimals)</param>
            <param name="_verbose">If the function should log with Debug.Log() (default = false)</param>
            <returns>Whether intersections were found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.intersectLinear(u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Boolean,System.Boolean)">
            <summary>
            test for intersections with other NURBSBasisCurve2Ds
            </summary>
            <param name="_curveToIntersectWith">the curve to intersect with</param>
            <param name="_margin"></param>
            <param name="_intersections">the found intersections</param>
            <param name="_allowStraightUpSections">whether to allow intersection with non-valid sections with a straight up (0,1) vector
            in math these sections are more regularly used for making sure the curve is continuous, but serve no further function</param>
            <returns>whether intersections were found</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Intersect(System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Boolean,System.Double,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve2D.intersectFirstOrderWithYValue(System.Double,System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Boolean,System.Boolean)" -->
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.SecondOrder2DNURBSCurveIntersection(u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Int32,System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@)">
            <summary>
            gets the intersect point of 2 nurbscurves through bounding boxes (de casteljau algorithm)
            </summary>
            <param name="_intersectionCurve">to check intersection with</param>
            <param name="_numberOfPasses">number of bounding passes before stopping</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <param name="_intersectPoints">resulting intersect points</param>
            <returns>if found intersection</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.getBezierPointsSpline(u040.prespective.math.spline.doubles.DNURBSCurve2D)">
            <summary>
            get the bezier curves points of a nurbs curve
            </summary>
            <param name="_nurbsCurve">nurbs curve</param>
            <returns>bezier curves points</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.findBoudingBox(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2},System.Double,System.Double)">
            <summary>
            finds the bounding box of this bezier curve
            </summary>
            <param name="_bezierPoints">bezier curve points in orde</param>
            <param name="_tbegin">begin t point bezier curve</param>
            <param name="_tend">end t point bezier curve</param>
            <returns>bouding box</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.getFurthesAwayFromPoint(System.Double,System.Double,System.Double)">
            <summary>
            finds out which of 2 values is furthest away from given point
            </summary>
            <param name="_givenPoint">given point</param>
            <param name="_firstCompare">first compare value</param>
            <param name="_secondCompare">second compare value</param>
            <returns>which compare value is furthest away</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.findMaxMinValue(System.Collections.Generic.List{System.Double})">
            <summary>
            find minimum and maximum value of given list
            </summary>
            <param name="_toCheck">list</param>
            <returns>minimum maximum value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.checkBounds(u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect[])">
            <summary>
            checks if bounds are inside eachother (fully or partialy)
            </summary>
            <param name="_intersects">list of bounds to check</param>
            <returns>resulting bounds that have intersects</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.diffToZeroSecondOrde(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double)">
            <summary>
            finds 3 orde bezier curve differential is zero points
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.findDSingle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            finds D value for abc-formula
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <returns>D value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.diffToZeroFirstOrde(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Double)">
            <summary>
            finds 2 orde bezier curve differential is zero point
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.halfTheBounds(System.Collections.Generic.List{u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect})">
            <summary>
            cuts the bezier curve in half using De Casteljau's algorithm and gets the new bounding box data
            </summary>
            <param name="_intersectsToHalf">original curve to cut in half</param>
            <returns>result of cutting in half</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.processIntersectPoints(System.Collections.Generic.List{u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect},System.Double)">
            <summary>
            process the intersect points to average out the ones that are probally the same
            </summary>
            <param name="_intersects">unprocessed intersect points</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <returns>processed intersect points</returns>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect.Bounds">
            <summary>
            bounds castlejau
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect.BezierPoints">
            <summary>
            bezier points
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect.Tbegin">
            <summary>
            percentage begin
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect.Tend">
            <summary>
            percentage end
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect.Tdifference">
            <summary>
            percentage difference
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect.Order">
            <summary>
            curve orde
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve2D.DataInterSect.CurveNumber">
            <summary>
            curve number
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.#ctor(System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.BezierValueAt(System.Double,System.Double,System.Double)">
            <summary>
            gets the bezier point of curve for casteljau
            </summary>
            <param name="_t">t value bezier</param>
            <param name="_tbegin">t begin bezier</param>
            <param name="_tend">t end bezier</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.getB(System.Int32,System.Int32,System.Double)">
            <summary>
            gets the bernstein basis polynomial
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <param name="_t">t</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.binomialCoefficient(System.Int32,System.Int32)">
            <summary>
            gets a binomial coefficient (n over i)
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>binomial coefficient</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.factorial(System.Int32)">
            <summary>
            get factoral of n
            </summary>
            <param name="_n">n</param>
            <returns>factoral</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.BezierDifferentialValueAt(System.Double)">
            <summary>
            get differential of bezier curve at point (experimental should not use)
            </summary>
            <param name="_t">percentage</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.BezierCurveStruc2DNURBSCasteljau.getA(System.Int32,System.Int32)">
            <summary>
            special self made coefficient for differential
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.getPoint(System.Double,System.Boolean)">
            <summary>
            Returns a point on this NURBS Curve
            </summary>
            <param name="_curvePercentage">Returns a point on this curve in range [0,1]</param>
            <param name="_useAdaptiveRange">Whether or not we want to use the adaptive range maintained for easy traversion over a ring spline</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.Optimize(System.Boolean,System.Double,System.Double)">
            <summary>
            Check for double points in control points with a margin
            </summary>
            <param name="_verbose">If the function should log with Debug.Log() (default = false)</param>
            <param name="_controlPointPrecision">Override for precision used in calculations related to the control points (default = 1E-20d)</param>
            <param name="_nonVolumeEarPrecision">Override for precision used in calculations related to the non volume ear (default = 1E-20d)</param>
            ToDo: Precision override only seems accurate up to 1E-8d
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.get2DVectorAtControlPoint(u040.prespective.math.doubles.DVector2[],System.Int32,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Returns the Vector of the curve at a particular control point
            </summary>
            <param name="_controlPoints">reference to the control points</param>
            <param name="_cpIndex">the index of the control point</param>
            <param name="_ring">whether this curve is a ring</param>
            <param name="_ignoreStraightUp">ignore straight up</param>
            <param name="_margin">margin of the distances checks</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.ParametricSolve(System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}@,System.Collections.Generic.List{System.Int32},System.Boolean,System.Double,System.Double)">
            <summary>
            Parametrically solve an x-coordinate on the curve
            </summary>
            <param name="_xValue">The x-value to solve the curve for</param>
            <param name="_results">The found results</param>
            <param name="_segmentsToCheck">A list of segments to check _xValue for (default = all segments included)</param>
            <param name="_verbose">Whether verbose logging is active</param>
            <param name="_maxSnappingDistanceToControlPoint">The maximum distance from a CP that is considered equal to the CP point (default = 1E-10d)</param>
            <param name="_maxDistanceToLine">The maximum distance from the line that is considered on the line (default = 1E-10d)</param>
            <returns>A boolean indicating if the given x-value can be solved parametrically</returns>
            ToDo: Does not get both points when IsRing is true
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.ParametricSolve(System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Collections.Generic.List{System.Int32},System.Double)">
            <summary>
            Simplified Parametric solve (with less settings)
            </summary>
            <param name="_xValue">The x-value to solve the curve for</param>
            <param name="_results">The found results</param>
            <param name="_segmentsToCheck">A list of segments to check _xValue for (default = all segments included)</param>
            <param name="_roundingMargin">The maximum distance from the line that is considered on the line and thus considered as a valid intersection point (default = 1E-10d)</param>
            <returns>A boolean indicating if a point was found for _xValue</returns>
            ToDo: Does not get both points when IsRing is true
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.getPointBetweenLines(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            gets point between 2 points of given x value
            </summary>
            <param name="_start"></param>
            <param name="_end"></param>
            <param name="_xValue"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.GetTessellatedCurve(System.Int32)">
            <summary>
            Returns a Tessellated variant of this Curve
            </summary>
            <param name="_sections">The number of sections the tessellated curve should have</param>
            <returns>The points along the curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve2D.GetSpanLimits(System.Int32)">
            <summary>
            Returns the Span Limits (which may be used to generate a Parametric (Basis) Curve for intersection calculation)
            </summary>
            <param name="_nSpan">The span # to get the limits for</param>
            <returns>The span limit points (2 points for 1th order and 3 points for 2nd order)</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve2D.getKnotVectorNURBS(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve2D.getNURBSCurvePoint(System.Int32,System.Double[],u040.prespective.math.doubles.DVector2[],System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve2D.findBSplineSpan(System.Int32,System.Int32,System.Double,System.Double[])" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve2D.nurbsFunction(System.Int32,System.Double,System.Int32,System.Double[])" -->
        <member name="T:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D">
             <summary>
             /// Extension Class for the NURBSCurve2D that allows it to describe an enveloped curve (curve covering a surface)
             For now, only equal thickness is supported over the curve
             (Included as part of DES)
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="T:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.CurveDescriptor">
            <summary>
            Shorthand descriptor used for the curve segments
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.ClampingRangeYAxis">
            <summary>
            The y range used for clamping this curve set 
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.xBounds">
            <summary>
            The X bounds for this enveloped curve
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.XBounds">
            <summary>
            The X bounds for this enveloped curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.yBounds">
            <summary>
            The Y bounds for this enveloped curve
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.YBounds">
            <summary>
            The Y bounds for this enveloped curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.trimmedBoundRegistry">
            <summary>
            A list of trimmed curve bounds and x range combinations for later use
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.envelopedCurveBounds">
            <summary>
            The X and Y bounds for this enveloped curve (There can be multiple bounds if a curve is clamped)
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.EnvelopAtCurveEnd">
            <summary>
            Returns the Boundary envelop (thickness forwards and backwards) at the end of the graph 
            (which is either end of the frame, or the last time point described by this enveloped curve)
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.EnvelopedCurveBounds">
            <summary>
            Retrieve the full bounds of this curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.envelopThickness">
            <summary>
            Thickness of the envelop (Y axis) in forward and backward direction
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.EnvelopThickness">
            <summary>
            Thickness of the envelop (Y axis) in forward and backward direction
            </summary>
            ToDo: Implement as DVector2 later, creates difficulty when an actor moves backwards (x -> y, y -> x)
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.frontCurve">
            <summary>
            The front curve of this enveloped curve (Center curve control points + envelopThickness for Y axis)
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.FrontCurve">
            <summary>
            The line *in front* of the sized object, describing the boundary point furthest forward 
            NOTE : when an object is moving forwards, the back line is still the line with the lowest % on spline
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.centerCurve">
            <summary>
            The center curve of this enveloped curve
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.CenterCurve">
            <summary>
            The line describing the centre line of the object
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.backCurve">
            <summary>
            The back curve of this enveloped curve (Center curve control points - envelopThickness for Y axis)
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.BackCurve">
            <summary>
            The line *behind* of the sized object, describing the boundary point furthest backwards
            NOTE : when an object is moving backwards, the back line is still the line with the lowest % on spline
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.#ctor(u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Double,u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.CurveDescriptor)">
            <summary>
            Envelop a NURBS curve without clamping
            </summary>
            <param name="_protoCurve">The curve to use as a basis for clamping</param>
            <param name="_envelopThickness">The thickness to use for clamping, towards front and back</param>
            <param name="_protoCurveDescription">The curve used as prototype, by default the centre curve - but front or back are also allowed</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.#ctor(u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Double,u040.prespective.math.doubles.DVector2,u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.CurveDescriptor)">
            <summary>
            Envelop a NURBS curve with clamping
            </summary>
            <param name="_protoCurve">The curve to use as a basis for clamping</param>
            <param name="_envelopThickness">The thickness to use for clamping, towards front and back</param>
            <param name="_clampingRangeYAxis">The clamping range to use for this envelop</param>
            <param name="_protoCurveDescription">The curve used as prototype, by default the centre curve - but front or back are also allowed</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.Offset(u040.prespective.math.doubles.DVector2)">
            <summary>
            Offset this enveloped curve
            </summary>
            <param name="_offset">The X and Y values to offset this enveloped curve with</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.ContainsDeltaOnYAxis(System.Double)">
            <summary>
            Check if the enveloped curve contains a certain difference on the Y axis
            </summary>
            <param name="_minYDelta">The minimum difference/delta on the Y axis to check for</param>
            <returns>A boolean indicating whether or not the enveloped curve contains a certain difference on the Y axis</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.ContainsDeltaInXSectionOnYAxis(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Retrieve a time trimmed curve bounds set
            </summary>
            <param name="_xRange">The x range to check the delta for</param>
            <param name="_minYDelta">The minimum difference/delta on the Y axis to check for</param>
            <returns>A boolean indicating whether or not the enveloped curve contains a certain difference on the Y axis within the given X range</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.TrimmedCurveBounds(u040.prespective.math.doubles.DVector2)">
            <summary>
            Get the bounds of a trimmed copy of this enveloped curve
            </summary>
            <param name="_xRange">The x range to trim a copy of this enveloped curve with before returning the bounds for said trimmed curve copy (does not trim this enveloped curve, just a copy to get the bounds for)</param>
            <returns>The bounds of the trimmed curve copy (can return multiple bounds in case of an envelop thickness of 0 and straight up sections)</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.GetEnvelopYRangeForX(System.Double,u040.prespective.math.spline.doubles.DCurveBounds[]@,System.Double@,System.Boolean@,System.Boolean,System.Double,System.Double)">
            <summary>
            Get the size of the y range for any given value in the x range of the curve (size of y envelop for x)
            Note: Shorthand variant of the GetEnvelopYRangeForX function returning CurveBounds (which can be easily overlap-checked)
            </summary>
            <param name="_x">The x value to get the y range size for</param>
            <param name="_bounds">(out parameter) The y-bounds that are covered (_x, minimum y) and (_x, maximum y) (Note: if a clamping cut-off is encountered 2 values can be returned)</param>
            <param name="_vectorAtPoint">(out parameter) The delta/vector this curve has at _x</param>
            <param name="_functionFailed">If the function failed to get at least one bounds</param>
            <param name="_verbose">Whether or not to enable verbose logging</param>
            <param name="_clampingMargin">The 0-range cut-off value to use (default = 1e-20) (note : numbers less than 1E-16 are even in double precision no longer displayed)</param>
            <param name="_zeroSpeedOverride">Speed override if self is zero (default = 0d)</param>
            <returns>A boolean indicating whether or not the function managed to get at least a single bounds</returns>
            ToDo: ref bool _functionFailed is redundant?
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.GetEnvelopYRangeForX(System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Double@,System.Boolean@,System.Boolean,System.Double,System.Double)">
            <summary>
            Get the size of the y range for any given value in the x range of the curve (size of y envelop for x)
            </summary>
            <param name="_x">The x value to get the y range size for</param>
            <param name="_yBounds">(out parameter) The y-bounds that are covered (minimum y, maximum y) (Note: if a clamping cut-off is encountered 2 values can be returned)</param>
            <param name="_vectorAtPoint">(out parameter) The delta/vector this curve has at _x</param>
            <param name="_functionFailed">If the function failed to get at least one bounds</param>
            <param name="_verbose">Whether or not to enable verbose logging</param>
            <param name="_clampingMargin">The 0-range cut-off value to use (default = 1e-20) (note : numbers less than 1E-16 are even in double precision no longer displayed)</param>
            <param name="_zeroSpeedOverride">Speed override if self is zero (default = 0d)</param>
            <returns>A boolean indicating whether or not the function managed to get at least a single bounds</returns>
            ToDo: ref bool _functionFailed is redundant?
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.ResetCurvesFromCurve(u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.CurveDescriptor,System.Double)">
            <summary>
            resets the enveloped curve from given curve
            </summary>
            <param name="_resetCurve">reset curve type</param>
            <param name="_tolerance">The margin used for resetting this curve (default = 1E-10d)</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.LimitCurve(u040.prespective.math.spline.doubles.DNURBSCurve2D,u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2,u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.CurveDescriptor,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Limit a curve within a given x range to the maximum y value of a given limiter curve
            </summary>
            <param name="_limiter">The curve to limit this curve with</param>
            <param name="_beginLimitValue">value limits starts on</param>
            <param name="_xRangeLimit">The x range limit to limit this curve for</param>
            <param name="_limitedCurve">Which of the curves (front, center or back) of this enveloped curve should be limited (default = CurveDescriptor.FRONT)</param>
            <param name="_movingForward">If the direction of the limiting curve is moving forward (default = true)</param>
            <param name="_tolerance">The margin used for limiting this curve (default = 1E-10d)</param>
            <param name="_verbose">If the function should output debug information (default = false)</param>
            <returns>if limited</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.Trim(u040.prespective.math.doubles.DVector2)">
            <summary>
            Trim the curve over the X axis
            </summary>
            <param name="_xRangeToKeep">The x range to keep</param>
            <returns>A boolean indicating whether or not the trim was successful</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.Clip(u040.prespective.math.doubles.DVector2,u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D[]@,System.Double)">
            <summary>
            Get a copy of the enveloped curve that has been clipped with a given x range
            </summary>
            <param name="_xRangeToRemove">x range to clip</param>
            <param name="_clippedCurves">(out parameter) clipped curves</param>
            <param name="_margin">The margin for clipping (default = 1E-10d)</param>
            <returns>A boolean indicating whether or not the clipping was successful</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.Merge(u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D,System.Double,System.Boolean)">
            <summary>
            Merge this enveloped curve with another enveloped curve
            </summary>
            <param name="_opposingRecord">The other enveloped curve to merge with</param>
            <param name="_clippingMargin">The margin to use for clipping when merging curves</param>
            <param name="_verbose">Whether or not the function should be verbose</param>
            <returns>A boolean indicating whether or not the merge was successful</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.Bounds(u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2@)">
            <summary>
            Get the minimum and maximum bounds of this curve
            Note: This function does NOT consider clamping when getting the Bounds
            </summary>
            <param name="_minimumBounds">(out parameter) The minimum bounds of this enveloped curve</param>
            <param name="_maximumBounds">(out parameter) the maximum bounds of this enveloped curve</param>
            <returns>A boolean indicating whether or not the bounds could be returned</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.updateCurveEnvelop(u040.prespective.math.spline.doubles.DNURBSCurve2D,u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.CurveDescriptor,System.Double)">
            <summary>
            Updates the entire envelop by recalculating the whole based on one of the component curves
            </summary>
            <param name="_newCurve">The new curve to base the envelop on</param>
            <param name="_newCurveDescriptor">The new curve type</param>
            <param name="_margin">Ignore, _margin is only used in the override of this function in the EnvelopedDNURBSCurve2DVariableThickness class (default = 1E-10d)</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.ToString">
            <summary>
            Get the ToString() of this enveloped curve
            </summary>
            <returns>A string with the following format: "{EnvelopThickness: " + EnvelopThickness + ",\nFrontCurve: " + frontCurve.ToString() + "\nCenterCurve: " + centerCurve.ToString() + "\nBackCurve: " + backCurve.ToString() + "}"</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D.Copy">
            <summary>
            get a copy of this enveloped curve
            </summary>
            <returns>A copy of this enveloped curve</returns>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DpolynominalForm.Start">
            <summary>
            Start time of the polynomial
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DpolynominalForm.End">
            <summary>
            End time of the polynomial
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DpolynominalForm.FunctionParameters">
            <summary>
            The polynomial coefficients : f(X) = A0X^(Coef[0]) + A1X^(Coef[1]) .. + A(Coef[n-1])X^1 + Coef[n]
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DpolynominalForm.Degree">
            <summary>
            Returns the degree of this polynomial formula
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.CreatePolynomialCurveSetFromDNurbsCurve2D(u040.prespective.math.spline.doubles.DNURBSCurve2D)">
            <summary>
            creates the polynominals of a nurbs curve
            </summary>
            <param name="_nurbsCurve">nurbs curve</param>
            <returns>the polynominal descriptions of the nurbs curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.GetDifferential">
            <summary>
            gets the differential polynominal of the polynominal
            </summary>
            <returns>differential polynominal</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.GetPointOnPolynominal(System.Double)">
            <summary>
            gets the point of polynominal at x
            </summary>
            <param name="_x">x</param>
            <returns>point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.Intersect(u040.prespective.math.spline.doubles.DpolynominalForm,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Boolean)">
            <summary>
            finds intersection between this polynominal and other polynominal
            </summary>
            <param name="_other">other polynominal</param>
            <param name="_intersections">found intersections</param>
            <param name="_allowStraightUpSections"></param>
            <returns>if found intersections</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.intersect1(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Boolean)">
            <summary>
            test for linear intersection
            </summary>
            <param name="_lineACoeficients">coefficient params for formula A</param>
            <param name="_lineBCoeficients">coefficient params for formula B</param>
            <param name="_intersections">found intersections</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.intersect2(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@)">
            <summary>
            test for Quadratic intersections
            </summary>
            <param name="_polynomialCoefficientsA">coefficient params for formula A</param>
            <param name="_polynomialCoefficientsB">coefficient params for formula B</param>
            <param name="_intersections">found intersections</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.intersect3(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@)">
            <summary>
            Test for Cubic intersections
            </summary>
            <param name="_polynomialCoefficientsA">coefficient params for formula A</param>
            <param name="_polynomialCoefficientsB">coefficient params for formula B</param>
            <param name="_intersections">found intersections</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.PolynomialFromNPoints(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2})">
            <summary>
            creates a polynominal of given points
            </summary>
            <param name="_points">points</param>
            <returns>polynominal</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.polynomialFrom1Point(u040.prespective.math.doubles.DVector2)">
            <summary>
            Creates a LINEAR polynomial from 
            </summary>
            <param name="_point"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.polynomialFrom2Points(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Function to calculate a linear polynomial from 2 (equally weighted) points
            </summary>
            <param name="_point1">first point on line</param>
            <param name="_point2">second point on line</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.polynomialFrom3Points(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Function to calculate a quadric polynomial from 3 (equally weighted) points
            </summary>
            <param name="_point1">first limit</param>
            <param name="_point2">second limit</param>
            <param name="_point3">third limit</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DpolynominalForm.determinant(System.Double,System.Double,System.Double,System.Double)" -->
        <member name="M:u040.prespective.math.spline.doubles.DpolynominalForm.getValueAtForPolynominal(System.Double,System.Collections.Generic.List{System.Double})">
            <summary>
            Calculate the y-coord for a polynomial with coeficients y = A0 * x^(n) + A1 * x^(n-1) .. + A(n-1) * x + An using Horner's method
            
            https://www.youtube.com/watch?v=39pu-z3KpAQ
            </summary>
            <param name="_x">the X to find the Y for</param>
            <param name="_polynominalCoefficients">the coefficients starting at the highest order</param>
            <returns>y</returns>
        </member>
        <member name="T:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager">
            <summary>
            <description>
            Abstract Class to manage Traversal of objects over a PolyBezier curve in a equidistant percentual fashion.
                     This class is required since this is not the default for PolyBezier traversal, by default the _u (curve time) value
                     leads to slower travel in curve areas with more control points closer together, and faster travel in areas with less
                     control points
            </description>
            <version 
                ver="1.0.0" 
                author="TDK" 
                date="191114">
                Refactored from the original spline tooling
            </version>
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.TesselationMode">
            <summary>
            The Tessellation mode to useS
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.TesselationSamples">
            <summary>
            When tessellating, what sample ratio to use for tessellation
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.MinSamplesPerSpan">
            <summary>
            minimum number of curve samples to use per span
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.DistanceBetweenSamples">
            <summary>
            Distance between samples
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.AngleBetweenSamples">
            <summary>
            Amount angle between samples in degrees
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.CurveLength">
            <summary>
            Returns the length of the curve in world units
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.SetTesselatedSample(System.Int32)">
            <summary>
            function to set the amount of tessellated samples
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.OnControlPolyChanged(u040.prespective.math.spline.doubles.DNURBSCurve3D,u040.prespective.math.doubles.DMatrix4x4,System.Double,System.Int32,System.Int32)">
            <summary>
            Called when the control polygon changed
            </summary>
            <param name="_changedVerts"></param>
            <param name="_globalToLocal"></param>
            <param name="_angleDifferenceBeginEndCurve"></param>
            <param name="_startIndex"></param>
            <param name="_endIndex"></param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.GetLocalPointAtEquidistantPerc(System.Double)">
            <summary>
            Get the point in world space at equidistant curve percentage  
            </summary>
            <param name="_perc"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.GetEqPercFromDistance(System.Double)">
            <summary>
            Get the equidistant percentage after traversing 
            </summary>
            <param name="_distance"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.GetClosestLocalPointOnLine(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DMatrix4x4,System.Double@,System.Double@)">
            <summary>
            A spline
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.DEBUG_Colors">
            <summary>
            Default Colours used to colour the spans when visualized
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DPolyNURBSTraversalManager.DEBUGGetTesselatedLocalCurve">
            <summary>
            function to debug tessellated curve
            </summary>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.math.spline.doubles.DParametricBasisCurve">
            <summary>
            <description>
            Class for creating a Parametric Basis Curve with double precision
            A Curve described by quadratic or linear functions for the x, y and z components
            </description>
            <version 
                ver="1.0.0" 
                author="TDK" 
                date="191114">
                Refactored from the original spline tooling
            </version>
            <version 
                ver="1.0.1" 
                author="TGE" 
                date="200602">
                Made get tessellated curve return an array
            </version>
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DParametricBasisCurve.functionParametersX">
            <summary>
            Ax^2 + BX + C parameters for the x-parabola
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DParametricBasisCurve.functionParametersY">
            <summary>
            Ax^2 + BX + C parameters for the y-parabola
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DParametricBasisCurve.functionParametersZ">
            <summary>
            Ax^2 + BX + C parameters for the z-parabola
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Generates a Parametric Basis Curve based on 3 limit points
            Generally used to convert a NURBS curve to a Parametric Basis Curve
            </summary>
            <param name="_limitPoints"></param>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DParametricBasisCurve.XFParams">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DParametricBasisCurve.YFParams">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DParametricBasisCurve.ZFParams">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.GetTesselatedCurve(System.Int32)">
            <summary>
            get tessellated curve
            </summary>
            <param name="_numberOfTesselationPoints">number of tessellation points</param>
            <returns>tessellated curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.GetPoint(System.Double)">
            <summary>
            get point at percentage
            </summary>
            <param name="_curvePercentage">percentage</param>
            <returns>point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.getcurveLength(System.Double,System.Double,System.Double)">
            <summary>
            Retrieves the curve length through integration
            </summary>
            <param name="_startPercentageCurve">the start _t for integration</param>
            <param name="_endPercentageCurve">the end _t for integration</param>
            <param name="_stepsizeOfPercentageOnCurve">the stepsize for integration</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.CreateParametricCurveSetFromNurbsCurve(u040.prespective.math.spline.doubles.DNURBSCurve3D)">
            <summary>
            
            </summary>
            <param name="_nCurve"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.CreateParametricCurveSetFromBasisNurbs(u040.prespective.math.spline.doubles.DNURBSCurve3D,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3[]}@,System.Int32)">
            <summary>
            
            </summary>
            <param name="_nCurve"></param>
            <param name="_tesselatedResults"></param>
            <param name="_tSections"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.integrateParabola(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double,System.Double,System.Double)">
            <summary>
            Calculates the length of a Parabola Line (segment), default in range [0, 1] using 0.01f as stepsize (i.e. 100 samples)
            Integral Under Parabola Line (not middle or over)
            </summary>
            <param name="_xparameters">the x functional parameters</param>
            <param name="_yparameters">the y functional parameters</param>
            <param name="_zparameters">the z functional parameters</param>
            <param name="startPercentageCurve">the start of the range to integrate, default 0</param>
            <param name="_endPercentageCurve">the end of the range to integrate, default 1</param>
            <param name="_stepSizeofPercentageOnCurve">the step size</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.parabolFrom3Points(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Function to calculate a parabola from 3 (equally weighted) points
            </summary>
            <param name="_p1">first limit</param>
            <param name="_p2">second limit</param>
            <param name="_p3">third limit</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DParametricBasisCurve.determinant(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Determinant calculation function
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_c"></param>
            <param name="_d"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.math.spline.doubles.DCurveBounds">
             <summary>
             Struct used for validating the bounds of 2D Curves (partner class to DNURBSCurve2D and EnvelopedDNURBSCurve2D)
             (Included as part of DES)
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DCurveBounds.Minimum">
            <summary>
            The minimum (X, Y) point of this rectangular bounds
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DCurveBounds.Maximum">
            <summary>
            The maximum (X, Y) point of this rectangular bounds
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.#ctor(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Default constructor - A bounds or boundary rectangle is described by its minimum and maximum (x,y) coordinates
            </summary>
            <param name="_point1">The first boundary position</param>
            <param name="_point2">The second boundary position</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.BoundsBxContainsBoundsAx(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check whether ot not the _minimumB and _maximumB contain the _minimumA and the _maximumA for the X values
            </summary>
            <param name="_minimumA">The minimum X and Y values of the bounds that may be contained within the other bounds</param>
            <param name="_maximumA">The maximum X and Y values of the bounds that may be contained within the other bounds</param>
            <param name="_minimumB">The minimum X and Y values of the bounds that may contain the other bounds</param>
            <param name="_maximumB">The maximum X and Y values of the bounds that may contain the other bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum X values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum X values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <returns>A boolean indicating whether ot not the _minimumB and _maximumB contain the _minimumA and the _maximumA for the X values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IsContainedByOtherBoundsX(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if the X values of this bounds is contained by the _otherBounds
            </summary>
            <param name="_otherBounds">The other bounds to check with</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum X values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum X values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <returns>A boolean indicating whether ot not the _otherBounds contains this bounds for the X values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.BoundsByContainsBoundsAy(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check whether ot not the _minimumB and _maximumB contain the _minimumA and the _maximumA for the Y values
            </summary>
            <param name="_minimumA">The minimum X and Y values of the bounds that may be contained within the other bounds</param>
            <param name="_maximumA">The maximum X and Y values of the bounds that may be contained within the other bounds</param>
            <param name="_minimumB">The minimum X and Y values of the bounds that may contain the other bounds</param>
            <param name="_maximumB">The maximum X and Y values of the bounds that may contain the other bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <returns>A boolean indicating whether ot not the _minimumB and _maximumB contain the _minimumA and the _maximumA for the Y values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IsContainedByOtherBoundsY(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if the Y values of this bounds is contained by the _otherBounds
            </summary>
            <param name="_otherBounds">The bounds to compare against</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <returns>A boolean indicating whether ot not the _otherBounds contains this bounds for the Y values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.BoundsBxyContainsBoundsAxy(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check whether ot not the _minimumB and _maximumB contain the _minimumA and the _maximumA for the X and Y values
            </summary>
            <param name="_minimumA">The minimum X and Y values of the bounds that may be contained within the other bounds</param>
            <param name="_maximumA">The maximum X and Y values of the bounds that may be contained within the other bounds</param>
            <param name="_minimumB">The minimum X and Y values of the bounds that may contain the other bounds</param>
            <param name="_maximumB">The maximum X and Y values of the bounds that may contain the other bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum X and Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum X and Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <returns>A boolean indicating whether ot not the _minimumB and _maximumB contain the _minimumA and the _maximumA for the X and Y values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IsContainedByOtherBoundsXY(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if the Y values of this bounds is contained by the _otherBounds
            </summary>
            <param name="_otherBounds">The bounds to compare against</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum X and Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum X and Y values may be equal when checking if one of the bounds contains the other (default = true)</param>
            <returns>A boolean indicating whether ot not the _otherBounds contains this bounds for the X and Y values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IntersectsX(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an intersection between two bounds for the X values
            </summary>
            <param name="_minimumA">The minimum X and Y value for the first bounds</param>
            <param name="_maximumA">The maximum X and Y value for the first bounds</param>
            <param name="_minimumB">The minimum X and Y value for the second bounds</param>
            <param name="_maximumB">The maximum X and Y value for the second bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an intersection (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an intersection (default = true)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IntersectsX(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an intersection between two bounds for the X values
            </summary>
            <param name="_otherBounds">The other bounds to check with</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an intersection (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an intersection (default = true)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IntersectsY(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an intersection between two bounds for the Y values
            </summary>
            <param name="_minimumA">The minimum X and Y value for the first bounds</param>
            <param name="_maximumA">The maximum X and Y value for the first bounds</param>
            <param name="_minimumB">The minimum X and Y value for the second bounds</param>
            <param name="_maximumB">The maximum X and Y value for the second bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an intersection (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an intersection (default = true)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IntersectsY(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an intersection between two bounds for the X values
            </summary>
            <param name="_otherBounds">The other bounds to check with</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an intersection (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an intersection (default = true)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IntersectsXY(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an intersection between two bounds for the X and Y values
            </summary>
            <param name="_minimumA">The minimum X and Y value for the first bounds</param>
            <param name="_maximumA">The maximum X and Y value for the first bounds</param>
            <param name="_minimumB">The minimum X and Y value for the second bounds</param>
            <param name="_maximumB">The maximum X and Y value for the second bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an intersection (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an intersection (default = true)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.IntersectsXY(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an intersection between two bounds for the X and Y values
            </summary>
            <param name="_otherBounds">The other bounds to check with</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an intersection (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an intersection (default = true)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.OverlapsX(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an overlap between two bounds for the X values
            </summary>
            <param name="_minimumA">The minimum X and Y value for the first bounds</param>
            <param name="_maximumA">The maximum X and Y value for the first bounds</param>
            <param name="_minimumB">The minimum X and Y value for the second bounds</param>
            <param name="_maximumB">The maximum X and Y value for the second bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an overlap (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an overlap (default = true)</param>
            <returns>A boolean indicating whether or not an overlap was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.OverlapsX(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an overlap between two bounds for the X values
            </summary>
            <param name="_otherBounds">The other bounds to check with</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an overlap (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an overlap (default = true)</param>
            <returns>A boolean indicating whether or not an overlap was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.OverlapsY(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an overlap between two bounds for the Y values
            </summary>
            <param name="_minimumA">The minimum X and Y value for the first bounds</param>
            <param name="_maximumA">The maximum X and Y value for the first bounds</param>
            <param name="_minimumB">The minimum X and Y value for the second bounds</param>
            <param name="_maximumB">The maximum X and Y value for the second bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an overlap (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an overlap (default = true)</param>
            <returns>A boolean indicating whether or not an overlap was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.OverlapsY(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an overlap between two bounds for the Y values
            </summary>
            <param name="_otherBounds">The other bounds to check with</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an overlap (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an overlap (default = true)</param>
            <returns>A boolean indicating whether or not an overlap was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.OverlapsXY(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Check if there is an overlap between two bounds for the X and Y values
            </summary>
            <param name="_minimumA">The minimum X and Y value for the first bounds</param>
            <param name="_maximumA">The maximum X and Y value for the first bounds</param>
            <param name="_minimumB">The minimum X and Y value for the second bounds</param>
            <param name="_maximumB">The maximum X and Y value for the second bounds</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an overlap (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an overlap (default = true)</param>
            <returns>A boolean indicating whether or not an overlap was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.OverlapsXY(u040.prespective.math.spline.doubles.DCurveBounds,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Check if there is an overlap between two bounds for the X and Y values
            </summary>
            <param name="_otherBounds">The other bounds to check with</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum values should be considered for checking for an overlap (default = true)</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum values should be considered for checking for an overlap (default = true)</param>
            <param name="_margin">margin</param>
            <returns>A boolean indicating whether or not an overlap was found</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.MergeBoundsIfPossible(u040.prespective.math.spline.doubles.DCurveBounds,u040.prespective.math.spline.doubles.DCurveBounds@,System.Boolean,System.Boolean)">
            <summary>
            Determine if these bounds overlap, and if so return the merged result
            </summary>
            <param name="_otherBounds">The opposing bounds to merge with</param>
            <param name="_resultBounds">(Out parameter) The resulting bounds after merging</param>
            <param name="_minimumMayBeEqual">Whether or not the minimum bounds may be equal for merging</param>
            <param name="_maximumMayBeEqual">Whether or not the maximum bounds may be equal for merging</param>
            <returns>If the bounds can be merged</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.AsClockwiseCurve">
            <summary>
            Returns this DCurveBounds as a clockwise curve
            </summary>
            <returns>This DCurveBounds as a clockwise curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.GetTrimmedEnvelopedCurveBounds(u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D,u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Get the Bounds of the Enveloped curve by merging the bounds of each individual control point section of the front, center and back curves in the envelop after removing all the points outside of the given trim for X.
            Bounds that overlap will be merged, while bounds that don't overlap will end up as separate elements in the list unless _mergeToBlock is true.
            </summary>
            <param name="_envelopedCurve">The enveloped curve to get the DCurveBounds for</param>
            <param name="_xTrim">The minimum and maximum X values for the curve to get the Bounds for. Points with X outside of the _xTrim will be ignored for getting the bounds</param>
            <param name="_ignoreStraightUpSections">Whether or not sections that go straight up should be ignored (default = true)</param>
            <param name="_mergeToBlock">If all resulting bounds should be merged into a single DCurveBounds regardless of having no overlap (default = false)</param>
            <param name="_straightUpMargin">The margin to check the straight up sections with. Straight up means the difference for X is smaller than _straightUpMargin while the difference for Y is bigger than _straightUpMargin (default = 1E-10d)</param>
            <param name="_verbose">Whether or not debug messages should be printed (default = false)</param>
            <returns>A list of DCurveBounds giving one or more bounds for the enveloped curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.GetEnvelopedCurveBounds(u040.prespective.math.spline.doubles.EnvelopedDNURBSCurve2D,System.Boolean,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Get the Bounds of the Enveloped curve by merging the bounds of each individual control point section of the front, center and back curves in the envelop.
            Bounds that overlap will be merged, while bounds that don't overlap will end up as separate elements in the list unless _mergeToBlock is true.
            </summary>
            <param name="_envelopedCurve">The enveloped curve to get the DCurveBounds for</param>
            <param name="_ignoreStraightUpSections">Whether or not sections that go straight up should be ignored (default = true)</param>
            <param name="_mergeToBlock">If all resulting bounds should be merged into a single DCurveBounds regardless of having no overlap (default = false)</param>
            <param name="_straightUpMargin">The margin to check the straight up sections with. Straight up means the difference for X is smaller than _straightUpMargin while the difference for Y is bigger than _straightUpMargin (default = 1E-10d)</param>
            <param name="_verbose">Whether or not debug messages should be printed (default = false)</param>
            <returns>A list of DCurveBounds giving one or more bounds for the enveloped curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.GetEnvelopedCurveBounds(u040.prespective.math.spline.doubles.DCurveBounds[],u040.prespective.math.spline.doubles.DCurveBounds[],System.Boolean,System.UInt32)">
            <summary>
            Get the Bounds of the Enveloped curve by merging the bounds of each individual control point section of the front, center and back curves in the envelop.
            Bounds that overlap will be merged, while bounds that don't overlap will end up as separate elements in the list unless _mergeToBlock is true.
            </summary>
            <param name="_frontCurveBounds">The front curve of the envelop</param>
            <param name="_backCurveBounds">The back curve of the envelop</param>
            <param name="_mergeToBlock">If all resulting bounds should be merged into a single DCurveBounds regardless of having no overlap (default = false)</param>
            <param name="_maxPasses">The maximum amount of passes allowed to find the bounds for the curve (default = 9999)</param>
            <returns>A list of DCurveBounds giving one or more bounds for the enveloped curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.GetTrimmedCurveBounds(u040.prespective.math.spline.doubles.DNURBSCurve2D,u040.prespective.math.doubles.DVector2,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Get the Bounds of the curve by merging the bounds of each individual control point section of the curve after removing all points outside of the X trim
            </summary>
            <param name="_curve">The curve to get the bounds for</param>
            <param name="_xTrim">The minimum and maximum X values for the curve to get the Bounds for. Points with X outside of the _xTrim will be ignored for getting the bounds</param>
            <param name="_ignoreStraightUpSections">Whether or not sections that go straight up should be ignored (default = true)</param>
            <param name="_straightUpMargin">The margin to check the straight up sections with. Straight up means the difference for X is smaller than _straightUpMargin while the difference for Y is bigger than _straightUpMargin (default = 1E-10d)</param>
            <param name="_verbose">Whether or not debug messages should be printed (default = false)</param>
            <returns>The Bounds of the curve by merging the bounds of each individual control point section of the curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.GetCurveBounds(u040.prespective.math.spline.doubles.DNURBSCurve2D,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Get the Bounds of the curve by merging the bounds of each individual control point section of the curve
            </summary>
            <param name="_curve">The curve to get the bounds for</param>
            <param name="_ignoreStraightUpSections">Whether or not sections that go straight up should be ignored (default = true)</param>
            <param name="_straightUpMargin">The margin to check the straight up sections with. Straight up means the difference for X is smaller than _straightUpMargin while the difference for Y is bigger than _straightUpMargin (default = 1E-10d)</param>
            <param name="_verbose">Whether or not debug messages should be printed (default = false)</param>
            <returns>The Bounds of the curve by merging the bounds of each individual control point section of the curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DCurveBounds.ToString">
            <summary>
            A custom ToString() function that returns a string with the minimum and maximum values of this DCurveBounds
            </summary>
            <returns>A string containing the minimum and maximum values of this DCurveBounds</returns>
        </member>
        <member name="T:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager">
            <summary>
            <description>
            Traversal Manager that tessellates the NURBS Curve (*makes explicit*) and allows objects
                     to traverse the curve in an equidistant percentual manner by calculating the distance travelled between
                     these (buffered) explicit points.
                     
                     This type of Traversal Manager is more precise (since all objects move over the explicit variant of the NURBS curve, and the length of this variant is exactly known)
                     But this variant is more performance heavy; particularly when moving control points of the NURBS Curve (since the affected section will need to be made explicit again)
                     
            </description>
            <version 
                ver="1.0.0" 
                author="TDK" 
                date="191114">
                Refactored from the original spline tooling
            </version>
            <version 
                ver="1.0.1" 
                author="TGE" 
                date="200603">
                Tessellation now controlled by distance
            </version>
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.spanRecords">
            <summary>
            Buffer with explicit results for position calculation
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.totalCurveLength">
            <summary>
            Buffer with the total curve length
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.totalCurveLengthLocal">
            <summary>
            Buffer with the total curve length in local space
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.CurveLength">
            <summary>
            After expressing the curve explicitly, the total curve length == totalCurveLength
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.OnControlPolyChanged(u040.prespective.math.spline.doubles.DNURBSCurve3D,u040.prespective.math.doubles.DMatrix4x4,System.Double,System.Int32,System.Int32)">
            <summary>
            Called when the Control Polygon changed
            Since this curve is explicitly managed, we will need to recalculate the section that was affected by the change
            </summary>
            <param name="_curve">NURBS curve we are managing</param>
            <param name="_globalToLocal">matrix to make values local</param>
            <param name="_angleDifferenceBeginEndCurve">rotation difference begin end curve</param>
            <param name="_startIndex">first Control Polygon Vert Index affected by the change</param>
            <param name="_endIndex">last Control Polygon Vert Index affected by the change</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.expressParamCurve(u040.prespective.math.spline.doubles.DParametricBasisCurve,u040.prespective.math.doubles.DMatrix4x4,System.Double)">
            <summary>
            Make a ParametricBasisCurve Explicit (i.e. tessellate)
            and buffer the results for translation calculations later
            </summary>
            <param name="_curve">the parametric curve to tessellate</param>
            <param name="_globalToLocal">matrix to make values local</param>
            <param name="_angleDifferenceBeginEndCurve">rotation difference begin end curve</param>
            <returns>explicit record of the span</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.getMaximumAngleOverCurve(u040.prespective.math.spline.doubles.DParametricBasisCurve)">
            <summary>
            gets maximum angle of the curve
            </summary>
            <param name="_curve">curve</param>
            <returns>maximum angle</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.getAngleDifferenceBeginEndCurve(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            gets the angle difference between the begin (0) and end (1) vector along given curve
            </summary>
            <param name="_params">parameters description curve (_params[0] * x^2 + _params[1] * x + _params[2])</param>
            <param name="_pa_nextMarginrams">margin to check next point in</param>
            <returns>angle between end and begin vector</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.GetEqPercFromDistance(System.Double)">
            <summary>
            Simply divide the distance by total curve length
            </summary>
            <param name="_distance"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.GetLocalPointAtEquidistantPerc(System.Double)">
            <summary>
            Returns the point at equidistant percentage on this curve
            </summary>
            <param name = "_perc" > the percentage to look for</param>
            <returns>a point on this curve</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DEBUGGetTesselatedLocalCurve">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.GetClosestLocalPointOnLine(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DMatrix4x4,System.Double@,System.Double@)">
            <summary>
            get closed point on line of given point
            </summary>
            <param name="_localPoint">given point</param>
            <param name="_localToGlobal">local to global matrix</param>
            <param name="_distance">distance between point and found point</param>
            <param name="_eqPerc">percentage</param>
            <returns>closed point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.SetTesselatedSample(System.Int32)">
            <summary>
            set tessellated samples
            </summary>
            <param name="_value">amount of samples</param>
        </member>
        <member name="T:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DExplicitSpanRecord">
            <summary>
            @STRUCT : DExplicitSpanRecord
            
            @ABOUT : A struct used for storing explicit results describing a Parametric Basis Curve
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: V1.00 - 10/10/2018 - Implemented Explicit Traversal Manager Buffer (to limit processing impact of traversing an object across the curve) 
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DExplicitSpanRecord.SpanCurve">
            <summary>
            Parametric Basis Curve Describing this span of the NURBS curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DExplicitSpanRecord.ExplicitLocalPointRecord">
            <summary>
            Buffer with explicit coordinates on this span of the NURBS Curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DExplicitSpanRecord.LocalIntervalRecord">
            <summary>
            Buffer with explicit distances between coordinates on this span of the NURBS curve in local space (section #0 is interval between explicitPointRecord #0 and #1)
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DExplicitSpanRecord.GlobalIntervalRecord">
            <summary>
            Buffer with explicit distances between coordinates on this span of the NURBS curve in global space (section #0 is interval between explicitPointRecord #0 and #1)
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DExplicitSpanRecord.GlobalSpanLength">
            <summary>
            Total length of this span of the NURBS Curve in global space
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DExplicitPolyNURBSTraversalManager.DExplicitSpanRecord.LocalSpanLength">
            <summary>
            Total length of this span of the NURBS Curve in local space
            </summary>
        </member>
        <member name="T:u040.prespective.math.spline.doubles.DNURBSCurve3D">
            <summary>
            <description>
            Class for generating a NURBS basis curve with double precision (i.e. hard corners, and point weighting not (yet) supported)
                     Supports ring shaping via control polygon point copying and limiting the traversion range (i.e. _u less than range [0,1])
            </description>
            <version 
                ver="1.0.0" 
                author="TDK" 
                date="191114">
                Refactored from the original spline tooling
            </version>
            <version 
                ver="1.0.1" 
                author="TGE" 
                date="070820">
                Made the Knot vector an array instead of a list (for preformance)
            </version>
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.controlpoints">
            <summary>
            Contains the 'complete' control polygon; this polygon is different from the 'core control polygon' when dealing with
            a ring shaped curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.curveorder">
            <summary>
            The order of this curve
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.knotvector">
            <summary>
            Buffers the Basis Knot vector, describing the influence of each control point at a given time
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.NURBSCurveIsRing">
            <summary>
            Whether this Curve describes a ring
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.curveprecentagenotused">
            <summary>
            The share of 'bezier time' not used (i.e. _u less than range [0,1])
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Int32,System.Boolean)">
            <summary>
            constructor
            </summary>
            <param name="_controlPolygon">control polygon</param>
            <param name="_order">orde</param>
            <param name="_isRing">is clossed</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.initSettings(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Int32,System.Boolean)">
            <summary>
            Actually setup the NURBSCurve; it has been seperated from the constructor since every
            setting requires a recalculation of the local variables
            </summary>
            <param name="_controlPolygon">the control polygon to use</param>
            <param name="_order">the order of the nurbs curve</param>
            <param name="_isRing">whether the curve should be a ring</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.makeRingControlPoints(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}@,System.Int32)">
            <summary>
            Converts a controlPolygon to a Control Polygon usable as ring
            
            This effectively means adding # _order points from the start of the control polygon to the end of the control polygon
            and adding # _order points from the end of the control polygon to the start of the polygon
            
            (NB!. don't forget that, in order to move an object over the curve, you will need to use 
            the _t range [(1f/ _controlPolygon.Count (input) + _order), 1f - (1f/ _controlPolygon.Count (input) + _order)])
            
            </summary>
            <param name="_contolpoints"></param>
            <param name="_order"></param>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve3D.ControlPoints">
            <summary>
            The control polygon described by the control points
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.needsCPRecalc(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Determine if the controlpolygon has changed 'too much'; meaning the nurbs needs to be recalculated
            </summary>
            <param name="_new">the new control polygon</param>
            <param name="_oldCore">the old core control polygon (excluding the adds from making it a ring</param>
            <returns></returns>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve3D.Order">
            <summary>
            The order of the BSpline
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve3D.IsRing">
            <summary>
            Whether the Curve should represent a ring
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve3D.SpanCount">
            <summary>
            Returns the Number of Spans this Nurbs Curve Contains
            </summary>
        </member>
        <member name="P:u040.prespective.math.spline.doubles.DNURBSCurve3D.KnotVector">
            <summary>
            Returns the Current Knot Vector of this NURBS Curve
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.SecondOrder3DNURBSCurveIntersection(u040.prespective.math.spline.doubles.DNURBSCurve3D,System.Int32,System.Double,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}@)">
            <summary>
            gets the intersect point of 2 nurbscurves through bounding boxes (de casteljau algorithm)
            </summary>
            <param name="_intersectionCurve">to check intersection with</param>
            <param name="_numberOfPasses">number of bounding passes before stopping</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <param name="_intersectPoints">resulting intersect points</param>
            <returns>if found intersection</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.getBezierPointsSpline(u040.prespective.math.spline.doubles.DNURBSCurve3D)">
            <summary>
            get the bezier curves points of a nurbs curve
            </summary>
            <param name="_nurbsCurve">nurbs curve</param>
            <returns>bezier curves points</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.findBoudingBox(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Double,System.Double)">
            <summary>
            finds the bounding box of this bezier curve
            </summary>
            <param name="_bezierPoints">bezier curve points in orde</param>
            <param name="_tbegin">begin t point bezier curve</param>
            <param name="_tend">end t point bezier curve</param>
            <returns>bouding box</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.getFurthesAwayFromPoint(System.Double,System.Double,System.Double)">
            <summary>
            finds out which of 2 values is furthes away from given point
            </summary>
            <param name="_givenPoint">given point</param>
            <param name="_firstCompare">first compare value</param>
            <param name="_secondCompare">second compare value</param>
            <returns>which compare value is furthes away</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.findMaxMinValue(System.Collections.Generic.List{System.Double})">
            <summary>
            find minimum and maximum value of given list
            </summary>
            <param name="_toCheck">list</param>
            <returns>minimum maximum value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.checkBounds(u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect[])">
            <summary>
            checks if bounds are inside eachother (fully or partialy)
            </summary>
            <param name="_intersects">list of bounds to check</param>
            <returns>resulting bounds that have intersects</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.diffToZeroSecondOrde(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double,System.Double)">
            <summary>
            finds 3 orde bezier curve differential is zero points
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t values</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.findDSingle(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            finds D value for abc-formula
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_p3">fourth bezier point</param>
            <returns>D value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.diffToZeroFirstOrde(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double,System.Double)">
            <summary>
            finds 2 orde bezier curve differential is zero point
            </summary>
            <param name="_p0">first bezier point</param>
            <param name="_p1">second bezier point</param>
            <param name="_p2">third bezier point</param>
            <param name="_tbegin">t begin percentage</param>
            <param name="_tend">t end percentage</param>
            <returns>t value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.halfTheBounds(System.Collections.Generic.List{u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect})">
            <summary>
            cuts the bezier curve in half using De Casteljau's algorithm and gets the new bounding box data
            </summary>
            <param name="_intersectsToHalf">original curve to cut in half</param>
            <returns>result of cutting in half</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.processIntersectPoints(System.Collections.Generic.List{u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect},System.Double)">
            <summary>
            process the intersect points to average out the ones that are probally the same
            </summary>
            <param name="_intersects">unprocessed intersect points</param>
            <param name="_minimumDistanceValue">minimum distance between points to then average them out</param>
            <returns>processed intersect points</returns>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect.Bounds">
            <summary>
            bounds castlejau
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect.BezierPoints">
            <summary>
            bezier points
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect.Tbegin">
            <summary>
            percentage begin
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect.Tend">
            <summary>
            percentage end
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect.Tdifference">
            <summary>
            percentage difference
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect.Order">
            <summary>
            curve orde
            </summary>
        </member>
        <member name="F:u040.prespective.math.spline.doubles.DNURBSCurve3D.DataInterSect.CurveNumber">
            <summary>
            curve number
            </summary>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.#ctor(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            constructor
            </summary>
            <param name="_points">bezier points</param>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.bezierValueAt(System.Double,System.Double,System.Double)">
            <summary>
            gets the bezier point of curve for casteljau
            </summary>
            <param name="_t">t value bezier</param>
            <param name="_tbegin">t begin bezier</param>
            <param name="_tend">t end bezier</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.getB(System.Int32,System.Int32,System.Double)">
            <summary>
            gets the bernstein basis polynomial
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <param name="_t">t</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.binomialCoefficient(System.Int32,System.Int32)">
            <summary>
            gets a binomial coefficient (n over i)
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>binomial coefficient</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.factorial(System.Int32)">
            <summary>
            get factoral of n
            </summary>
            <param name="_n">n</param>
            <returns>factoral</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.bezierDifferentialValueAt(System.Double)">
            <summary>
            get differential of bezier curve at point (experimental should not use)
            </summary>
            <param name="_t">percentage</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.BezierCurveStruc3DNURBSCasteljau.getA(System.Int32,System.Int32)">
            <summary>
            special self made coefficient for differential
            </summary>
            <param name="_i">i</param>
            <param name="_n">n</param>
            <returns>value</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.GetPoint(System.Double,System.Boolean)">
            <summary>
            Returns a point on this NURBS Curve
            </summary>
            <param name="_curvePercentage">Returns a point on this curve in range [0,1]</param>
            <param name="_useAdaptiveRange">Whether or not we want to use the adaptive range maintained for easy traversion over a ring spline</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.GetSpanLimits(System.Int32)">
            <summary>
            Returns the Span Limits (which may be used to generate a Parametric (Basis) Curve for intersection calculation)
            </summary>
            <param name="_nSpan">the span # to get the limits for</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve3D.getKnotVectorNURBS(System.Int32,System.Int32)" -->
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.GetImplicitPoint(System.Double)">
            <summary>
            The implicit point on curve (The NURBS Book - Les Piegl, Wayne Tiller p.81)
            </summary>
            <param name="_percentageOnCurve">percentage on curve</param>
            <returns>implicit point</returns>
        </member>
        <member name="M:u040.prespective.math.spline.doubles.DNURBSCurve3D.NCalculation(System.Double,System.Int32,System.Double[])">
            <summary>
            Calculates the N values of NURBS curve depending (The NURBS Book - Les Piegl, Wayne Tiller p.50)
            </summary>
            <param name="_percentage">percentage on curve</param>
            <param name="_currentOrder">current order of previous results</param>
            <param name="_previousNResults">previous N values</param>
            <returns>N values</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve3D.GetNURBSCurvePoint(System.Int32,System.Double[],System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve3D.findBSplineSpan(System.Int32,System.Int32,System.Double,System.Double[])" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.spline.doubles.DNURBSCurve3D.NURBSFunction(System.Int32,System.Double,System.Int32,System.Double[])" -->
        <member name="T:u040.prespective.math.doubles.clipper.SuthHodgClipper">
            <summary>
            Sutherland-Hodgeman Clipping Algorithm for 2D Shapes - expects verts in clockwise order:
            implementation based on: https://www.geeksforgeeks.org/polygon-clipping-sutherland-hodgman-algorithm-please-change-bmp-images-jpeg-png/
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.clipper.SuthHodgClipper.SuthHodgClip(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2},System.Collections.Generic.List{u040.prespective.math.doubles.DVector2},System.Collections.Generic.List{UnityEngine.Vector2Int}@)">
            <summary>
            Clips shape1 and shape2 in accordance to the Sutherland-Hodgeman Clipping Algorithm for 2D shapes
            </summary>
            <param name="_shape1">Shape 1 hull described as DVector2 List</param>
            <param name="_shape2">Shape 2 hull described as DVector2 List</param>
            <param name="_addresses">Resulting polygon vertex origin addresses - X is # of shape [0 or 1], Y is # vert, X = -1 is inserted point</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.clipper.SuthHodgClipper.x_intersect(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns the X-value of the intersection point of 2 lines
            </summary>
            <param name="_a1">Start point of first line</param>
            <param name="_a2">End point of first line</param>
            <param name="_b1">Start point of second line</param>
            <param name="_b2">End point of second line</param>
            <returns>X-value of the intersection point </returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DVector2">
            <summary>
            Double implementation of the Unity3D Default float Vector2 struct
            
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.Zero">
            <summary>
            Shorthand for writing @@DVector2(0, 0)@@  (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.One">
            <summary>
            Shorthand for writing @@DVector2(1, 1)@@  (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.Up">
            <summary>
            Shorthand for writing @@DVector2(0, 1)@@  (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.Down">
            <summary>
            Shorthand for writing @@DVector2(0, -1)@@  (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.Left">
            <summary>
            Shorthand for writing @@DVector2(-1, 0)@@  (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.Right">
            <summary>
            Shorthand for writing @@DVector2(1, 0)@@  (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.PositiveInfinity">
            <summary>
            Shorthand for writing @@DVector2(double.PositiveInfinity, double.PositiveInfinity)@@  (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.NegativeInfinity">
            <summary>
            Shorthand for writing @@DVector2(double.NegativeInfinity, double.NegativeInfinity)@@  (style sheet exception)
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.#ctor(System.Double,System.Double)">
            <summary>
            Constructs a new vector with given x, y components
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.X">
            <summary>
            X component of the vector
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector2.Y">
            <summary>
            Y component of the vector
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector2.Item(System.Int32)">
            <summary>
            Access the /x/ or /y/ component using [0] or [1] respectively
            </summary>
            <param name="_index"></param>
            <returns></returns>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector2.Normalized">
            <summary>
            Returns this vector with a ::ref::magnitude of 1 (RO)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector2.Magnitude">
            <summary>
            Returns the length of this vector (RO)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector2.SqrMagnitude">
            <summary>
            Returns the squared length of this vector (RO)
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.ClipValueRange(u040.prespective.math.doubles.DVector2)">
            <summary>
            Clips the value range out of the range described as [X,Y]
            Since an inlaying value range can result in 2 segments a list is returned
            (Included as part of DES)
            </summary>
            <param name="_valueRangeToRemove">the value range [X,Y] to Clip out of this range [X,Y]</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.TrimValueRange(u040.prespective.math.doubles.DVector2)">
            <summary>
            Trims the value range [X,Y] from this value range
            (Included as part of DES)
            </summary>
            <param name="_other">the value range [X,Y] to Trim from this value range [X,Y]</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.ValueRangeOverlaps(u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Returns whether the value range _b [X,Y] overlaps with this value range [X,Y]
            (Included as part of DES)
            </summary>
            <param name="_b">the value range to test [X,Y]</param>
            <param name="_minimumMayBeEqual">whether an equal minimum value should be seen as overlapping</param>
            <param name="_maximumMayBeEqual">whether an equal maximum value should be seen as overlapping</param>
            <returns>whether an overlap is found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.valueRangeContains(u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Returns whether this value range [X,Y] is contained by _b [X,Y]
            (Included as part of DES)
            </summary>
            <param name="_b">the value range [X,Y] to test for overlap</param>
            <param name="_minimumMayBeEqual">whether an equal minimum value should be seen as content</param>
            <param name="_maximumMayBeEqual">whether an equal maximum value should be seen as content</param>
            <returns>whether this value is contained in _b</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.ValueRangeIntersects(u040.prespective.math.doubles.DVector2,System.Boolean,System.Boolean)">
            <summary>
            Returns whether the value range _b [X,Y] intersects with this value range [X,Y]
            (Included as part of DES)
            </summary>
            <param name="_b">the value range [X,Y] to test for intersection</param>
            <param name="_minimumMayBeEqual">whether an equal minimum value should be seen as intersecting</param>
            <param name="_maximumMayBeEqual">whether an equal maximum value should be seen as intersecting</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.ToFloat">
            <summary>
            makes float vector2 from double vector2
            </summary>
            <returns>float vector2</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Normalize">
            <summary>
            Makes this vector have a ::ref::magnitude of 1
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Set(System.Double,System.Double)">
            <summary>
            Set x and y components of an existing Vector2
            </summary>
            <param name="_newX"></param>
            <param name="_newY"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Scale(u040.prespective.math.doubles.DVector2)">
            <summary>
            Multiplies every component of this vector by the same component of /scale/
            </summary>
            <param name="_scale"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.GetHashCode">
            <summary>
            used to allow Vector2s to be used as keys in hash tables
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Equals(System.Object)">
            <summary>
            also required for being able to use Vector2s as keys in hash tables
            </summary>
            <param name="_other"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Equals(u040.prespective.math.doubles.DVector2)">
            <summary>
            checks if vector2 are equal
            </summary>
            <param name="_other"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Rotate(System.Double)">
            <summary>
            rotation 
            </summary>
            <param name="_cwRotationDeg"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.ToString">
            <summary>
            makes string of DVector2
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.IsNan">
            <summary>
            checks is DVector3 has NAN values
            </summary>
            <returns>has NAN value</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Lerp(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Linearly interpolates between two vectors
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_t"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.LerpUnclamped(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Linearly interpolates between two vectors without clamping the interpolate
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_t"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.MoveTowards(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Moves a point /current/ towards /target/
            </summary>
            <param name="_current"></param>
            <param name="_target"></param>
            <param name="_maxDistanceDelta"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Scale(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Multiplies two vectors component-wise
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Reflect(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            reflect direction to plane
            </summary>
            <param name="_inDirection">direction</param>
            <param name="_inNormal">plane normal</param>
            <returns>reflected direction</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Perpendicular(u040.prespective.math.doubles.DVector2)">
            <summary>
            creates perpendicular direction
            </summary>
            <param name="_inDirection"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Dot(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Dot Product of two vectors
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Angle(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns the angle in degrees between /from/ and /to/
            </summary>
            <param name="_from"></param>
            <param name="_to"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.SignedAngle(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns the signed angle in degrees between /from/ and /to/. Always returns the smallest possible angle
            </summary>
            <param name="_from"></param>
            <param name="_to"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.CCWAngle(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            counter clockwise angle between 2 vectors
            </summary>
            <param name="_d1">vector1</param>
            <param name="_d2">vector2</param>
            <returns>counter clockwise angle</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.CWAngle(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            clockwise angle between 2 vectors
            </summary>
            <param name="_d1">vector1</param>
            <param name="_d2">vector2</param>
            <returns>clockwise angle</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Distance(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns the distance between /a/ and /b/
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.ClampMagnitude(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Returns a copy of /vector/ with its magnitude clamped to /maxLength/
            </summary>
            <param name="_vector"></param>
            <param name="_maxLength"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Min(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns a vector that is made from the smallest components of two vectors
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Max(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns a vector that is made from the largest components of two vectors
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Project(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            project vector on other vector
            </summary>
            <param name="_vector"></param>
            <param name="_onNormal"></param>
            <returns>projected vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.Rotate(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Rotate a vector by a given amount of degrees
            </summary>
            <param name="_vector"></param>
            <param name="_degrees"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.VectorToParametricParameters(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Converts a linear 2D Vector to a Parametric Description y = aX + b -> (a, b)
            </summary>
            <param name="_pointOnLine"></param>
            <param name="_lineVector"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.PointOnLine(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            gets point on given line
            </summary>
            <param name="_start">start line</param>
            <param name="_end">end line</param>
            <param name="_xValue">x value of point</param>
            <returns>point</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Addition(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Adds two vectors
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Subtraction(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Subtracts one vector from another
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Multiply(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Multiplies one vector by another
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Division(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Divides one vector over another
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_UnaryNegation(u040.prespective.math.doubles.DVector2)">
            <summary>
            Negates a vector
            </summary>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Multiply(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Multiplies a vector by a number
            </summary>
            <param name="_a"></param>
            <param name="_d"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Multiply(System.Double,u040.prespective.math.doubles.DVector2)">
            <summary>
            Multiplies a vector by a number
            </summary>
            <param name="_d"></param>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Division(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
             Divides a vector by a number
            </summary>
            <param name="_a"></param>
            <param name="_d"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Equality(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns true if the vectors are equal
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Inequality(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Returns true if vectors are different
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector2.op_Implicit(u040.prespective.math.doubles.DVector3)~u040.prespective.math.doubles.DVector2">
            <summary>
            Converts a [[Vector3]] to a Vector2
            </summary>
            <param name="_v"></param>
        </member>
        <member name="T:u040.prespective.math.doubles.DUnitCircle">
             <summary>
             Class to store data about a circle
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DUnitCircle.FindCircle(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3@,System.Double@,u040.prespective.math.doubles.DPlane@)">
            <summary>
            Finds the circle of 3 points
            </summary>
            <param name="_vectorA">point 1</param>
            <param name="_vectorB">point 2</param>
            <param name="_vectorC">point 3</param>
            <param name="_center">Circle centre</param>
            <param name="_radius">Circle radius</param>
            <param name="_plane">Circle plane</param>
            <returns>A boolean indicating whether or not a circle has been found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DUnitCircle.GetPointOnUnitCircleClosestToWorldPoint(u040.prespective.math.doubles.DVector3,System.Double,u040.prespective.math.doubles.DPlane,u040.prespective.math.doubles.DVector3,System.Double@)">
            <summary>
            Get the point on a unit circle that is closest to an arbitrary point
            (Implemented as part of DES)
            </summary>
            <param name="_unitCircleCenter">The center point of the unit circle</param>
            <param name="_unitCircleRadius">The radius of the unit circle</param>
            <param name="_unitCirclePlane">The plane description of the unit circle</param>
            <param name="_soughtPoint">The point we want to get closest to</param>
            <param name="_signedCircleAngle">The angle this point was found at</param>
            <returns>The point on a unit circle that is closest to an arbitrary point</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DUnitCircle.GetPointOnUnitCircleBySignedAngle(u040.prespective.math.doubles.DVector3,System.Double,u040.prespective.math.doubles.DPlane,System.Double)">
            <summary>
            Get the point on the Unit circle you get ata given signed angle
            (Implemented as part of DES)
            </summary>
            <param name="_unitCircleCenter">The center point of the unit circle</param>
            <param name="_unitCircleRadius">The radius of the unit circle</param>
            <param name="_unitCirclePlane">The plane description of the unit circle</param>
            <param name="_signedAngle">The angle to use</param>
            <returns>A point on the unit circle at the given signed angle</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DUnitCircle.perpendicularBisector(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2@)">
            <summary>
            Get a perpendicular line to the input line that starts at the center of the input line
            </summary>
            <param name="_lineStart">Start of the input line</param>
            <param name="_lineEnd">End of the input line</param>
            <param name="_perpendicularOrigin">(out param) perpendicular line start</param>
            <param name="_perpendicularEnd">(out param) perpendicular line end</param>
        </member>
        <member name="T:u040.prespective.math.doubles.DPlane">
             <summary>
             Class to store data about a plane such as the rotatation, origin and normal direction. Also has functions for calculating intersections and projections of points and line onto the plane and translating from and to global space from the local space of the plane.
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPlane.rotation">
            <summary>
            Plane rotation
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPlane.Origin">
            <summary>
            Plane origin
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DPlane.Rotation">
            <summary>
            Plane rotation getter and setter
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DPlane.Normal">
            <summary>
            Plane normal getter
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.#ctor(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Constructor for creating a DPlane with three points in space
            </summary>
            <param name="_pointA">The first point to determine the origin and rotation o the DPlane</param>
            <param name="_pointB">The second point to determine the origin and rotation o the DPlane</param>
            <param name="_pointC">The third point to determine the origin and rotation o the DPlane</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.#ctor(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Constructor for creating a DPlane with a given origin and rotation
            </summary>
            <param name="_origin">Origin of the DPlane</param>
            <param name="_rotation">Rotation of the DPlane</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.LocalToGlobal(u040.prespective.math.doubles.DVector3)">
            <summary>
            Get a global point from a local point on the DPlane
            </summary>
            <param name="_localPosition">The point in the local space of the DPlane to convert to a point in global space</param>
            <returns>The converted point in global space from the given point in the local space of the DPlane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.LocalToGlobal(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Get a list of global points from a list of local points on the DPlane
            </summary>
            <param name="_localPositions">The list of points in the local space of the DPlane to convert to a list of points in global space</param>
            <returns>A list of converted points in global space from the given list of points in the local space of the DPlane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.GlobalToLocal(u040.prespective.math.doubles.DVector3)">
            <summary>
            Get a point in the local DPlane space from a point in global space
            </summary>
            <param name="_globalPosition">The point in global space to convert to a point in the local space of the DPlane</param>
            <returns>The converted point in the local space of the DPlane from the point in global space</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.GlobalToLocal(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Get a list of points in the local DPlane space from a list of points in global space
            </summary>
            <param name="_globalPositions">The list of points in global space to convert to a list of points in the local space of the DPlane</param>
            <returns>The converted list of points in the local space of the DPlane from the list of points in global space</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.GlobalToLocal(u040.prespective.math.doubles.DVector3[])">
            <summary>
            Get an array of points in the local DPlane space from an array of points in global space
            </summary>
            <param name="_globalPositions">The array of points in global space to convert to an array of points in the local space of the DPlane</param>
            <returns>The converted array of points in the local space of the DPlane from the array of points in global space</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.GlobalToLocalPlanarV2(u040.prespective.math.doubles.DVector3)">
            <summary>
            Get a point in the local DPlane space as a DVector2 (X and Z from 3D space) from a point in global space
            </summary>
            <param name="_globalPoint">The 3D point in global space to convert to a 2D point (X and Z from 3D space) in the local space of the DPlane</param>
            <returns>The converted 2D point (X and Z from 3D space) in the local space of the DPlane from the given 3D point in the global space</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.PlanarV2LocalToGlobal(u040.prespective.math.doubles.DVector2)">
            <summary>
            Get a 3D point in global space from a 2D local point (X and Z from 3D space) on the DPlane
            </summary>
            <param name="_planarPoint">The 2D point (X and Z from 3D space) in the local space of the DPlane to convert to a 3D point in global space</param>
            <returns>The converted 3D point in global space from the given 2D point (X and Z from 3D space) in the local space of the DPlane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.ProjectPointOntoPlane(u040.prespective.math.doubles.DVector3)">
            <summary>
            Project a point in global space on the DPlane
            </summary>
            <param name="_globalPosition">The point in global space to project on the DPlane</param>
            <returns>The projected point on the DPlane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.ProjectPointsOntoPlane(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Project a list of points in global space on the DPlane
            </summary>
            <param name="_globalPositions">The list of points in global space to project on the DPlane</param>
            <returns>A list of projected points on the DPlane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.ProjectLineOntoPlane(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3@)">
            <summary>
            Project a line in global space on the DPlane
            </summary>
            <param name="_lineStart">The starting point of the line</param>
            <param name="_lineDirection">The direction of the line</param>
            <param name="_projectedLineStart">(out param) The starting point of the projected line</param>
            <param name="_projectedLineDirection">(out param) The direction of the projected line</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.GetLinePlaneIntersection(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3@)">
            <summary>
            Get the intersection point between a line and the DPlane
            </summary>
            <param name="_lineStart">The start of the line that intersects with the plane</param>
            <param name="_lineDirection">The direction of the line</param>
            <param name="_intersectionPoint">(out param) The point on the DPlane where the line intersects with the DPlane</param>
            <returns>A boolean indicating whether or not the line intersects with the DPlane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.GetLinesPlaneIntersections(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3}@)">
            <summary>
            Get the intersections points between a list of lines and the DPlane
            </summary>
            <param name="_lineStarts">The starting points of the lines</param>
            <param name="_lineDirection">The direction of the lines</param>
            <param name="_intersectionPoints">(out param) The starting point of the projected lines</param>
            <returns>A boolean indicating whether or not all lines intersect with the DPlane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.GetReorderedCyclicHullIndices(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Get an array of indices indicating the proper order of a given list of vertex coordinates based on ordering
            the vertices into a cyclic hull on the DPLane
            </summary>
            <param name="_vertices">A list of vertices to get the reordered indices for</param>
            <returns>An array of indices indicating the proper order of a given list of vertex coordinates representing a
            cyclic hull on the DPLane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.MakeHullCyclicOverPlane(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Get an array of vertices by reordering a given list of vertices based on ordering the vertices into a cyclic
            hull on the plane of the DPLane
            </summary>
            <param name="_vertices">A list of vertices to reorder</param>
            <returns>A reordered array of vertices representing a cyclic hull on the DPLane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.getCyclicHullIndices(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Get an array of indices indicating the proper order of a given list of vertex coordinates based on ordering
            the vertices into a cyclic hull on the DPLane
            </summary>
            <param name="_vertices">A list of vertices to get the reordered indices for</param>
            <returns>An array of indices indicating the proper order of a given list of vertex coordinates representing a
            cyclic hull on the DPLane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.ConvexHullLiuAndChen(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Makes Convex hull using Liu and Chen method
            </summary>
            <param name="_pointsIn">Point to make convex hull off (will be projected on plane)</param>
            <returns>Convex hull</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPlane.ConvexHullLiuAndChen(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DVector3)">
            <summary>
            Makes Convex hull using Liu and Chen method
            </summary>
            <param name="_pointsIn">Point to make convex hull off (will be projected on plane)</param>
            <param name="_projectionDirection">direction to direct the points onto plane</param>
            <returns>Convex hull</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DTessellation">
             <summary>
             Get the triangle indices of a given list of vertices on a plane
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DTessellation.TessellatePlanar(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Int32)">
            <summary>
            Gets the triangle indices of a tessellated plane form its ordered outer vertices
            </summary>
            <param name="_outlinePoints">Outer vertices of plane in order</param>
            <param name="_maxPasses">Maximum amount of passes</param>
            <returns>A list of triangle indices</returns>
            ToDo: Vertex optimization for duplicate vertices has not yet been implemented
        </member>
        <member name="M:u040.prespective.math.doubles.DTessellation.earClippingSolver(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Collections.Generic.List{System.Int32}},System.Int32)">
            <summary>
            Gets the triangle indices of a tessellated plane form its ordered outer vertices
            </summary>
            <param name="_outlinePoints">Outer vertices of plane in order</param>
            <param name="_remainingVertices">The remaining vertices to check</param>
            <param name="_results">The resulting triangle vertex indices</param>
            <param name="_passesLeft">The maximum amount of passes before returning the list of triangle indices (default = 20)</param>
            <returns>The resulting triangle vertex indices</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DTessellation.isProperPolygonEar(System.Int32,System.Int32,System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Checks whether or not a given triangle is a proper polygon ear
            </summary>
            <param name="_index">Polygon vertex start index</param>
            <param name="_nextNextIndex">Polygon vertex end index</param>
            <param name="_remainingVertices">The remaining vertices to check</param>
            <param name="_outlinePoints">Outer vertices of plane in order</param>
            <returns>A boolean indicating whether or not a given triangle is a proper polygon ear</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DMatrix4x4">
            <summary>
            @STRUCT : DMatrix4x4
            
            @ABOUT : Double implementation of the Unity3D Default float Matrix4x4 struct
            
                     Note that the sourcecode (that was used for implementation) for the unity float class can be found in the GIT:
                     https://github.com/Unity-Technologies/UnityCsReference
            
            @AUTHOR: Tymen (Unit040)
            
            @VERSION:V1.00 - 27/11/2018 - Implemented base
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DMatrix4x4.Zero">
            <summary>
            Returns a matrix with all elements set to zero (RO)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DMatrix4x4.Identity">
            <summary>
            Returns the identity matrix (RO)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M00">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M10">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M20">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M30">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M01">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M11">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M21">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M31">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M02">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M12">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M22">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M32">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M03">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M13">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M23">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DMatrix4x4.M33">
            <summary>
            Matrix value where the first number is the row and second number is the column
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DMatrix4x4.Item(System.Int32,System.Int32)">
            <summary>
            Access element at [_row, _column]
            </summary>
            <param name="_row">The row of the element</param>
            <param name="_column">The column of the element</param>
            <returns>The element at [_row, _column]</returns>
        </member>
        <member name="P:u040.prespective.math.doubles.DMatrix4x4.Item(System.Int32)">
            <summary>
            Access element at sequential index (0..15 inclusive) where the index goes through rows before going through columns
            </summary>
            <param name="_index">The index for the element</param>
            <returns>The element at the index</returns>
        </member>
        <member name="P:u040.prespective.math.doubles.DMatrix4x4.Inverse">
            <summary>
            Get the inverse of this matrix
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.#ctor(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Constructor for DMatrix4x4
            </summary>
            <param name="_column0">First column</param>
            <param name="_column1">Second column</param>
            <param name="_column2">Third column</param>
            <param name="_column3">Fourth column</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.ToFloat">
            <summary>
            Get a copy of this DMatrix4x4 of type Matrix4x4
            </summary>
            <returns>A copy of this DMatrix4x4 of type Matrix4x4</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.GetHashCode">
            <summary>
            Get a hash code based on this the columns from this DMatrix4x4
            </summary>
            <returns>A hash code based on this the columns from this DMatrix4x4</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.Equals(System.Object)">
            <summary>
            Check if another object is of type DMatrix4x4 and equal to this DMatrix4x4
            </summary>
            <param name="_other">The other object to compare this DMatrix4x4 to</param>
            <returns>A boolean indicating whether or not another object is of type DMatrix4x4 and equal to this DMatrix4x4</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.Equals(u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            Check if this DMatrix4x4 is equal to another DMatrix4x4
            </summary>
            <param name="_other">The other Matrix4x4 to compare this Matrix4x4 to</param>
            <returns>A boolean indicating whether or not this DMatrix4x4 is equal the other DMatrix4x4</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.GetColumn(System.Int32)">
            <summary>
            Get a column of the matrix with a given index
            </summary>
            <param name="_index">The index of the column to get</param>
            <returns>A DVector4 containing the values of the column</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.GetRow(System.Int32)">
            <summary>
            Get a row of the matrix with a given index
            </summary>
            <param name="_index">The index of the row to get</param>
            <returns>A DVector4 containing the values of the row</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.SetColumn(System.Int32,u040.prespective.math.doubles.DVector4)">
            <summary>
            Sets a column of the matrix with a given index
            </summary>
            <param name="_index">The index of the column to set</param>
            <param name="_column">The values of the column to set</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.SetRow(System.Int32,u040.prespective.math.doubles.DVector4)">
            <summary>
            Sets a row of the matrix with a given index
            </summary>
            <param name="_index">The index of the row to set</param>
            <param name="_row">The values of the row to set</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.MultiplyPoint(u040.prespective.math.doubles.DVector3)">
            <summary>
            Transforms a position by this matrix with a perspective divide (generic)
            </summary>
            <param name="_point">The point to transform</param>
            <returns>A transformed point with a perspective divide</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.MultiplyPoint3x4(u040.prespective.math.doubles.DVector3)">
            <summary>
            Transforms a point by this matrix without a perspective divide (fast)
            </summary>
            <param name="_point">The point to transform</param>
            <returns>A transformed point without a perspective divide</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.MultiplyVector(u040.prespective.math.doubles.DVector3)">
            <summary>
            Transforms a vector by this matrix
            </summary>
            <param name="_vector">The vector to transform</param>
            <returns>The transformed vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.ToString">
            <summary>
            Get a string representation of this matrix where each number has five decimals, each row is spaced with an enter, and each row is spaced with a tab
            </summary>
            <returns>A string representation of this matrix where each number has five decimals, each row is spaced with an enter, and each row is spaced with a tab</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.ToString(System.Globalization.CultureInfo,System.String)">
            <summary>
            Get a string representation of this matrix with a given format
            </summary>
            <param name="_culture">The culture for this ToString function</param>
            <param name="_format">The format for this ToString function</param>
            <returns>A string representation of this matrix with a given format</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.Scale(u040.prespective.math.doubles.DVector3)">
            <summary>
            Creates a scaling matrix 
            </summary>
            <param name="_scale">The scale of the new scaling matrix</param>
            <returns>A new scaling matrix </returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.Translate(u040.prespective.math.doubles.DVector3)">
            <summary>
            Creates a translation matrix
            </summary>
            <param name="_translate">The translation of the new translation matrix</param>
            <returns>A new translation matrix</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.Rotate(u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Creates a rotation matrix. Note: Uses DVector3.One as the scale vector
            </summary>
            <param name="_quaternion">The quaternion for the rotation matrix</param>
            <returns>A rotation matrix based on the given quaternion and a DVector3.One scale vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.Rotate(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3)">
            <summary>
             Creates a rotation matrix. Note: Assumes unit quaternion
            </summary>
            <param name="_quaternion">The quaternion for the rotation matrix</param>
            <param name="_scale">The scale vector fot the rotation matrix</param>
            <returns>A rotation matrix based on the given quaternion and scale vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.op_Multiply(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            Multiplies two matrices of type DMatrix4x4
            </summary>
            <param name="_left">The DMatrix4x4 left of the * operator</param>
            <param name="_right">The DMatrix4x4 left of the * operator</param>
            <returns>A new DMatrix4x4 that is equal to the the left and right DMatrix4x4 being multiplied with each other</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.op_Multiply(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Transforms a DVector4 by a DMatrix4x4
            </summary>
            <param name="_left">The FMatrix4x4, left of the * operator, to transform the DVector4 with</param>
            <param name="_vector">The DVector4, right of the * operator, to transform</param>
            <returns>The transformed DVector4</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.op_Equality(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            == operator for DMatrix4x4 (will always return false in the presence of NaN values)
            </summary>
            <param name="_left">The DMatrix4x4 on the left side of the == operator</param>
            <param name="_right">The DMatrix4x4 on the right side of the == operator</param>
            <returns>A boolean indicating whether or not the DMatrix4x4 are equal (equal = true, NOT equal = false, any NaN value = false)</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DMatrix4x4.op_Inequality(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            != operator for DMatrix4x4 (will always return true in the presence of NaN values)
            </summary>
            <param name="_left">The DMatrix4x4 on the left side of the == operator</param>
            <param name="_right">The DMatrix4x4 on the left side of the == operator</param>
            <returns>A boolean indicating whether or not the DMatrix4x4 are NOT equal (equal = false, NOT equal = true, any NaN value = true)</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DVector3">
            <summary>
            Double implementation of the Unity3D Default float Vector3 struct
            
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Back">
            <summary>
            Shorthand for writing DVector3(0, 0, -1) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Down">
            <summary>
            Shorthand for writing DVector3(0, -1, 0) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Forward">
            <summary>
            Shorthand for writing DVector3(0, 0, 1) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Left">
            <summary>
            Shorthand for writing DVector3(-1, 0, 0) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.NegativeInfinity">
            <summary>
            Shorthand for writing DVector3(double.NegativeInfinity, double.NegativeInfinity, double.NegativeInfinity) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.One">
            <summary>
            Shorthand for writing DVector3(1, 1, 1) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.PositiveInfinity">
            <summary>
            Shorthand for writing DVector3(double.PositiveInfinity, double.PositiveInfinity, double.PositiveInfinity) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Right">
            <summary>
            Shorthand for writing DVector3(1, 0, 0) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Up">
            <summary>
            Shorthand for writing DVector3(0, 1, 0) (style sheet exception).
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Zero">
            <summary>
            Shorthand for writing DVector3(0, 0, 0) (style sheet exception).
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector with given x, y, z components.
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <param name="_z"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new vector with given x, ycomponents and sets z as 0.
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.#ctor(UnityEngine.Vector3)">
            <summary>
            creats double vector3 from float vector3
            </summary>
            <param name="_input">float vector3</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.#ctor(UnityEngine.Vector2)">
            <summary>
            creats double vector3 from float vector2
            </summary>
            <param name="_input">float vector2</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.#ctor(u040.prespective.math.doubles.DVector2)">
            <summary>
            creats double vector3 from double vector2
            </summary>
            <param name="_input">double vector2</param>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector3.Magnitude">
            <summary>
            Returns the length of this vector (Read Only).
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector3.Normalized">
            <summary>
            Returns this vector with a magnitude of 1 (Read Only).
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector3.SqrMagnitude">
            <summary>
            Returns the squared length of this vector (Read Only).
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector3.Item(System.Int32)">
            <summary>
            Access the x, y, z components using [0], [1], [2] respectively.
            </summary>
            <param name="_i"></param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.X">
            <summary>
            X component of the vector.
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Y">
            <summary>
            Y component of the vector.
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector3.Z">
            <summary>
            Z component of the vector.
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.ToFloat">
            <summary>
            makes float vector3 from double vector3
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Normalize">
            <summary>
            normalizes value
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.GetHashCode">
            <summary>
            get hash code
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Set(System.Double,System.Double,System.Double)">
            <summary>
            Set x, y and z components of an existing Vector3.
            </summary>
            <param name="_newX"></param>
            <param name="_newY"></param>
            <param name="_newZ"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.ToString">
            <summary>
            Returns a nicely formatted string for this vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Equals(u040.prespective.math.doubles.DVector3)">
            <summary>
            check if equal to given vector
            </summary>
            <param name="_other"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Equals(System.Object)">
            <summary>
            Returns true if the given vector is exactly equal to this vector.
            </summary>
            <param name="_obj"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.IsNan">
            <summary>
            checks is DVector3 has NAN values
            </summary>
            <returns>has NAN value</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.PlanarNormal(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            planar normal between 3 points
            </summary>
            <param name="_a">point 1</param>
            <param name="_b">point 2</param>
            <param name="_c">point 3</param>
            <returns>planar normal</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.PlanarNormal(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Get planar normal using points furthest apart; or rather using the biggest triangle
            </summary>
            <param name="_pts"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Centroid(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            centre of given points
            </summary>
            <param name="_pts">points</param>
            <returns>centre</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.biggestTri(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},System.Int32[]@,System.Double@)">
            <summary>
            finds biggest triangle
            </summary>
            <param name="_pts">points</param>
            <param name="_tri">triangles</param>
            <param name="_maxSurf">biggest surface</param>
            <returns>if found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Angle(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            angle between 2 vectors
            </summary>
            <param name="_from"></param>
            <param name="_to"></param>
            <returns>angle</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.SignedAngle(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            signed angle between 2 vectors
            </summary>
            <param name="_from"></param>
            <param name="_to"></param>
            <param name="_axis">signed axis</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.ClampMagnitude(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            clamp magnitude
            </summary>
            <param name="_vector">vector</param>
            <param name="_maxLength">maximum magnitude</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Cross(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            cross product
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Dot(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Returns the dot product of the left-hand and right-hand vector
            
            Tested and works 21/10/2018
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Distance(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            distance between vectors
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Lerp(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            lerp between 2 vectors
            </summary>
            <param name="_a">vector 1</param>
            <param name="_b">vector 2</param>
            <param name="_t">lerp vactor</param>
            <returns>lerped vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.LerpUnclamped(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            lerp between 2 vectors unclamped lerp factor
            </summary>
            <param name="_a">vector 1</param>
            <param name="_b">vector 2</param>
            <param name="_t">lerp factor</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Max(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            maximum value of vector
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Min(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            minimum value of vector
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.MoveTowards(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            moves current vector to target vector
            </summary>
            <param name="_current">current vector</param>
            <param name="_target">target vector</param>
            <param name="_maxDistanceDelta">maximum distance allowed to move</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Normalize(u040.prespective.math.doubles.DVector3)">
            <summary>
            normalized vector
            </summary>
            <param name="_value"></param>
            <returns>normalized vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Project(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            project vector on other vector
            </summary>
            <param name="_vector"></param>
            <param name="_onNormal"></param>
            <returns>projected vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.ProjectOnPlane(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            project the vector on plane
            </summary>
            <param name="_vector">vector</param>
            <param name="_planeNormal">plane normal</param>
            <returns>vector projected on plane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Reflect(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            reflect direction from plane
            </summary>
            <param name="_inDirection">direction</param>
            <param name="_inNormal">plane normal</param>
            <returns>reflected direction</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Scale(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            multiply 2 vector parameter per parameter
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.Divide(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            divide 2 vector parameter per parameter
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Subtraction(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            subtract vectors per parameter
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_UnaryNegation(u040.prespective.math.doubles.DVector3)">
            <summary>
            inverts a vector
            </summary>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Addition(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            add vectors per parameter
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Multiply(System.Double,u040.prespective.math.doubles.DVector3)">
            <summary>
            multiply vectors per parameter with constant value
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Multiply(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            multiply vectors per parameter with constant value
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Multiply(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3)">
            <summary>
            rotated the vector
            </summary>
            <param name="_a">rotation</param>
            <param name="_b">vector</param>
            <returns>rotated vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Division(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            divide vectors per parameter with constant value
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Equality(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            check if vectors are equal
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Inequality(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            check if vectors are not equal
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector3.op_Implicit(u040.prespective.math.doubles.DVector2)~u040.prespective.math.doubles.DVector3">
            <summary>
            Converts a Vector2 to a [[Vector3]]
            </summary>
            <param name="_v"></param>
        </member>
        <member name="T:u040.prespective.math.doubles.DBounds3D">
            <summary>
            Double implementation of the Unity3D Default float bounds struct for 3D
            
            Note that the source code (that was used for implementation) for the unity float class can be found in the GIT:
            https://github.com/Unity-Technologies/UnityCsReference
            
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DBounds3D.Center">
            <summary>
            The center of the bounding box
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds3D.Size">
            <summary>
            The total size of the range of the bounds
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DBounds3D.extents">
            <summary>
            The size of the range from the center to the edge of the bounds (always half the Size property)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds3D.Extents">
            <summary>
            The size of the range from the center to the edge of the bounds (always half the Size property)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds3D.Min">
            <summary>
            The minimal point of the box. This is always equal to "Center property - Extents property"
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds3D.Max">
            <summary>
            The maximal point of the box. This is always equal to "Center property + Extents property"
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.#ctor(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Creates new Bounds with a given center and total size. Bound extents will be half the given size
            </summary>
            <param name="_center">The center point of the bounds</param>
            <param name="_size">The total size of the bounds (2x the extents measured from the center)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.ToFloat">
            <summary>
            Get a copy of this DBounds3D of type Bounds which uses floats instead of doubles
            </summary>
            <returns>A copy of this bounds of type Bounds that uses floats instead of doubles</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.GetHashCode">
            <summary>
            Get a hash code based on the Center and Extents properties of this bounds to be used as keys in hash tables
            </summary>
            <returns>The hash code based on this bounds Center and Extents properties</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Equals(System.Object)">
            <summary>
            Check if the other object is of type DBounds3D and equal to another DBounds3D
            </summary>
            <param name="_other">The other object to compare this DBounds3D to</param>
            <returns>A boolean indicating whether or not this DBounds3D is equal to the other object</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Equals(u040.prespective.math.doubles.DBounds3D)">
            <summary>
            Check if this DBounds3D is equal to another DBounds3D
            </summary>
            <param name="_other">The other DBounds3D to compare this DBounds3D to</param>
            <returns>A boolean indicating whether or not this DBounds3D is equal to the other DBounds3D</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.SetMinMax(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Set this bounds values with two DVector3 describing the new min and max values for this bounds
            </summary>
            <param name="_min">The new min values for this bounds</param>
            <param name="_max">The new max values for this bounds</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Encapsulate(u040.prespective.math.doubles.DVector3)">
            <summary>
            Grows this Bounds3D to include a point
            </summary>
            <param name="_pointToEncapsulate">The point to encapsulate</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Encapsulate(u040.prespective.math.doubles.DBounds3D)">
            <summary>
            Grows this DBounds3D to include another DBounds3D
            </summary>
            <param name="_boundsToEncapsulate">The other DBounds3D to encapsulate</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Expand(System.Double)">
            <summary>
            Expand the bounds by adding the same size to both the X, Y and Z values of the Size property
            </summary>
            <param name="_sizeToAdd">The size to add to the value of the Size property (Note: Adds _sizeToAdd * 0.5 to BOTH sides of the center)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Expand(u040.prespective.math.doubles.DVector3)">
            <summary>
            Expand the bounds by adding size to the X, Y and Z values of the Size property
            </summary>
            <param name="_sizeToAdd">The sizes to add for The X, Y and Z values of the Size property (Note: Adds _sizeToAdd * 0.5 to BOTH sides of the center)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Intersects(u040.prespective.math.doubles.DBounds3D)">
            <summary>
            Check if another DBounds3D intersects with this DBounds3D
            </summary>
            <param name="_boundsToCheckIntersectionWith">The other DBounds3D to check for intersection with this DBounds3D</param>
            <returns>A boolean indicating whether or not this DBounds3D intersects with the other DBounds3D</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.Contains(u040.prespective.math.doubles.DVector3)">
            <summary>
            Check if a given point is contained within this DBounds3D
            </summary>
            <param name="_pointToCheckContainmentFor">The point to check containment within this DBounds3D for</param>
            <returns>A boolean indicating whether or not the given point is contained within this DBounds3D</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.ToString">
            <summary>
            ToString function for DBounds3D
            </summary>
            <returns>A string with the Center and Extents properties</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.op_Equality(u040.prespective.math.doubles.DBounds3D,u040.prespective.math.doubles.DBounds3D)">
            <summary>
            == operator for DBounds3D that checks if the Center and Extents properties are equal for both DBounds3D
            </summary>
            <param name="_valueLeftOfOperator">The DBounds3D left of the == operator</param>
            <param name="_valueRightOfOperator">The DBounds3D right of the == operator</param>
            <returns>A boolean indicating whether or not the Bounds3D objects on both side of the == operator have equal Center and Extents properties (Note: Returns false in the presence of NaN values)</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds3D.op_Inequality(u040.prespective.math.doubles.DBounds3D,u040.prespective.math.doubles.DBounds3D)">
            <summary>
            != operator for DBounds3D that checks if the Center and Extents properties are NOT equal for both DBounds3D
            </summary>
            <param name="_valueLeftOfOperator">The DBounds3D left of the != operator</param>
            <param name="_valueRightOfOperator">The DBounds3D right of the != operator</param>
            <returns>A boolean indicating whether or not the DBounds3D objects on both side of the != operator do NOT have equal Center and Extents properties (Note: Returns true in the presence of NaN values)</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.SeededDoubleRandom">
             <summary>
              Manager Class for controlled generation of seeded Double Random values
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.SeededDoubleRandom.ActiveDoubleRandoms">
            <summary>
            Reference to previously generated Double Randoms with a seed
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.SeededDoubleRandom.Seed">
            <summary>
            The seed used to generate the Random
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.SeededDoubleRandom.UseCount">
            <summary>
            The number of times it has been used 
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.SeededDoubleRandom.Instance">
            <summary>
            The Random running the seed
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.SeededDoubleRandom.#ctor(System.Int32)">
            <summary>
            Constructor with seed
            </summary>
            <param name="_seed">The seed to use for the SeededDoubleRandom</param>
        </member>
        <member name="M:u040.prespective.math.doubles.SeededDoubleRandom.GetSeededDoubleRandom(System.Int32)">
            <summary>
            Get an instance of a SeededDoubleRandom with a seed while ensuring there is only one unique SeededDoubleRandom instance for each seed.
            </summary>
            <param name="_seed">The seed used for generating random numbers</param>
            <returns></returns>
            Keeping SeededDoubleRandoms in memory like this probably won't go wrong if you use it responsibly, but it
            would be better to keep them in memory where you're using them.
        </member>
        <member name="M:u040.prespective.math.doubles.SeededDoubleRandom.GenerateRandomValue">
            <summary>
            Generate the next random value in this seed
            </summary>
            <returns>A random double</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DCube">
            <summary>
            cube data
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DCube.Centre">
            <summary>
            centre of cube in global space
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DCube.LocalCentre">
            <summary>
            local centre of cube
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DCube.Size">
            <summary>
            size of cube
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DCube.ConnnectedTransform">
            <summary>
            mesh collider connected to cube size
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DCube.Rotation">
            <summary>
            rotation of cube
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DCube.LocalToGlobal">
            <summary>
            local to global matrix
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DCube.Extend">
            <summary>
            extend cube
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DCube.#ctor(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,UnityEngine.Transform,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            constructor
            </summary>
            <param name="_centre">global space centre</param>
            <param name="_locCentre">local space centre</param>
            <param name="_size">size</param>
            <param name="_t">connected transform</param>
            <param name="_rot">rotation</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DCube.InsideCube(u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            checks if point is inside the cube
            </summary>
            <param name="_globalPoint">point in global space</param>
            <param name="_margin">margin</param>
            <returns>if point inside the cube</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DCube.GetLocalPoint(u040.prespective.math.doubles.DVector3)">
            <summary>
            get local point in cube space
            </summary>
            <param name="_globalPoint">global point</param>
            <returns>local point</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DCube.GetPointOnEgdeCube(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            get local point on edge of cube
            </summary>
            <param name="_beginLocalInsideCube">local point inside cube</param>
            <param name="_endLocalOutSideCube">local point outside cube</param>
            <param name="_margin">margin</param>
            <returns>local point on edge</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DCube.ToString">
            <summary>
            to string
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.convexhull.LiuAndChenConvexHull">
            <summary>
            Original first implementation of Ouellet (Liu and Chen) algorithm
            implemented based on: https://www.codeproject.com/Articles/1210225/Fast-and-improved-D-Convex-Hull-algorithm-and-its
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:u040.prespective.math.doubles.DPolygon2D" -->
        <member name="T:u040.prespective.math.doubles.DPolygon2D.ClippingTypes">
            <summary>
            types of clipping need to do
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPolygon2D.vertices">
            <summary>
            The vertices that make up this Polygon
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPolygon2D.centroid">
            <summary>
            Centroid of this 2D Polygon (calculated on construction)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DPolygon2D.ProjectionPlane">
            <summary>
            The Plane (if any) the vertices were projected onto
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DPolygon2D.Vertices">
            <summary>
            The getter and setter for the vertices
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DPolygon2D.Centroid">
            <summary>
            The getter and setter for the centroid
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DPolygon2D.FursthestVertexDistance">
            <summary>
            Distance of the Furthest vertex (calculated on construction) which is useful for calculating max reach
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2},u040.prespective.math.doubles.DPlane,System.Boolean,System.Double)">
            <summary>
            Constructor for a DPolygon2D with a list parameter for the vertices
            </summary>
            <param name="_vertices">The vertices making up the (cyclic) polygon</param>
            <param name="_projectionPlane">The plane this 2D polygon exists on</param> 
            <param name="_optimize">Whether or not vertex points should be removed if they do not result in no added surface area for the polygon (default = false)</param>
            <param name="_surfaceMargin">Precision for the optimization calculations (default = 1E-20d)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.#ctor(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DPlane,System.Boolean,System.Double)">
            <summary>
            Constructor for a DPolygon2D with an array parameter for the vertices
            </summary>
            <param name="_vertices">The vertices making up the (cyclic) polygon</param>
            <param name="_projectionPlane">The plane this 2D polygon exists on</param>
            <param name="_optimize">Whether or not vertex points should be removed if they do not result in no added surface area for the polygon (default = false)</param>
            <param name="_surfaceMargin">Precision for the optimization calculations (default = 1E-20d)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.getFurthestVertexFromOriginIndex(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[])">
            <summary>
            Get the index of the vertex furthest from the centroid
            </summary>
            <param name="_origin">The centroid</param>
            <param name="_vertices">The array of vertices to get the index from</param>
            <returns>The index of the vertex furthest from the centroid</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.calculateCentroid(u040.prespective.math.doubles.DVector2[])">
            <summary>
            Calculates the centroid of a given set of vertices
            </summary>
            <param name="_vertices">The set of vertices to calculate the centroid with</param>
            <returns>The centroid of a given set of vertices</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetGrownPolygon(System.Double)">
            <summary>
            Grows or shrinks a copy of this polygon by a given radius
            </summary>
            <param name="_growthRadius">The radius to grow or shrink with</param>
            <returns>A grown or shrunken copy of this polygon based on the given radius</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.EnlargePolygon(System.Double)">
            <summary>
            Enlarges a copy of this polygon by a given margin
            </summary>
            <param name="_enlargingFactor">The margin to enlarge with</param>
            <returns>An enlarged copy of this polygon based on the given margin</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetCycledPolygon(System.Int32)">
            <summary>
            Get a copy of this polygon with cycled vertices by a given amount
            </summary>
            <param name="_numberOfCycles">The amount of times the vertices should be cycled</param>
            <returns>A copy of this polygon with cycled vertices by a given amount</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetSurfaceArea">
            <summary>
            Get the surface area of the Polygon
            </summary>
            <returns>The surface area of this polygon in the form of a double that needs to be interpreted as value of the double squared</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetLinePolygonIntersection(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2@,System.Int32,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2},System.Double)">
            <summary>
            Get the point on the polygon where the line segment _lineSegmentStart to _lineSegmentEnd intersects
            </summary>
            <param name="_lineSegmentStart">The starting point of the line segment</param>
            <param name="_lineSegmentEnd">The end point of the line segment</param>
            <param name="_intersectionPoint">(out param) The resulting intersection point</param>
            <param name="_intersectionInfo">(out param) Additional info on the intersection point (x = line segment index, y = share on the line segment)</param>
            <param name="_indexStart">Segment to start from</param>
            <param name="_intersectionsToIgnore">Intersection points to ignore</param>
            <returns>A boolean indicating whether or not an intersection point between the line and the polygon has been found</returns>
            ToDo: Edge case that is currently unhandled:
            IF you put a line directly over the edge of a polygon
            AND add both vertex locations of that edge to the ignore list for intersection points
            THEN the function will not find an intersection point on the remainder of the edge that has not been ignored as potential intersection points
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.ExceedsBounds(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Boolean)">
            <summary>
            Determines whether this polygon exceeds the bounds specified by _min and _max
            </summary>
            <param name="_min">The minimum coordinates of the bounds</param>
            <param name="_max">The maximum coordinates of the bounds</param>
            <param name="_margin">Margin for checking the boundaries</param>
            <param name="_debug">Whether or not this function should print debug information (default = false)</param>
            <returns>A bool indicating whether or not this polygon exceeds the given bounds</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetBounds(u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2@)">
            <summary>
            Get the bounds of this polygon
            </summary>
            <param name="_min">(out param) The minimum bounds of this polygon</param>
            <param name="_max">(out param) The maximum bounds of this polygon</param>
            <returns>Returns false if there are no vertices and therefore no bounds can be found, otherwise returns true</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetWorldProjection">
            <summary>
            Returns the coordinates of this polygon in world space (via the owner plane transformation)
            </summary>
            <returns>The coordinates of this polygon in world space</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.ProjectFromPlaneOntoPlane(u040.prespective.math.doubles.DPlane,u040.prespective.math.doubles.DPlane,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DPolygon2D@)">
            <summary>
            Projects the vertices of this polygon from plane _from to plane _to in direction _worldProjectionVector to create a new polygon _result
            NOTE: This function will return false if any of the vertices cannot be projected on the opposing plane, this should only occur if the reception
            plane is positioned perpendicular to the sender plane
            </summary>
            <param name="_from">The plane the vertices will be projected from</param>
            <param name="_to">The plane the vertices will be projected onto</param>
            <param name="_worldProjectionVector">The projection direction</param>
            <param name="_result">(out param) The result polygon in 2D local space of on the to plane</param>
            <returns>Whether projection was successful, should only fail if the _worldProjectionVector is perpendicular to the normal of the _from plane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.Transform(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Get a transformed copy of this polygon around the point _origin with clockwise rotation _cwRotationDeg in degrees and offset _translation
            </summary>
            <param name="_origin">The origin around which to rotate</param>
            <param name="_translation">The translation to perform</param>
            <param name="_counterClockwiseRotationInDegrees">The number of degrees to rotate this polygon counter clockwise</param>
            <returns>A transformed copy of this polygon</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.AlignOtherPolygon(u040.prespective.math.doubles.DPolygon2D,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DPolygon2D@,u040.prespective.math.doubles.DPolygon2D@)">
            <summary>
            aligns this polygon to other polygon
            </summary>
            <param name="_otherPolygonIn">other polygon</param>
            <param name="_focusPoint">focus point</param>
            <param name="_otherPolygonOut">resulting aligned other polygon</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.findClosedNotCutEdgeToFocusPoint(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector2},u040.prespective.math.doubles.DVector2)">
            <summary>
            find closed not cut edge to focus point
            </summary>
            <param name="_vert">vertices in order</param>
            <param name="_focusPoint">focus point</param>
            <returns>closed edge</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.optimizeVertices(u040.prespective.math.doubles.DVector2[],System.Double)">
            <summary>
            Optimizes the Polygon by removing vertices at [n] that are collinear with segment [n-1, n+1] 
            and removing vertices that create a 0-surface triangle (loose polygonal ears)
            *Tested in PolygonOptimalizationTest
            </summary>
            <param name="_vertices">the input vertices</param>
            <param name="_distanceMargin">margin to check in for distance</param>
            <param name="_surfaceMargin">margin to check in for surface</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetMaxVectorToOtherPolygonInDirection(System.Boolean,System.Boolean,System.Boolean,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DPolygon2D,System.Double@,u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2@,System.Double,System.Boolean,System.String,System.String)">
            <summary>
            gets vector to other polygon in direction
            </summary>
            <param name="_useNegForIntrusion">use negative values for intrusion</param>
            <param name="_getFurthest">get furthest distance</param>
            <param name="_allowBidirectional">allow bidirectional distance check</param>
            <param name="_direction">direction to check in</param>
            <param name="_otherPolygon">other polygon to find distance to</param>
            <param name="_vectorLength">found vector length</param>
            <param name="_ownHullPoint">hull point self</param>
            <param name="_otherHullPoint">hull point other polygon</param>
            <param name="_dotMargin">margin of dot product direction check</param>
            <param name="_debug">if show debug logs</param>
            <param name="_debugS1Name">debug name used for self</param>
            <param name="_debugS2Name">debug name used for other</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.getEdgesComparedToDirection(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2@,System.Double)">
            <summary>
            gets edges of poly compared to direction
            </summary>
            <param name="_direction">direction</param>
            <param name="_centre">centre to rotated around</param>
            <param name="_xRange">found x range polygon</param>
            <param name="_yRange">found y range polygon</param>
            <param name="_optimizePoly">if should optimize polygon vertices</param>
            <param name="_margin">margin to check in</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.GetClosestPointOnHull(u040.prespective.math.doubles.DVector2,System.Double@)">
            <summary>
            Returns the closes point on this polygon hull
            </summary>
            <param name="_point">the point to check for</param>
            <param name="_minDist">the minimum distance</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.HasVerticesWithinRange(u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{System.Int32}@,System.Double)">
            <summary>
            Determine if this 2D Polygon has Vertices within # range of a point
            </summary>
            <param name="_point">the point to test against</param>
            <param name="_findings">the found verts in range</param>
            <param name="_range">the range to check - default is 'Unity double epsilon' ~ 1E-10</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.ClipHulls(u040.prespective.math.doubles.DPolygon2D,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Collections.Generic.List{UnityEngine.Vector2Int}@,System.Double,System.Double)">
            <summary>
            Create a clipping hull by intersecting this polygon with another polygon
            </summary>
            <param name="_other">the polygon to intersect with</param>
            <param name="_clippingHull">the resulting clipping hull</param>
            <param name="_resultAddresses">List with addresses on the polygon that fit the clipping hull verts; (0, 1) = 2nd vert on this polygon</param>
            <param name="_distanceMargin">margin distance</param>
            <param name="_dotMargin">margin dot product</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.HasIntersections(u040.prespective.math.doubles.DPolygon2D,System.Boolean)">
            <summary>
            Test whether the 2 2D polygons have one or more intersections, and returns how they relate
            -1 : No intersections
            0 : at least one LineLine intersection at _iPnt
            1 : this polygon lies within the other polygon
            2 : the other polygon lies within this polygon
            </summary>
            <param name="_other">the other 2D Polygon</param>
            <param name="_colinearIsIntersection">allow collinear intersection</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.hasIntersectionsClippingHullCreation(u040.prespective.math.doubles.DPolygon2D,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>
            Test whether the 2 2D polygons have one or more intersections, and returns how they relate
            -1 : No intersections
            0 : at least one LineLine intersection at _iPnt
            1 : this polygon lies within the other polygon
            2 : the other polygon lies within this polygon
            </summary>
            <param name="_other">the other 2D Polygon</param>
            <param name="_colinearIsIntersection">allow collinear intersection</param>
            <param name="_ignorePointIntersections">if the intersection is precisely on the points it is ignored</param>
            <param name="_distanceMargin">margin distance</param>
            <param name="_dotMargin">margin dot product</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.HasIntersectionsCollisionHullCheck(u040.prespective.math.doubles.DPolygon2D,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>
            Test whether the 2 2D polygons have one or more intersections
            </summary>
            <param name="_other">the other 2D Polygon</param>
            <param name="_colinearIsIntersection">allow collinear intersection</param>
            <param name="_ignorePointIntersections">if the intersection is precisely on the points it is ignored</param>
            <param name="_distanceMargin">margin distance</param>
            <param name="_dotMargin">margin dot product</param>
            <returns>has intersection</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.samePointCheck(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2[],System.Double)">
            <summary>
            checks if point is already present
            </summary>
            <param name="_checkPoint">point to check</param>
            <param name="_comparePoints">points to check against</param>
            <param name="_margin">margin to check in</param>
            <returns>already present</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.BothEdgePointsOnLineCheck(u040.prespective.math.doubles.DVector2[],u040.prespective.math.doubles.DVector2[],System.Double,System.Double)">
            <summary>
            checks if edge points of polygon are on edge of other polygon
            </summary>
            <param name="_check">check edges</param>
            <param name="_compare">compare edges</param>
            <param name="_distanceMargin">margin to check in</param>
            <returns>if has any edge with both points on other edges</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.PointInPolygon(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Returns whether the point lies within this polygon
            </summary>
            <param name="_point">point to check</param>
            <param name="_margin">margin to check in</param>
            <returns>point in polygon</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.PointInPolygonWithEdges(u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Returns whether the point lies within this polygon including if it is on the edge
            </summary>
            <param name="_point">point to check</param>
            <param name="_margin">margin to check in</param>
            <returns>point in polygon</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.basePointInPolygon(u040.prespective.math.doubles.DVector2,System.Double,System.Boolean)">
            <summary>
            base processing of point in polygon
            </summary>
            <param name="_point">point to check</param>
            <param name="_margin">margin to check in</param>
            <param name="_onEdgesReturnValue">the return value when on a edge</param>
            <returns>point in polygon</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.IsLeft(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            point is left of line
            </summary>
            <param name="_beginLine">begin line</param>
            <param name="_endLine">end line</param>
            <param name="_point">point to check</param>
            <param name="_margin"></param>
            <returns>1 is left -1 is right 0 on line</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.DEBUG_drawInScene(u040.prespective.math.doubles.DPlane,UnityEngine.Color,System.Single,u040.prespective.math.doubles.DVector3,System.Boolean)">
            <summary>
            draws polygon in scene
            </summary>
            <param name="_plane">plane to draw on</param>
            <param name="_color">colour</param>
            <param name="_duration">amount time is drawn</param>
            <param name="_offset">offset plane</param>
            <param name="_showOrientation">show orientation</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.DEBUG_drawInScene(UnityEngine.Color,System.Single,System.Boolean)">
            <summary>
            Draw this 2D polygon in the scene
            </summary>
            <param name="_color">the colour to use for the outline</param>
            <param name="_duration">the draw duration, default is 1 tick</param>
            <param name="_worldPosition">whether to draw this polygon on world position (uses DPlane)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.LocalizeXZOntoPlane(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DPlane)">
            <summary>
            Create a DPolygon2D by localizing DVector3 points onto a plane
            </summary>
            <param name="_vertices">The vertices of the polygon</param>
            <param name="_plane">The plane for the Polygon2D</param>
            <returns>A DPolygon2D with the given vertices and plane</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DPolygon2D.EdgeData">
            <summary>
            the data of the edges
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPolygon2D.EdgeData.Edge">
            <summary>
            Rotated edge
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPolygon2D.EdgeData.OriginalEdge">
            <summary>
            Original edge
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPolygon2D.EdgeData.IndexEdge">
            <summary>
            Edge index
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPolygon2D.EdgeData.gradiantValue">
            <summary>
            Gradient of edge formula
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DPolygon2D.EdgeData.constantValue">
            <summary>
            Constant of edge formula
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.EdgeData.#ctor(u040.prespective.math.doubles.DVector2[],System.Int32,u040.prespective.math.doubles.DVector2[],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="_dummyEdge">The rotated edge</param>
            <param name="_index">The edge index</param>
            <param name="_originalVertices">The original vertices</param>
            <param name="_nextIndex">The next edge index</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DPolygon2D.EdgeData.GetValueAtX(System.Double)">
            <summary>
            Gets the vector on the edge
            </summary>
            <param name="_x">X value for the vector</param>
            <returns>The vector on the edge</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.GetIncapsulatedBoxes(System.Collections.Generic.KeyValuePair{UnityEngine.Mesh,UnityEngine.Transform},System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{UnityEngine.Mesh,UnityEngine.Transform}},u040.prespective.math.doubles.DCube@,System.Collections.Generic.List{u040.prespective.math.doubles.DCube}@,System.Double)">
            <summary>
            gets the encapsulated boxes of given mesh filter
            </summary>
            <param name="_main">mesh around encapsulated meshes</param>
            <param name="_meshesToIncapsulated">encapsulated meshes</param>
            <param name="_mainCube">main cube created</param>
            <param name="_subCubes">sub cubes created</param>
            <param name="_enlargingFactor">how much the main cube is enlarged</param>
            <returns>successful</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.GetIncapsulatedBoxes(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{UnityEngine.Mesh,UnityEngine.Transform}},u040.prespective.math.doubles.DQuaternion,System.Int32,System.Int32,u040.prespective.math.doubles.DCube@,System.Collections.Generic.List{u040.prespective.math.doubles.DCube}@,System.Double)">
            <summary>
            gets the encapsulated boxes of given mesh filter
            </summary>
            <param name="_meshesToIncapsulated">encapsulated meshes</param>
            <param name="_rotation">rotation of main cube</param>
            <param name="_directionToCheck">direction to check in first</param>
            <param name="_secondDirectionCheck">direction to check in second</param>
            <param name="_mainCube">main cube created</param>
            <param name="_subCubes">sub cubes created</param>
            <param name="_enlargingFactor">how much the main cube is enlarged</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.getVertices(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{UnityEngine.Mesh,UnityEngine.Transform}},u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            get vertices in main cube space of mesh filters
            </summary>
            <param name="_meshes">mesh filters</param>
            <param name="_globalToLocal">global to local matrix of main cube</param>
            <returns>vertices</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.mainCubeFinding(System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{UnityEngine.Transform,u040.prespective.math.doubles.DVector3[]}},u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion,System.Double,System.Int32,System.Int32,u040.prespective.math.doubles.DCube@)">
            <summary>
            creates main cube
            </summary>
            <param name="_valuesToIncapsulated">values that need to be encapsulated</param>
            <param name="_localToGlobal">local to global matrix</param>
            <param name="_enlargingFactor">enlarging factor</param>
            <param name="_directionToCheck">direction to check in first</param>
            <param name="_secondDirectionCheck">direction to check in second</param>
            <param name="_cube">created cube</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.cubeFinding(UnityEngine.Transform,u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3[],u040.prespective.math.doubles.DCube@)">
            <summary>
            creates sub cube
            </summary>
            <param name="_t">connected transform</param>
            <param name="_localToGlobal">local to global matrix</param>
            <param name="_valuesToIncapsulated">vertices to encapsulated</param>
            <param name="_cube">created cube</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.makeCube(UnityEngine.Transform,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double,System.Int32,System.Int32)">
            <summary>
            makes a DCube of min maximum values
            </summary>
            <param name="_t">connected transform</param>
            <param name="_localToGlobal">local to global matrix</param>
            <param name="_rot">rotation</param>
            <param name="_minx">x minimum</param>
            <param name="_maxx">x maximum</param>
            <param name="_miny">y minimum</param>
            <param name="_maxy">y maximum</param>
            <param name="_minz">z minimum</param>
            <param name="_maxz">z maximum</param>
            <param name="_enlargingFactor">enlarging factor of cube</param>
            <param name="_directionToCheck">direction to check in first</param>
            <param name="_secondDirectionCheck">direction to check in second</param>
            <returns>DCube</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.checkDirection(u040.prespective.math.doubles.DCube,System.Collections.Generic.List{u040.prespective.math.doubles.DCube},System.Int32,System.Int32)">
            <summary>
            creates DCube within main cube depending on direction
            </summary>
            <param name="_mainCube">main cube</param>
            <param name="_subCubes">current sub cubes</param>
            <param name="_directionToCheck">first direction to check</param>
            <param name="_secondDirectionCheck">second direction to check</param>
            <returns>created DCubes</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DEncapsulatedCube.isBetween(System.Double,System.Double,System.Double)">
            <summary>
            check if values if between values
            </summary>
            <param name="_value">value</param>
            <param name="_min">minimum</param>
            <param name="_max">maximum</param>
            <returns>if between</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DVector4">
            <summary>
            @STRUCT : DVector4
            
            @ABOUT : Double implementation of the Unity3D Default float Vector4 struct
            
                     Note that the sourcecode (that was used for implementation) for the unity float class can be found in the GIT:
                     https://github.com/Unity-Technologies/UnityCsReference
            
            @AUTHOR: Tymen (Unit040)
            
            @VERSION:V1.00 - 27/11/2018 - Implemented base
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector with given x, y, z, w components
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <param name="_z"></param>
            <param name="_w"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector with given x, y, z components and sets /w/ to zero
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
            <param name="_z"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.#ctor(System.Double,System.Double)">
            <summary>
            Creates a new vector with given x, y components and sets /z/ and /w/ to zero
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.Zero">
            <summary>
            Shorthand for writing @@Vector4(0,0,0,0)@@
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.One">
            <summary>
            Shorthand for writing @@Vector4(1,1,1,1)@@
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.PositiveInfinity">
            <summary>
            Shorthand for writing @@Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)@@
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.NegativeInfinity">
            <summary>
            Shorthand for writing @@Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)@@
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.SqrMagnitude(u040.prespective.math.doubles.DVector4)">
            <summary>
            *undoc* --- there's a property now
            </summary>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector4.X">
            <summary>
            X component of the vector
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector4.Y">
            <summary>
            Y component of the vector
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector4.Z">
            <summary>
            Z component of the vector
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DVector4.W">
            <summary>
             W component of the vector
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.Item(System.Int32)">
            <summary>
            Access the x, y, z, w components using [0], [1], [2], [3] respectively
            </summary>
            <param name="_index">index to get between 0 and 3</param>
            <returns>index value</returns>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.Normalized">
            <summary>
            Returns this vector with a ::ref::magnitude of 1 (RO)
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.SqrMagnitude">
            <summary>
            *undoc* --- there's a property now
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.ToFloat">
            <summary>
            creates float value of double value
            </summary>
            <returns>float value</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Set(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Set x, y, z and w components of an existing Vector4
            </summary>
            <param name="_newX">new x</param>
            <param name="_newY">new y</param>
            <param name="_newZ">new z</param>
            <param name="_newW">new w</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Scale(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Multiplies two vectors component-wise
            </summary>
            <param name="_a">vector 1</param>
            <param name="_b">vector 2</param>
            <returns>multiplied result</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Scale(u040.prespective.math.doubles.DVector4)">
            <summary>
            Multiplies every component of this vector by the same component of /scale/
            </summary>
            <param name="_scale"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.GetHashCode">
            <summary>
            used to allow Vector4s to be used as keys in hash tables
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Equals(System.Object)">
            <summary>
             also required for being able to use Vector4s as keys in hash tables
            </summary>
            <param name="_other"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Equals(u040.prespective.math.doubles.DVector4)">
            <summary>
            checks if 2 vector4 are equal to eachother
            </summary>
            <param name="_other">compare vector</param>
            <returns>if the same</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Normalize">
            <summary>
            Makes this vector have a ::ref::magnitude of 1
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.ToString">
            <summary>
            makes string of vector 4
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Lerp(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4,System.Double)">
            <summary>
            Linearly interpolates between two vectors
            </summary>
            <param name="_a">vector 1</param>
            <param name="_b">vector 2</param>
            <param name="_t">interpolation factor</param>
            <returns>interpolated vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.LerpUnclamped(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4,System.Double)">
            <summary>
            Linearly interpolates between two vectors without clamping the interpolant
            </summary>
            <param name="_a">vector 1</param>
            <param name="_b">vector 2</param>
            <param name="_t">interpolation factor</param>
            <returns>interpolated vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.MoveTowards(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4,System.Double)">
            <summary>
            Moves a point /current/ towards /target/
            </summary>
            <param name="_current">current point</param>
            <param name="_target">target point</param>
            <param name="_maxDistanceDelta">maximum distance to travel</param>
            <returns>moved vector</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Normalize(u040.prespective.math.doubles.DVector4)">
            <summary>
             *undoc* --- we have normalized property now
            </summary>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Dot(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
             Dot Product of two vectors
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Project(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Projects a vector onto another vector
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Distance(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
             Returns the distance between /a/ and /b/
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Magnitude(u040.prespective.math.doubles.DVector4)">
            <summary>
            *undoc* --- there's a property now
            </summary>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.magnitude">
            <summary>
            Returns the length of this vector (RO)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DVector4.sqrMagnitude">
            <summary>
            Returns the squared length of this vector (RO)
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Min(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Returns a vector that is made from the smallest components of two vectors
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.Max(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Returns a vector that is made from the largest components of two vectors
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Addition(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Adds two vectors
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Subtraction(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Subtracts one vector from another
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_UnaryNegation(u040.prespective.math.doubles.DVector4)">
            <summary>
            Negates a vector
            </summary>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Multiply(u040.prespective.math.doubles.DVector4,System.Double)">
            <summary>
            Multiplies a vector by a number
            </summary>
            <param name="_a"></param>
            <param name="_d"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Multiply(System.Double,u040.prespective.math.doubles.DVector4)">
            <summary>
            Multiplies a vector by a number
            </summary>
            <param name="_d"></param>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Division(u040.prespective.math.doubles.DVector4,System.Double)">
            <summary>
            Divides a vector by a number
            </summary>
            <param name="_a"></param>
            <param name="_d"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Equality(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
             Returns true if the vectors are equal
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Inequality(u040.prespective.math.doubles.DVector4,u040.prespective.math.doubles.DVector4)">
            <summary>
            Returns true if vectors are different
            </summary>
            <param name="_lhs"></param>
            <param name="_rhs"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Implicit(u040.prespective.math.doubles.DVector3)~u040.prespective.math.doubles.DVector4">
            <summary>
            Converts a [[Vector3]] to a Vector4
            </summary>
            <param name="_v"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Implicit(u040.prespective.math.doubles.DVector4)~u040.prespective.math.doubles.DVector3">
            <summary>
            Converts a Vector4 to a [[Vector3]]
            </summary>
            <param name="_v"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Implicit(u040.prespective.math.doubles.DVector2)~u040.prespective.math.doubles.DVector4">
            <summary>
            Converts a [[Vector2]] to a Vector4
            </summary>
            <param name="_v"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DVector4.op_Implicit(u040.prespective.math.doubles.DVector4)~u040.prespective.math.doubles.DVector2">
            <summary>
            Converts a Vector4 to a [[Vector2]]
            </summary>
            <param name="_v"></param>
        </member>
        <member name="T:u040.prespective.math.doubles.DBounds2D">
            <summary>
            Double implementation of the Unity3D Default float bounds struct for 2D
            
            Note that the source code (that was used for implementation) for the unity float class can be found in the GIT:
            https://github.com/Unity-Technologies/UnityCsReference
            
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DBounds2D.Center">
            <summary>
            The center of the bounding box
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds2D.Size">
            <summary>
            The total size of the range of the bounds
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DBounds2D.extents">
            <summary>
            The size of the range from the center to the edge of the bounds (always half the Size property)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds2D.Extents">
            <summary>
            The size of the range from the center to the edge of the bounds (always half the Size property)
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds2D.Min">
            <summary>
            The minimal point of the box. This is always equal to "Center property - Extents property"
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DBounds2D.Max">
            <summary>
            The maximal point of the box. This is always equal to "Center property + Extents property"
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.#ctor(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Creates new DBounds2D with a given center and total size. Bound extents will be half the given size
            </summary>
            <param name="_center">The center point of the bounds</param>
            <param name="_size">The total size of the bounds (2x the extents measured from the center)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.ToFloat">
            <summary>
            Get a copy of this DBounds2D of type Bounds2D which uses floats instead of doubles
            </summary>
            <returns>A copy of this bounds of type Bounds2D that uses floats instead of doubles</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.GetHashCode">
            <summary>
            Get a hash code based on the Center and Extents properties of this bounds to be used as keys in hash tables
            </summary>
            <returns>The hash code based on this bounds Center and Extents properties</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Equals(System.Object)">
            <summary>
            Check if the other object is of type DBounds2D and equal to another DBounds2D
            </summary>
            <param name="_other">The other object to compare this DBounds2D to</param>
            <returns>A boolean indicating whether or not this DBounds2D is equal to the other object</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Equals(u040.prespective.math.doubles.DBounds2D)">
            <summary>
            Check if this DBounds2D is equal to another DBounds2D
            </summary>
            <param name="_other">The other DBounds2D to compare this DBounds2D to</param>
            <returns>A boolean indicating whether or not this DBounds2D is equal to the other DBounds2D</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.SetMinMax(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Set this bounds values with two DVector2 describing the new min and max values for this bounds
            </summary>
            <param name="_min">The new min values for this bounds</param>
            <param name="_max">The new max values for this bounds</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Encapsulate(u040.prespective.math.doubles.DVector2)">
            <summary>
            Grows this DBounds2D to include a point
            </summary>
            <param name="_pointToEncapsulate">The point to encapsulate</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Encapsulate(u040.prespective.math.doubles.DBounds2D)">
            <summary>
            Grows this DBounds2D to include another DBounds2D
            </summary>
            <param name="_boundsToEncapsulate">The other DBounds2D to encapsulate</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Expand(System.Double)">
            <summary>
            Expand the bounds by adding the same size to both the X and Y values of the Size property
            </summary>
            <param name="_sizeToAdd">The size to add to the value of the Size property (Note: Adds _sizeToAdd * 0.5 to BOTH sides of the center)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Expand(u040.prespective.math.doubles.DVector2)">
            <summary>
            Expand the bounds by adding size to the X and Y values of the Size property
            </summary>
            <param name="_sizeToAdd">The sizes to add for The X and Y values of the Size property (Note: Adds _sizeToAdd * 0.5 to BOTH sides of the center)</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Intersects(u040.prespective.math.doubles.DBounds2D)">
            <summary>
            Check if another DBounds2D intersects with this DBounds2D
            </summary>
            <param name="_boundsToCheckIntersectionWith">The other DBounds2D to check for intersection with this DBounds2D</param>
            <returns>A boolean indicating whether or not this DBounds2D intersects with the other DBounds2D</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.Contains(u040.prespective.math.doubles.DVector2)">
            <summary>
            Check if a given point is contained within this DBounds2D
            </summary>
            <param name="_pointToCheckContainmentFor">The point to check containment within this DBounds2D for</param>
            <returns>A boolean indicating whether or not the given point is contained within this DBounds2D</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.ToString">
            <summary>
            ToString function for DBounds2D
            </summary>
            <returns>A string with the Center and Extents properties</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.op_Equality(u040.prespective.math.doubles.DBounds2D,u040.prespective.math.doubles.DBounds2D)">
            <summary>
            == operator for DBounds2D that checks if the Center and Extents properties are equal for both DBounds2D
            </summary>
            <param name="_valueLeftOfOperator">The DBounds2D left of the == operator</param>
            <param name="_valueRightOfOperator">The DBounds2D right of the == operator</param>
            <returns>A boolean indicating whether or not the DBounds2D objects on both side of the == operator have equal Center and Extents properties (Note: Returns false in the presence of NaN values)</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DBounds2D.op_Inequality(u040.prespective.math.doubles.DBounds2D,u040.prespective.math.doubles.DBounds2D)">
            <summary>
            != operator for DBounds2D that checks if the Center and Extents properties are NOT equal for both DBounds2D
            </summary>
            <param name="_valueLeftOfOperator">The DBounds2D left of the != operator</param>
            <param name="_valueRightOfOperator">The DBounds2D right of the != operator</param>
            <returns>A boolean indicating whether or not the DBounds2D objects on both side of the != operator do NOT have equal Center and Extents properties (Note: Returns true in the presence of NaN values)</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DQuaternion">
            <summary>
            Double implementation of the the float based 'Quaternion' UnityEngine Class
            
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DQuaternion.Identity">
            <summary>
            Identity rotation quaternion (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DQuaternion.Zero">
            <summary>
            Zero rotation quaternion (style sheet exception)
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DQuaternion.X">
            <summary>
            X value quaternion
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DQuaternion.Y">
            <summary>
            Y value quaternion
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DQuaternion.Z">
            <summary>
            Z value quaternion
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DQuaternion.W">
            <summary>
            W value quaternion
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DQuaternion.EulerAngles">
            <summary>
            Euler angles
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DQuaternion.Normalized">
            <summary>
            Normalize self
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DQuaternion.Item(System.Int32)">
            <summary>
            Quaternion values (x,y,z,w) on index (between 0 and 3)
            </summary>
            <param name="_i">index</param>
            <returns>value at index</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructor
            </summary>
            <param name="_x">x value quaternion</param>
            <param name="_y">y value quaternion</param>
            <param name="_z">z value quaternion</param>
            <param name="_w">w value quaternion</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.#ctor(UnityEngine.Quaternion)">
            <summary>
            Constructor
            </summary>
            <param name="_input">quaternion</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>has code</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.ToFloat">
            <summary>
            Makes float quaternion from double quaternion
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.ToString">
            <summary>
            Get string value of quaternion
            </summary>
            <returns>value of quaternion</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Set(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Set new value to quaternion
            </summary>
            <param name="_newX"></param>
            <param name="_newY"></param>
            <param name="_newZ"></param>
            <param name="_newW"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Equals(u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Checks if value is equal to stored value
            </summary>
            <param name="_other">quaternion</param>
            <returns>if equal</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Equals(System.Object)">
            <summary>
            Checks if object is equal to stored value
            </summary>
            <param name="_other">object</param>
            <returns>if equal</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.IsNan">
            <summary>
            Checks is DQuaternion has NAN values
            </summary>
            <returns>has NAN value</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Angle(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Get angle between quaternions
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.CheckAngleDifference(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion,System.Double)">
            <summary>
            Checks if 2 quaternions have no angle difference between them
            </summary>
            <param name="_a">rotation a</param>
            <param name="_b">rotation b</param>
            <param name="_dotMargin">dot margin to check within</param>
            <returns>if 2 quaternions have angle difference</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.AngleAxis(System.Double,u040.prespective.math.doubles.DVector3)">
            <summary>
            Get rotation determined by given axis and angle in radian
            </summary>
            <param name="_angle">angle in radian</param>
            <param name="_axis">axis</param>
            <returns>rotation</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.RotationAxisOfRotation(u040.prespective.math.doubles.DQuaternion,System.Double@)">
            <summary>
            Get the rotation axis of given rotation
            </summary>
            <param name="_rot">rotation</param>
            <param name="_angle">angle over axis in radii</param>
            <returns>rotation axis</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.dot(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Dot product of quaternions
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns>dot</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Euler(System.Double,System.Double,System.Double)">
            <summary>
            The quaternion of given Euler angles (x = pitch, y = yaw, z = roll)
            </summary>
            <param name="_x">x Euler angle</param>
            <param name="_y">y Euler Angle</param>
            <param name="_z">z Euler Angle</param>
            <returns>quaternion of Euler angles</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Euler(u040.prespective.math.doubles.DVector3)">
            <summary>
            The quaternion of given Euler angles (x = pitch, y = yaw, z = roll)
            </summary>
            <param name="_euler">Euler angles</param>
            <returns>quaternion of Euler angles</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.FromToRotation(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            Calculate the rotation from DVector3 _fromDirection to  DVector3 _toDirection
            </summary>
            <param name="_fromDirection">the start direction</param>
            <param name="_toDirection">the end direction</param>
            <param name="_margin">the margin to use for identity calculation</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.FromToRotation(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3)">
            <summary>
            Calculates the rotation from rotation _from to rotation _to while restricting rotation over axis _restrictionAxis
            </summary>
            <param name="_from">the from rotation (may be unconstrained)</param>
            <param name="_to">the to rotation (may be unconstrained)</param>
            <param name="_restrictionAxis">the axis we want to use for restriction</param>
            <returns>the resulting rotation with the restrictions applied (may need multiplication with the _from rotation to retain orientation)</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Inverse(u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Inverse quaternion
            </summary>
            <param name="_rotation">rotation</param>
            <returns>inverse quaternion</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Normalize(u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Normalize
            </summary>
            <param name="_q">quaternion to normalize</param>
            <returns>normalized quaternion</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Lerp(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion,System.Double)">
            <summary>
            Lerp between 2 rotations
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_t">lerp factor</param>
            <returns>lerped rotation</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.LerpUnclamped(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion,System.Double)">
            <summary>
            Lerp between 2 rotations unclamped
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_t">lerp factor</param>
            <returns>lerped rotation</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Average(u040.prespective.math.doubles.DQuaternion[],System.Double[])">
            <summary>
            Average a set of quaternions with an applied relative weighting
            Adapted from:
            https://forum.unity.com/threads/average-quaternions.86898/
            (Implemented as part of DES)
            </summary>
            <param name="_quaternions">the quaternions to be weighted</param>
            <param name="_weight">the weighting to apply to the quaternion at entry</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.LookRotation(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Adapted from https://answers.unity.com/questions/467614/what-is-the-source-code-of-quaternionlookrotation.html
            
            Fixed faulty up vector reference @ line 5 (21/10/2018)
            </summary>
            <param name="_forward"></param>
            <param name="_upwards"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.Slerp(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion,System.Double)">
            <summary>
            Slerp between rotations
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_t">slerp factor</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.SlerpUnclamped(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion,System.Double)">
            <summary>
            Slerp between rotations unclamped
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <param name="_t">slerp factor</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.PlanarRotation(u040.prespective.math.doubles.DVector3)">
            <summary>
            Get rotation of plane
            </summary>
            <param name="_planarNormal">plane normal</param>
            <returns>rotation of plane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.normalizeAngles(u040.prespective.math.doubles.DVector3)">
            <summary>
            Normalize Euler angle
            </summary>
            <param name="_angles">angles</param>
            <returns>normalized angles</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.normalizeAngle(System.Double)">
            <summary>
            Normalize angle
            </summary>
            <param name="_angle">angle</param>
            <returns>normalized angle</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.op_Multiply(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Multiply rotations
            </summary>
            <param name="_lhs">left of operator quaternion</param>
            <param name="_rhs">right of operator quaternion</param>
            <returns>multiplied quaternion</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.op_Equality(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Check if rotation are equal
            </summary>
            <param name="_lhs">left of operator quaternion</param>
            <param name="_rhs">right of operator quaternion</param>
            <returns>if quaternions are equal</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DQuaternion.op_Inequality(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            Check if rotation are not equal
            </summary>
            <param name="_lhs">left of operator quaternion</param>
            <param name="_rhs">right of operator quaternion</param>
            <returns>if quaternions are not equal</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DNgon">
            <summary>
            @CLASS : DNgon
            
            @ABOUT : Creates a Left-handed Ngon based N points in Double Vector3 format
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: v1.00 - 25/04/2019 - Implemented based on Triangles used for alignment and Affign transformation
            </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DNgon.Points">
            <summary>
            The points describing this Ngon
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.#ctor">
            <summary>
            empty constructor
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.#ctor(u040.prespective.math.doubles.DNgonPoint[])">
            <summary>
            constructor
            </summary>
            <param name="_points"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.#ctor(System.Collections.Generic.List{u040.prespective.math.doubles.DNgonPoint})">
            <summary>
            constructor
            </summary>
            <param name="_points"></param>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.Inverse">
            <summary>
            Inverse this Ngon shape
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.Cycle(System.Boolean,System.Int32)">
            <summary>
            Cycle the points in this Ngon left or right
            </summary>
            <param name="_left">whether to cycle left or right</param>
            <param name="_n">how many times to cycle</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.Rotation(UnityEngine.Vector3Int)">
            <summary>
            Get the rotation of a triangle (A, B, C) part of N-gon, assuming the forward direction is targeted from A to B
            </summary>
            <param name="_indices">the indices to use for creating the triangle/determining the rotation</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.Normal(UnityEngine.Vector3Int)">
            <summary>
            Returns the (planar) normal (direction) this N-gon is oriented in
            </summary>
            <param name="_indices">the point (indices) to use to create the planar normal - default is the first 3 points in order</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.GetAffineTransformation(u040.prespective.math.doubles.DNgon,System.Boolean,u040.prespective.math.doubles.DNgonTransform,u040.prespective.math.doubles.DNgonTransform,UnityEngine.Vector3Int)">
            <summary>
            Provides the Affine transformation (translation, rotation and scaling) required to go from '_other' N-gon in space '_otherTransform' (default world space)
            to this N-gon in space '_selfTransform' (default world space)
            </summary>
            <param name="_other">the N-gon describing the desired result</param>
            <param name="_useWeightedCentroid">Whether to use a weighted centroid when calculating the control point used for the N-gon triangles</param>
            <param name="_selfTransform">the origin transformation of this N-gon</param>
            <param name="_otherTransform">the origin transformation of the '_other' N-gon</param>
            <param name="_otherTransform">the point indices to use for transformation calculation</param>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.Centroid(System.Boolean)">
            <summary>
            Return the centroid of this Ngon
            </summary>
            <param name="_weighted">whether to consider weight</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DNgon.MatchByClosestPoints(UnityEngine.Vector3[],System.Func{UnityEngine.Vector3,UnityEngine.Vector3})">
            <summary>
            match by closeted points
            </summary>
            <param name="_toMatch"></param>
            <param name="_v3Op"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DNgonTransform">
            <summary>
            @CLASS : DTransform
            
            @ABOUT : Double Transform Object to contain the position, rotation and scale
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: v1.00 - 25/04/2019 - Implemented as part of the Arbitrary Alignment refactoring
            </summary>
        </member>
        <member name="T:u040.prespective.math.doubles.DNgonPoint">
            <summary>
            @CLASS : DNgonPoint
            
            @ABOUT : Class containing the description of a weighted point part of an N-Gon
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: v1.00 - 25/04/2019 - Implemented as part of the Arbitrary Alignment refactoring
            </summary>
        </member>
        <member name="T:u040.prespective.math.doubles.DoubleRandom">
             <summary>
             Class to create a double Random Value
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="F:u040.prespective.math.doubles.DoubleRandom.randomInstance">
            <summary>
            The singleton instance
            </summary>
        </member>
        <member name="P:u040.prespective.math.doubles.DoubleRandom.RandomInstance">
            <summary>
            Create a random instance only once
            </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DoubleRandom.Range(System.Double,System.Double)">
            <summary>
            Get a random double within a given range
            </summary>
            <param name="_min">Minimum value point</param>
            <param name="_max">Maximum value point</param>
            <returns>A random double within a given range</returns>
        </member>
        <member name="T:u040.prespective.math.doubles.DIntersection">
             <summary>
             Combined library of parametric(2D) and vector(3D) intersection and point projection math functions
             Rewritten for use of double values (instead of float)
            
             <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
             </summary>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LinearIntersection(u040.prespective.math.doubles.DVector2@,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Find intersections on 2 linear 2D parametric polynomials (y = a * x + b)
            </summary>
            <param name="_intersection">(out parameter) Intersection point</param>
            <param name="_firstOrder1">First order (aX) of the first polynomial</param>
            <param name="_constant1">Constant (+b) of the first polynomial</param>
            <param name="_firstOrder2">First order (aX) of the second polynomial</param>
            <param name="_constant2">Constant (+b) of the second polynomial</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.QuadraticIntersection(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Find intersections on 2 quadratic 2D parametric polynomials (y = a * x^2 + b * x + c)
            </summary>
            <param name="_intersections">(out parameter) List with intersection points</param>
            <param name="_secondOrder1">Second order (aX^2) of the first polynomial</param>
            <param name="_firstOrder1">First order (aX) of the first polynomial</param>
            <param name="_constant1">Constant (+b) of the first polynomial</param>
            <param name="_secondOrder2">Second order (aX^2) of the second polynomial</param>
            <param name="_firstOrder2">First order (aX) of the second polynomial</param>
            <param name="_constant2">Constant (+b) of the second polynomial</param>
            <returns>A boolean indicating whether or not at least one intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.TertiaryIntersection(System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Find intersections on 2 cubic 2D parametric polynomials (y = a * x^3 + b * x^2 + c * x + d)
            </summary>
            <param name="_intersections">Output with (x, y) of the found intersections</param>
            <param name="_thirdOrder1">Third order (ax^3) of the first polynomial</param>
            <param name="_secondOrder1">Second order (bX^2) of the first polynomial</param>
            <param name="_firstOrder1">First order (aX) of the first polynomial</param>
            <param name="_constant1">Constant (+b) of the first polynomial</param>
            <param name="_thirdOrder2">Third order (ax^3) of the second polynomial</param>
            <param name="_secondOrder2">Second order (bX^2) of the second polynomial</param>
            <param name="_firstOrder2">First order (aX) of the second polynomial</param>
            <param name="_constant2">Constant (+b) of the second polynomial</param>
            <returns>A boolean indicating whether or not at least one intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.ThirdDegreeCardanoIntersection(System.Collections.Generic.List{System.Double}@,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Algorithm for solving a 3rd degree polynomial (Cubic > Cardano formula)
            
            Reference taken from:
            https://www.easycalculation.com/algebra/cubic-equation.php
            
            (Note: The JavaScript is visible in the page header)
            </summary>
            <param name="_complex">(out parameter) The complex number additions for the found intersections</param>
            <param name="_thirdOrder">The A(x^3) coefficient</param>
            <param name="_secondOrder">The B(x^2) coefficient</param>
            <param name="_firstOrder">The C(x) coefficient</param>
            <param name="_constant">The D coefficient</param>
            <returns>The x-values for which y=0</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineSegmentLineSegmentIntersection2D(u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Get the intersection point between two 2D line segments
            (Included as part of DES)
            </summary>
            <param name="_intersection">(out parameter) The intersection point</param>
            <param name="_line1Start">First line segment starting point</param>
            <param name="_line1End">First line segment end point</param>
            <param name="_line2Start">Second line segment starting point</param>
            <param name="_line2End">Second line segment end point</param>
            <param name="_margin">The margin to use for checking intersection points (default = 0d)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineSegmentLineSegmentIntersectionCoLinear2D(u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Boolean)">
            <summary>
            Get the intersection point between two 2D line segments with the additional functionality of deciding whether or not a collinear intersection should be deemed a valid intersection
            </summary>
            <param name="_intersection">(out parameter) The intersection point</param>
            <param name="_line1Start">First line segment starting point</param>
            <param name="_line1End">First line segment end point</param>
            <param name="_line2Start">Second line segment starting point</param>
            <param name="_line2End">The margin to use for checking intersection points</param>
            <param name="_coLinearIsIntersection">Whether a collinear intersection should be deemed a valid intersection (will result in some extra tests)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineSegmentLineIntersection2D(u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Get the intersection point between a 2D line segment and a 2D line
            </summary>
            <param name="_intersection">(out parameter) The intersection point</param>
            <param name="_lineSegmentStart">Line segment starting point</param>
            <param name="_lineSegmentEnd">Line segment end point</param>
            <param name="_linePoint">Line point</param>
            <param name="_lineDirection">Line direction</param>
            <param name="_margin">The margin to use for checking intersection points (default = 0d)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineLineIntersection2D(u040.prespective.math.doubles.DVector2@,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Double)">
            <summary>
            Get the intersection point between two 2D lines. Returns true if lines intersect, otherwise false. Ignores parallel and anti parallel lines
            </summary>
            <param name="_intersection">(out parameter) The intersection point</param>
            <param name="_line1Point">Point on the first line</param>
            <param name="_line1Direction">Direction of the first line</param>
            <param name="_line2Point">Point on the second line</param>
            <param name="_line2Direction">Direction of the second line</param>
            <param name="_lineDirectionMargin">The margin to check if a line is going straight up (default = 1E-10d)</param>
            <returns>A boolean indicating whether or not an intersection was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.PlanePlaneIntersection3D(u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Find the line of intersection between two planes. The planes are defined by a normal and a point on that plane.
            The outputs are a point on the line and a vector which indicates it's direction. If the planes are not parallel, 
            the function outputs true, otherwise false.
            
            Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
            </summary>
            <param name="_intersectionLinePoint">(out parameter) Starting point of the intersection line</param>
            <param name="_intersectionLineDirection">(out parameter) Direction of the intersection line</param>
            <param name="_plane1Normal">Normal of the first plane</param>
            <param name="_plane1Origin">Origin of the first plane</param>
            <param name="_plane2Normal">Normal of the second plane</param>
            <param name="_plane2Origin">Origin of the second plane</param>
            <returns>A boolean indicating whether or not an intersection line was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineSegmentPlaneIntersection3D(u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double,System.Double)">
            <summary>
            Get the intersection point between a 3D line segment and a plane
            </summary>
            <param name="_intersection">(out parameter) The intersection point</param>
            <param name="_lineStart">Line segment starting point</param>
            <param name="_lineEnd">Line segment end point</param>
            <param name="_planeNormal">Normal of the plane</param>
            <param name="_planeOrigin">Origin of the plane</param>
            <param name="_distanceMargin">Margin for the line segment check (default = 0d)</param>
            <param name="_dotMargin">Margin of the dot product for the parallel check (default = 0d)</param>
            <returns>A boolean indicating whether or not an intersection point was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LinePlaneIntersection3D(u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            Get the intersection point between a 3D line and a plane. If the line and plane are not parallel, the function outputs true, otherwise false.
            
            Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
            </summary>
            <param name="_intersection">(out parameter) The intersection point</param>
            <param name="_linePoint">Point on the first line</param>
            <param name="_lineDirection">Direction of the first line</param>
            <param name="_planeNormal">Normal of the plane</param>
            <param name="_planeOrigin">Origin of the plane</param>
            <param name="_dotMargin">Margin for the parallel check (default = 0d)</param>
            <returns>A boolean indicating whether or not an intersection point was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineSegmentLineSegmentIntersection3D(u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            Get the intersection point between two 3D line segments
            </summary>
            <param name="_intersection">(out parameter) The intersection point</param>
            <param name="_line1Start">First line segment starting point</param>
            <param name="_line1End">First line segment end point</param>
            <param name="_line2Start">Second line segment starting point</param>
            <param name="_line2End">The margin to use for checking intersection points</param>
            <returns>A boolean indicating whether or not an intersection point was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineLineIntersection3D(u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            Get the intersection point between two 3D lines. Returns true if lines intersect, otherwise false.
            Note that in 3d, two lines do not intersect most of the time. So if the two lines are not in the 
            same plane, use ClosestPointsOnTwoLines() instead.
            
            Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
            </summary>
            <param name="_intersection">(out parameter) The intersection points</param>
            <param name="_line1Point">Point on the first line</param>
            <param name="_line1Direction">Direction of the first line</param>
            <param name="_line2Point">Point on the second line</param>
            <param name="_line2Direction">Direction of the second line</param>
            <param name="_margin">margin</param>
            <returns>A boolean indicating whether or not an intersection point was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineSegmentCircleIntersection(u040.prespective.math.doubles.DVector2,System.Double,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@,System.Double)">
             <summary>
            Get the intersection points between a circle and a line segment
             
             http://mathworld.wolfram.com/Circle-LineIntersection.html
             </summary>
             <param name="_circleCenter">Circle centre</param>
             <param name="_circleRadius">Circle radius</param>
             <param name="_lineStart">Line segment starting point</param>
             <param name="_lineEnd">Line segment end point</param>
             <param name="_intersectionPoints">(out parameter) Intersection points</param>
             <param name="_margin">Margin to check intersection points with (default = 0d)</param>
             <returns>A boolean indicating whether or not at least one intersection point was found</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineCircleIntersection(u040.prespective.math.doubles.DVector2,System.Double,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,System.Collections.Generic.List{u040.prespective.math.doubles.DVector2}@)">
            <summary>
            Determines the intersection points between circle and line
            http://mathworld.wolfram.com/Circle-LineIntersection.html
            </summary>
            <param name="_circleCentre">Circle centre</param>
            <param name="_circleRadius">Circle radius</param>
            <param name="_linePoint">point of on the line</param>
            <param name="_lineDirection">direction of line</param>
            <param name="_intersectionPoints">Found intersection points</param>
            <returns>if found intersection</returns>
            ToDo: Function name implies that the input should be line point and line direction, but is a line segment instead? Same as function above? Function needs a rewrite
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.LineSegmentFullyInsideCircle(u040.prespective.math.doubles.DVector2,System.Double,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Check if a given line is fully inside of a given circle
            </summary>
            <param name="_centreCircle">Circle centre</param>
            <param name="_circleRadius">Circle radius</param>
            <param name="_lineBeginPoint">Line segment starting point</param>
            <param name="_lineEndPoint">Line segment end point</param>
            <returns>A boolean indicating whether or not the line segment is fully inside the circle</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.GetClosestPointOnLineSegment2D(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Gets the closed point to a given 2D point on a 2D line segment
            </summary>
            <param name="_point">Point to check with</param>
            <param name="_lineStart">Line segment starting point</param>
            <param name="_lineEnd">Line segment end point</param>
            <returns>Closest point on the line segment</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.GetClosestPointOnLine2D(u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2,u040.prespective.math.doubles.DVector2)">
            <summary>
            Gets the closed point to a given 2D point on a 2D line
            </summary>
            <param name="_point">Point to check with</param>
            <param name="_linePoint">point on line</param>
            <param name="_lineDirection">Direction of line</param>
            <returns>Closest point on the line</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.GetClosestPointsOnTwoLines3D(u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3@,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Two non-parallel 3D lines which may or may not touch each other have a point on each line which are closest
            to each other. This function finds those two points. If the lines are not parallel, the function 
            outputs true, otherwise false.
            
            Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
            </summary>
            <param name="_closestPointToLine1">(out parameter) Closest point on the first line</param>
            <param name="_closestPointToLine2">(out parameter) Closest point on the second line</param>
            <param name="_line1Point">Point on the first line</param>
            <param name="_line1Direction">Direction of the first line</param>
            <param name="_line2Point">Point on the second line</param>
            <param name="_line2Direction">Direction of the second line</param>
            <returns>A boolean indicating whether or not the two parallel lines are NOT parallel (NOT parallel = true)</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.GetClosedPointOnLineSegment3D(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            Determines which point on the line segment in 3D is closed to given point in 3D
            </summary>
            <param name="_linePoint1">line segment first point</param>
            <param name="_linePoint2">line segment second point</param>
            <param name="_point">point to find closeted to</param>
            <param name="_margin">margin</param>
            <returns>closet point on line segment</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.ProjectPointOnLineSegment(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
             <summary>
             This function returns a point which is a projection from a 3D point to a 3D line segment.
             If the projected point lies outside of the line segment, the projected point will 
             be clamped to the appropriate line edge.
             If the line is infinite instead of a segment, use ProjectPointOnLine() instead.
            
             Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
             </summary>
             <param name="_lineStart">Start of line segment</param>
             <param name="_lineEnd">End of line segment</param>
             <param name="_point">Point to project</param>
             <returns>The projected point</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.ProjectPointOnLine(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            This function returns a point which is a projection from a 3D point to a 3D line.
            The line is regarded infinite. If the line is finite, use ProjectPointOnLineSegment() instead.
            
            Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
            </summary>
            <param name="_linePoint">Point on the line</param>
            <param name="_lineDirection">Direction of the line</param>
            <param name="_point">Point to project on the line</param>
            <returns>The projected point</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.ProjectPointOnPlane(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            This function returns a point which is a projection from a 3D point to a plane.
            </summary>
            <param name="_planeNormal">Normal of the plane</param>
            <param name="_planeOrigin">Origin of the plane</param>
            <param name="_point">Point to project onto plane</param>
            <returns>The projected point</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.SignedDistancePlanePoint(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
             <summary>
             Get the shortest distance between a 3D point and a plane. The output is signed so it holds information
             as to which side of the plane normal the point is.
            
             Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
             </summary>
             <param name="_planeNormal">Normal of the plane</param>
             <param name="_planeOrigin">Origin of the plane</param>
             <param name="_point">Point to determine distance from</param>
             <returns>The shortest distance between a point and a plane</returns>
        </member>
        <member name="M:u040.prespective.math.doubles.DIntersection.OnWhichSideOfLineSegmentIsPoint(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
             <summary>
             This function finds out on which side of a 3D line segment a 3D point is located.
             The point is assumed to be on a line segment created by lineStart and lineEnd. If the point is not on
             the line segment, project it on the line using ProjectPointOnLine() first.
             Returns 0 if point is on the line segment.
             Returns 1 if point is outside of the line segment and located on the side of lineStart.
             Returns 2 if point is outside of the line segment and located on the side of lineEnd.
            
             Adapted to doubles from: http://wiki.unity3d.com/index.php/3d_Math_functions
             </summary>
             <param name="_lineStart">Starting point of the line segment</param>
             <param name="_lineEnd">End point of the line segment</param>
             <param name="_point">Point to compare</param>
             <returns>0 if point is on the line segment, 1 if point is outside of the line segment and located on the side of lineStart and 2 if point is outside of the line segment and located on the side of lineEnd</returns>
        </member>
        <member name="T:u040.prespective.math.singles.Bounds2D">
            <summary>
            2D version of unity bounds class
            
            Note that the source code (that was used for implementation) for the unity float class can be found in the GIT:
            https://github.com/Unity-Technologies/UnityCsReference
            
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="F:u040.prespective.math.singles.Bounds2D.Center">
            <summary>
            The center of the bounding box
            </summary>
        </member>
        <member name="P:u040.prespective.math.singles.Bounds2D.Size">
            <summary>
            The total size of the range of the bounds
            </summary>
        </member>
        <member name="F:u040.prespective.math.singles.Bounds2D.extents">
            <summary>
            The size of the range from the center to the edge of the bounds (always half the Size property)
            </summary>
        </member>
        <member name="P:u040.prespective.math.singles.Bounds2D.Extents">
            <summary>
            The size of the range from the center to the edge of the bounds (always half the Size property)
            </summary>
        </member>
        <member name="P:u040.prespective.math.singles.Bounds2D.Min">
            <summary>
            The minimal point of the box. This is always equal to "Center property - Extents property"
            </summary>
        </member>
        <member name="P:u040.prespective.math.singles.Bounds2D.Max">
            <summary>
            The maximal point of the box. This is always equal to "Center property + Extents property"
            </summary>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.#ctor(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Creates new Bounds2D with a given center and total size. Bound extents will be half the given size
            </summary>
            <param name="_center">The center point of the bounds</param>
            <param name="_size">The total size of the bounds (2x the extents measured from the center)</param>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.GetHashCode">
            <summary>
            Get a hash code based on the Center and Extents properties of this bounds to be used as keys in hash tables
            </summary>
            <returns>The hash code based on this bounds Center and Extents properties</returns>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Equals(System.Object)">
            <summary>
            Check if the other object is of type Bounds2D and equal to another Bounds2D
            </summary>
            <param name="_other">The other object to compare this Bounds2D to</param>
            <returns>A boolean indicating whether or not this Bounds2D is equal to the other object</returns>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Equals(u040.prespective.math.singles.Bounds2D)">
            <summary>
            Check if this Bounds2D is equal to another Bounds2D
            </summary>
            <param name="_other">The other Bounds2D to compare this Bounds2D to</param>
            <returns>A boolean indicating whether or not this Bounds2D is equal to the other Bounds2D</returns>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.SetMinMax(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Set this bounds values with two Vector2 describing the new min and max values for this bounds
            </summary>
            <param name="_min">The new min values for this bounds</param>
            <param name="_max">The new max values for this bounds</param>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Encapsulate(UnityEngine.Vector2)">
            <summary>
            Grows this Bounds2D to include a point
            </summary>
            <param name="_pointToEncapsulate">The point to encapsulate</param>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Encapsulate(u040.prespective.math.singles.Bounds2D)">
            <summary>
            Grows this Bounds2D to include another Bounds2D
            </summary>
            <param name="_boundsToEncapsulate">The other Bounds2D to encapsulate</param>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Expand(System.Single)">
            <summary>
            Expand the bounds by adding the same size to both the X and Y values of the Size property
            </summary>
            <param name="_sizeToAdd">The size to add to the value of the Size property (Note: Adds _sizeToAdd * 0.5 to BOTH sides of the center)</param>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Expand(UnityEngine.Vector2)">
            <summary>
            Expand the bounds by adding size to the X and Y values of the Size property
            </summary>
            <param name="_sizeToAdd">The sizes to add for The X and Y values of the Size property (Note: Adds _sizeToAdd * 0.5 to BOTH sides of the center)</param>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Intersects(u040.prespective.math.singles.Bounds2D)">
            <summary>
            Check if another Bounds2D intersects with this Bounds2D
            </summary>
            <param name="_boundsToCheckIntersectionWith">The other Bounds2D to check for intersection with this Bounds2D</param>
            <returns>A boolean indicating whether or not this Bounds2D intersects with the other Bounds2D</returns>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.Contains(UnityEngine.Vector2)">
            <summary>
            Check if a given point is contained within this Bounds2D
            </summary>
            <param name="_pointToCheckContainmentFor">The point to check containment within this Bounds2D for</param>
            <returns>A boolean indicating whether or not the given point is contained within this Bounds2D</returns>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.ToString">
            <summary>
            ToString function for Bounds2D
            </summary>
            <returns>A string with the Center and Extents properties</returns>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.op_Equality(u040.prespective.math.singles.Bounds2D,u040.prespective.math.singles.Bounds2D)">
            <summary>
            == operator for Bounds2D that checks if the Center and Extents properties are equal for both Bounds2D
            </summary>
            <param name="_valueLeftOfOperator">The Bounds2D left of the == operator</param>
            <param name="_valueRightOfOperator">The Bounds2D right of the == operator</param>
            <returns>A boolean indicating whether or not the Bounds2D objects on both side of the == operator have equal Center and Extents properties (Note: Returns false in the presence of NaN values)</returns>
        </member>
        <member name="M:u040.prespective.math.singles.Bounds2D.op_Inequality(u040.prespective.math.singles.Bounds2D,u040.prespective.math.singles.Bounds2D)">
            <summary>
            != operator for Bounds2D that checks if the Center and Extents properties are NOT equal for both Bounds2D
            </summary>
            <param name="_valueLeftOfOperator">The Bounds2D left of the != operator</param>
            <param name="_valueRightOfOperator">The Bounds2D right of the != operator</param>
            <returns>A boolean indicating whether or not the Bounds2D objects on both side of the != operator do NOT have equal Center and Extents properties (Note: Returns true in the presence of NaN values)</returns>
        </member>
        <member name="T:u040.prespective.math.PreSpectiveMath">
            <summary>
            @CLASS : PreSpectiveMath
            
            @ABOUT : Math utility functions for prespective
                     
            @AUTHOR : Bas, Tymen, Pieter (Unit040)
            
            @VERSION : 1.00 - Implemented mesh area calculation(17-01-2019)
            @VERSION : 1.10 - Implemented matrix calculation(25-03-2019)
            @VERSION : 1.11 - Implemented matrix add rotation bug fix of implementing the scale(25-03-2019)
            @VERSION : 1.12 - Added sum functions from prespective utility(25-04-2019)
            @VERSION : 1.13 - Implemented volume calculation from object filter(25-04-2019)
            @VERSION : 1.14 - Implemented making functions directly callable from variable(25-04-2019)
            @VERSION : 1.15 - Made mesh area and volume calculation double precision(26-04-2019)
            @VERSION : 1.20 - Imported the math functions from the u040.prespective.utility.Math class(02-10-2019)
            @VERSION : 1.30 - Imported the math functions from the u040.prespective.utility.dMath class(03-12-2019)
            @VERSION : 1.40 - Updated class based on unit tests and fixed XML tags(05-10-2021)
            </summary>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshArea(UnityEngine.MeshFilter)">
            <summary>
            Calculate the total area of a mesh in local space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <returns>The total area of a mesh in local space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshArea(UnityEngine.MeshFilter,System.Int32[])">
            <summary>
            Calculate the total area of a specified area of a mesh in local space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified area of a mesh in local space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshArea(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,UnityEngine.Vector3})">
            <summary>
            Calculate the total area of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type Vector3</param>
            <returns>The total area of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshArea(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3})">
            <summary>
            Calculate the total area of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type DVector3</param>
            <returns>The total area of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshArea(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,UnityEngine.Vector3},System.Int32[])">
            <summary>
            Calculate the total area of a specified part of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type Vector3</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified part of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshArea(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Int32[])">
            <summary>
            Calculate the total area of a specified part of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type DVector3</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified part of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshAreaGlobal(UnityEngine.MeshFilter)">
            <summary>
            Calculate the total area of a mesh in global space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <returns>The total area of a mesh in global space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshAreaGlobal(UnityEngine.MeshFilter,System.Int32[])">
            <summary>
            Calculate the total area of a specified area of a mesh in local space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified area of a mesh in local space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshAreaGlobal(UnityEngine.MeshFilter,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3})">
            <summary>
            Calculate the total area of a specified area of a mesh in local space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type DVector3</param>
            <returns>The total area of a specified area of a mesh in local space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.calculateAreaTriangle(System.Double[])">
            <summary>
            Calculate the area of a triangle
            </summary>
            <param name="_triangles">Array of triangles</param>
            <returns>The area of a triangle</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.calculateDistance(u040.prespective.math.doubles.DVector3[])">
            <summary>
            Calculate the distances between the vertices of a triangle
            </summary>
            <param name="_position">list of 3 verts</param>
            <returns>The distances between the vertices of a triangle</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.HeronTriangleSurface(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Calculates the surface of a triangle defined by 3 points using Heron's Formula
            </summary>
            <param name="_vertexA">First point/vertex of a triangle</param>
            <param name="_vertexB">Second point/vertex of a triangle</param>
            <param name="_vertexC">Third point/vertex of a triangle</param>
            <returns>The surface of a triangle defined by 3 points using Heron's Formula</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaCalculation(UnityEngine.MeshFilter)">
            <summary>
            Alternative way to calculate the total area of a mesh in local space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <returns>The total area of a mesh in local space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaCalculation(UnityEngine.MeshFilter,System.Int32[])">
            <summary>
            Alternative way to calculate the total area of a specified area of a mesh in local space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified area of a mesh in local space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaCalculation(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,UnityEngine.Vector3})">
            <summary>
            Alternative way to calculate the total area of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type Vector3</param>
            <returns>The total area of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaCalculation(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3})">
            <summary>
            Alternative way to calculate the total area of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type DVector3</param>
            <returns>The total area of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaCalculation(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,UnityEngine.Vector3},System.Int32[])">
            <summary>
            Alternative way to calculate the total area of a specified part of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type Vector3</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified part of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaCalculation(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Int32[])">
            <summary>
            Alternative way to calculate the total area of a specified part of a triangle list
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type DVector3</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified part of a triangle list</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaGlobalCalculation(UnityEngine.MeshFilter)">
            <summary>
            Alternative way to calculate the total area of a mesh in global space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <returns>The total area of a mesh in global space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AlternativeMeshAreaGlobalCalculation(UnityEngine.MeshFilter,System.Int32[])">
            <summary>
            Alternative way to calculate the total area of a specified area of a mesh in local space
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <param name="_triangleIndexList">Triangles index list</param>
            <returns>The total area of a specified area of a mesh in local space</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshVolumeGlobal(UnityEngine.MeshFilter)">
            <summary>
            Calculate the total area of a mesh
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <returns>The total area of a mesh</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CalculateMeshVolumeGlobal(UnityEngine.MeshFilter,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3})">
            <summary>
            Calculate the total area of a mesh
            </summary>
            <param name="_meshFilter">MeshFilter input</param>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices list of type DVector3</param>
            <returns>The total area of a mesh</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.GetVolume(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,UnityEngine.Vector3})">
            <summary>
            Calculates the volume of a set of triangles that form a mesh
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices of type Vector3</param>
            <returns>The volume of a set of triangles that form a mesh</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.GetVolume(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3})">
            <summary>
            Calculates the volume of a set of triangles that form a mesh
            </summary>
            <param name="_triangles">Triangles</param>
            <param name="_vertices">Vertices of type DVector3</param>
            <returns>The volume of a set of triangles that form a mesh</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.signedVolume(u040.prespective.math.doubles.DVector3[])">
            <summary>
            Calculates the volume for a single triangle
            </summary>
            <param name="_vertexArray">An array of three vertices for a single triangle</param>
            <returns>The volume for a single triangle</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CreateLocalToWorldMatrix(u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Creates the local to world matrix with a given global rotation, position and scale
            </summary>
            <param name="_rotation">Rotation of type DQuaternion</param>
            <param name="_position">Position of type DVector3</param>
            <param name="_scale">Scale of type DVector3</param>
            <returns>A matrix with the given global rotation, position and scale of type DMatrix4x4</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CreateLocalToWorldMatrix(UnityEngine.Quaternion,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Creates the local to world matrix with a given global rotation, position and scale
            </summary>
            <param name="_rotation">Rotation of type Quaternion</param>
            <param name="_position">Position of type Vector3</param>
            <param name="_scale">Scale of type Vector3</param>
            <returns>A matrix with the given global rotation, position and scale of type Matrix4x4</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddRotationToTransformMatrix(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion,u040.prespective.math.doubles.DVector3)">
            <summary>
            Adds a local or global rotation to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type DMatrix4x4</param>
            <param name="_rotation">Local or global rotation of type DQuaternion</param>
            <param name="_scale">Local scale of type DVector3</param>
            <returns>The local to world space matrix, of type DMatrix4x4, after the local or global rotation has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddRotationToTransformMatrix(UnityEngine.Matrix4x4,UnityEngine.Quaternion,UnityEngine.Vector3)">
            <summary>
            Adds a local or global rotation to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type Matrix4x4</param>
            <param name="_rotation">Local or global rotation of type Quaternion</param>
            <param name="_scale">Local scale of type Vector3</param>
            <returns>The local to world space matrix, of type Matrix4x4, after the local or global rotation has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddLocalTranslationToTransformMatrix(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DMatrix4x4)">
            <summary>
            Adds a local translation to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type DMatrix4x4</param>
            <param name="_translation">Translation of type DVector3</param>
            <param name="_parentMatrix">Matrix of the parent of this matrix of type DMatrix4x4</param>
            <returns>The local to world space matrix, of type DMatrix4x4, after the local translation has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddLocalTranslationToTransformMatrix(UnityEngine.Matrix4x4,UnityEngine.Vector3,UnityEngine.Matrix4x4)">
            <summary>
            Adds a local translation to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type Matrix4x4</param>
            <param name="_translation">Translation of type Vector3</param>
            <param name="_parentMatrix">Matrix of the parent of this matrix of type Matrix4x4</param>
            <returns>The local to world space matrix, of type Matrix4x4, after the local translation has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddGlobalTranslationToTransformMatrix(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DVector3)">
            <summary>
            Adds a global translation to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type DMatrix4x4</param>
            <param name="_translation">Translation of type DVector3</param>
            <returns>The local to world space matrix, of type DMatrix4x4, after the global translation has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddGlobalTranslationToTransformMatrix(UnityEngine.Matrix4x4,UnityEngine.Vector3)">
            <summary>
            Adds a global translation to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type Matrix4x4</param>
            <param name="_translation">Translation of type Vector3</param>
            <returns>The local to world space matrix, of type Matrix4x4, after the global translation has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddScaleToTransformMatrix(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DVector3)">
            <summary>
            Adds a change in scale to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type DMatrix4x4</param>
            <param name="_scaleFactor">Scaling factor of type DVector3</param>
            <returns>The local to world space matrix, of type DMatrix4x4, after the change in scale has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.AddScaleToTransformMatrix(UnityEngine.Matrix4x4,UnityEngine.Vector3)">
            <summary>
            Adds a change in scale to a local to world space matrix
            </summary>
            <param name="_matrix">Local to world matrix of type Matrix4x4</param>
            <param name="_scaleFactor">Scaling factor of type Vector3</param>
            <returns>The local to world space matrix, of type Matrix4x4, after the change in scale has been applied</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Sum(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Get the sum of a set of integers
            </summary>
            <param name="_array">Enumerable ints</param>
            <returns>The sum of a set of integers</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Sum(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Get the sum of a set of floats
            </summary>
            <param name="_array">Enumerable floats</param>
            <returns>The sum of a set of floats</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Sum(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Get the sum of a set of doubles
            </summary>
            <param name="_array">Enumerable doubles</param>
            <returns>The sum of a set of doubles</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>
            Calculates a binomial coefficient (n over k)
            </summary>
            <param name="_k">k</param>
            <param name="_n">n</param>
            <returns>The binomial coefficient (n over k)</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Factorial(System.Int32)">
            <summary>
            Get the factorial of n
            </summary>
            <param name="_n">n (n can range from 0 to 12)</param>
            <returns>The factorial of n</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.CwAngle(UnityEngine.Vector2,UnityEngine.Vector2)">
            <summary>
            Calculates the clockwise angle in radians between 2 vectors (expects the vectors to be normalized)
            </summary>
            <param name="_d1">first normalized vector</param>
            <param name="_d2">second normalized vector</param>
            <returns>angle in radians between 2 vectors</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.GetAngleInRadiansBetweenVectorsXZ(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Calculates the angle between two vectors in radians
            </summary>
            <param name="_vectorA">Vector 1 of type Vector3</param>
            <param name="_vectorB">Vector 2 of type Vector3</param>
            <returns>The angle between two vectors in radians as a float</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.GetAngleInRadiansBetweenVectorsXZ(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Calculates the angle between two vectors in radians
            </summary>
            <param name="_vectorA">Vector 1 of type DVector3</param>
            <param name="_vectorB">Vector 2 of type DVector3</param>
            <returns>The angle between two vectors in radians as a double</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.GetPlanarNormal(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            Get the normal direction for a plane between three points
            </summary>
            <param name="_vectorA">The first point/vector</param>
            <param name="_vectorB">The second point/vector</param>
            <param name="_vectorC">The third point/vector</param>
            <returns>The normal direction for a plane between three points</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.math.PreSpectiveMath.RandomNonMinMax(System.Single,System.Single)" -->
        <member name="M:u040.prespective.math.PreSpectiveMath.Round(System.Single,System.Int32)">
            <summary>
            Rounds the value _val to a specific number of decimals
            </summary>
            <param name="_value">The float to round</param>
            <param name="_decimals">The number of decimals</param>
            <returns>The value, of type float, rounded to a specific number of decimals</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Round(System.Double,System.Int32)">
            <summary>
            Rounds the value _val to a specific number of decimals
            </summary>
            <param name="_value">The double to round</param>
            <param name="_decimals">The number of decimals</param>
            <returns>The value, of type double, rounded to a specific number of decimals</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.FloatToString(System.Single)">
            <summary>
            Converts a float to a string
            </summary>
            <param name="_value">Float to convert</param>
            <returns>The float as a string</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.FloatFromString(System.String)">
            <summary>
            Converts a string to a float
            </summary>
            <param name="_floatString">String to convert</param>
            <returns>The string as a float</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.countCharInString(System.String,System.Char)">
            <summary>
            Counts the number of occurrences of a given char within a given string
            </summary>
            <param name="_string">String to check</param>
            <param name="_char">Char to count</param>
            <returns>The number of occurrences of a given char within a given string</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.RandomStringSeed(System.Int32)">
            <summary>
            Returns a random integer as string with _length characters
            </summary>
            <param name="_length">The length of the seed</param>
            <returns>A random integer as string with _length characters</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.RandomIntSeed(System.Int32)">
            <summary>
            Returns a random integer with _length characters
            </summary>
            <param name="_length">The length of the seed</param>
            <returns>A random integer with _length characters</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.LimitMinMax(System.Int32,System.Int32,System.Int32)">
            <summary>
            Move an integer within a range with a modulo operator if the value is outside a given range
            </summary>
            <param name="_value">Value of type integer</param>
            <param name="_min">Minimum value of type integer</param>
            <param name="_max">Maximum value of type integer</param>
            <returns>An integer between a given min and max value</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.LimitMinMax(System.Single,System.Single,System.Single)">
            <summary>
            Move an float within a range with a modulo operator if the value is outside a given range
            </summary>
            <param name="_value">Value of type float</param>
            <param name="_min">Minimum value of type float</param>
            <param name="_max">Maximum value of type float</param>
            <returns>A float between a given min and max value</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.LimitMinMax(System.Double,System.Double,System.Double)">
            <summary>
            Move a double within a range with a modulo operator if the value is outside a given range
            </summary>
            <param name="_value">Value of type double</param>
            <param name="_min">Minimum value of type double</param>
            <param name="_max">Maximum value of type double</param>
            <returns>A double between a given min and max value</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.ToDouble(UnityEngine.Quaternion)">
            <summary>
            Convert a Quaternion to a DQuaternion that uses doubles for higher accuracy
            </summary>
            <param name="_floatQuaternion">Quaternion to convert</param>
            <returns>A DQuaternion that was copied from the given Quaternion</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.ToDouble(UnityEngine.Vector2)">
            <summary>
            Convert a Vector2 to a DVector2 that uses doubles for higher accuracy
            </summary>
            <param name="_floatVector2">Vector2 to convert</param>
            <returns>A DVector2 that was copied from the given Vector2</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.ToDouble(UnityEngine.Vector3)">
            <summary>
            Convert a Vector3 to a DVector3 that uses doubles for higher accuracy
            </summary>
            <param name="_floatVector3">Vector3 to convert</param>
            <returns>A DVector3 that was copied from the given Vector3</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.ToDouble(UnityEngine.Vector4)">
            <summary>
            Convert a Vector4 to a DVector4 that uses doubles for higher accuracy
            </summary>
            <param name="_floatVector4">Vector4 to convert</param>
            <returns>A DVector4 that was copied from the given Vector4</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.ToDouble(UnityEngine.Bounds)">
            <summary>
            Convert a Bounds to a DBounds that uses doubles for higher accuracy
            </summary>
            <param name="_floatBounds">Bounds to convert</param>
            <returns>A DBounds that was copied from the given Bounds</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.ToDouble(UnityEngine.Matrix4x4)">
            <summary>
            Convert a Matrix4x4 to a DMatrix4x4 that uses doubles for higher accuracy
            </summary>
            <param name="_floatMatrix">Matrix4x4 to convert</param>
            <returns>A DMatrix4x4 that was copied from the given Matrix4x4</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.IntPow(System.Int32,System.UInt32)">
            <summary>
            Calculates a specified number raised to the specified power for integers. (Does not work for negative powers!)
            </summary>
            <param name="_x">the specified number</param>
            <param name="_power">the specified power</param>
            <returns>outcome of _x ^ _power as an integer</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.QuadraticFormula(System.Double,System.Double,System.Double)">
            <summary>
            Calculate the intersection points on a line based on the quadratic formula
            </summary>
            <param name="_a">The first of the numerical coefficients</param>
            <param name="_b">The second of the numerical coefficients</param>
            <param name="_c">The third of the numerical coefficients</param>
            <returns>Returns one or two intersection points based on the given inputs</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.IsPointInPolygon(u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Check if a given point is inside a polygon
            </summary>
            <param name="_point">Point to check</param>
            <param name="_polygon">Polygon to check</param>
            <returns>A boolean indicating if the given point was inside the given polygon</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.IsPointOnPolygonXZPlane(u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            Check if a given point is on the x-z plane of a given polygon
            </summary>
            <param name="_point">Point to check</param>
            <param name="_vertices">Polygon to check</param>
            <returns>A boolean indicating if the given point was on the x-z plane of the given polygon</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.getOnWhichSidePointIsOfLine(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            Check on which side a given point is of a given line on the x-z plane
            </summary>
            <param name="_lineStartPoint">Starting point of the line</param>
            <param name="_lineEndPoint">End point of the line</param>
            <param name="_pointToCheck">Point to check</param>
            <returns>An integer that is 1 when the given point is on the left side, 0 when the given point is on the line and -1 when the point is on the right side</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.IsPointOnLineSection(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Double)">
            <summary>
            Check if a given point is on a given line
            </summary>
            <param name="_lineStartPoint">Starting point of the line</param>
            <param name="_lineEndPoint">End point of the line</param>
            <param name="_pointToCheck">Point to check</param>
            <param name="_margin">margin to check in</param>
            <returns>A boolean indicating if the given point was on the given line</returns>
        </member>
        <member name="F:u040.prespective.math.PreSpectiveMath.RADIANS_TO_DEGREES">
            <summary>
            Radians to degrees
            </summary>
        </member>
        <member name="F:u040.prespective.math.PreSpectiveMath.DEGREES_TO_RADIANS">
            <summary>
            Degrees to radians
            </summary>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Clamp a double between a minimum and maximum value
            </summary>
            <param name="_value">Value to clamp</param>
            <param name="_min">Minimum value</param>
            <param name="_max">Maximum value</param>
            <returns>A clamped double</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.ClampBetween0And1(System.Double)">
            <summary>
            Clamp a double between 0 and 1
            </summary>
            <param name="_value">Double to clamp</param>
            <returns>A clamped double between 0 and 1</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.InRange(System.Double,System.Double,System.Double)">
            <summary>
            Check whether a value lies within a certain range
            </summary>
            <param name="_value">Value to check</param>
            <param name="_min">Lowest value of range</param>
            <param name="_max">Highest value of range</param>
            <returns>A boolean indicating if the value is within the given range</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.IsBetween(System.Double,System.Double,System.Double)">
            <summary>
            Check whether a value is larger than the minimum or smaller than the maximum
            </summary>
            <param name="_value">Value to test</param>
            <param name="_min">Minimum value</param>
            <param name="_max">Maximum value</param>
            <returns>A boolean indicting if the value is between the minimum or maximum values (will return false if equal to either)</returns>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Min(System.Double,System.Double)">
            <summary>
            Returns the smallest of two values
            </summary>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.Max(System.Double,System.Double)">
            <summary>
            Returns the largest of two values
            </summary>
        </member>
        <member name="M:u040.prespective.math.PreSpectiveMath.GetPointInRange(System.Double,System.Double,System.Double)">
            <summary>
            Find a point in a range based on mapping a value to a given range (Ex.: for 0.5 between range 10 to 20 would be 15)
            </summary>
            <param name="_start">Start of range</param>
            <param name="_end">End of range</param>
            <param name="_pointInRange">Point to get in range when between 0 and 1</param>
            <returns>A point in the range based on the given input value</returns>
        </member>
        <member name="T:u040.prespective.math.Matrix4x4Utility">
            <summary>
            Function library with non-affine matrix math, primarily for AR (originally for hololens)
            </summary>
        </member>
        <member name="M:u040.prespective.math.Matrix4x4Utility.ExtractTranslationFromMatrix(UnityEngine.Matrix4x4@)">
            <summary>
            Extract translation from transform matrix.
            </summary>
            <param name="matrix">Transform matrix. This parameter is passed by reference
            to improve performance; no changes will be made to it.</param>
            <returns>
            Translation offset.
            </returns>
        </member>
        <member name="M:u040.prespective.math.Matrix4x4Utility.ExtractRotationFromMatrix(UnityEngine.Matrix4x4@)">
            <summary>
            Extract rotation quaternion from transform matrix.
            </summary>
            <param name="matrix">Transform matrix. This parameter is passed by reference
            to improve performance; no changes will be made to it.</param>
            <returns>
            Quaternion representation of rotation transform.
            </returns>
        </member>
        <member name="M:u040.prespective.math.Matrix4x4Utility.ExtractScaleFromMatrix(UnityEngine.Matrix4x4@)">
            <summary>
            Extract scale from transform matrix.
            </summary>
            <param name="matrix">Transform matrix. This parameter is passed by reference
            to improve performance; no changes will be made to it.</param>
            <returns>
            Scale vector.
            </returns>
        </member>
        <member name="M:u040.prespective.math.Matrix4x4Utility.DecomposeMatrix(UnityEngine.Matrix4x4@,UnityEngine.Vector3@,UnityEngine.Quaternion@,UnityEngine.Vector3@)">
            <summary>
            Extract position, rotation and scale from TRS matrix.
            </summary>
            <param name="matrix">Transform matrix. This parameter is passed by reference
            to improve performance; no changes will be made to it.</param>
            <param name="localPosition">Output position.</param>
            <param name="localRotation">Output rotation.</param>
            <param name="localScale">Output scale.</param>
        </member>
        <member name="M:u040.prespective.math.Matrix4x4Utility.SetTransformFromMatrix(UnityEngine.Transform,UnityEngine.Matrix4x4@)">
            <summary>
            Set transform component from TRS matrix.
            </summary>
            <param name="transform">Transform component.</param>
            <param name="matrix">Transform matrix. This parameter is passed by reference
            to improve performance; no changes will be made to it.</param>
        </member>
        <member name="M:u040.prespective.math.Matrix4x4Utility.rigidTransform(System.Collections.Generic.List{UnityEngine.Vector3},System.Collections.Generic.List{UnityEngine.Vector3},System.Collections.Generic.List{System.Single},UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>
            rigid transform between points p and q with weighting
            </summary>
            <param name="_p">list of points</param>
            <param name="_q">list of points</param>
            <param name="_weights">weighting to points</param>
            <param name="_translation">vector difference between weighted centre points</param>
            <param name="_wcP">weighted centre point p</param>
            <param name="_wcQ">weighted centre point q</param>
            <param name="_rQ"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.DateAndTime">
            <summary>
            @CLASS: DateAndTime
            
            @ABOUT: Static library class for commonly used date and time data types
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: 1.00 - Base implementation taken from Frijado v2.0
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.DateAndTime.GetTimeStampString(System.String,System.String)">
            <summary>
            Retrieves the descriptive string in accordance to the _regExp from the timeStamp _tstamp
            </summary>
            <param name="_tstamp">14 character description of a time: YYYYMMDDhhmmss</param>
            <param name="_regExp">string buildup expected as output (see function content)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DateAndTime.GetDateFromTimeStamp(System.String)">
            <summary>
            Creates a DateTime object from a timeStamp string
            </summary>
            <param name="_tstamp">14 character description of a time: YYYYMMDDhhmmss</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DateAndTime.TimeStampStringFromDateTime(System.DateTime)">
            <summary>
            Creates a TimeStamp string from a DateTime object
            </summary>
            <param name="_d">the DateTime object</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.ObjectNesting">
            <summary>
            @STRUCT : ObjectNesting
            
            @ABOUT : Struct used to register the location of a nested object within a string to be deserialized
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: V1.00 - 19/06/2018 - First implementation for used in PreSpective
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.ObjectNesting.start">
            <summary>
            index of the starting character of this nested object
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.ObjectNesting.end">
            <summary>
            Index of the finishing character of this nested object
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.ObjectNesting.nesting">
            <summary>
            Nesting level of this object - 0 is the root object level
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.ObjectNesting.parent">
            <summary>
            Parent index in the nesting registry (assigned externally)
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.ObjectNesting.index">
            <summary>
            Own index on creation (assigned externally)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:u040.prespective.utility.serialization.DSerKey" -->
        <member name="F:u040.prespective.utility.serialization.DSerKey.LABEL_SPLIT">
            <summary>
            Character used to split the different deserialization key (label) parts
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.DSerKey.key">
            <summary>
            Actual name of this serialized key/field
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.DSerKey.type">
            <summary>
            Index found for the type of this key
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.DSerKey.index">
            <summary>
            Index of this key within a collection
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.DSerKey.isKey">
            <summary>
            Wether we are dealing with a key (or false = value) part of a named collection
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.DSerKey.#ctor(System.String)">
            <summary>
            string serialized based constructor of the serialization key
            </summary>
            <param name="_serializedKey">string serialized key value</param>
        </member>
        <member name="M:u040.prespective.utility.serialization.DSerKey.#ctor(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            parameter based constructor
            </summary>
            <param name="_key">Actual name of this serialized key/field </param>
            <param name="_type">Index found for the type of this key</param>
            <param name="_index">Index of this key within a collection/enumeration, -1 if not part of a collection/enumeration</param>
            <param name="_kv">Wether we are dealing with a key (or false = value) part of a named collection</param>
        </member>
        <member name="M:u040.prespective.utility.serialization.DSerKey.ToString">
            <summary>
            Outputs/serializes this DSERKEY as string
            </summary>
            <returns>Serialized version of this key</returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DSerKey.keyString(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Object bypass for the key generator - note that the results must match with the ToString function!
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DSerKey.Equals(System.Object)">
            <summary>
            Equality override (by string)
            </summary>
            <param name="obj">the object to compare with</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DSerKey.GetHashCode">
            <summary>
            Hashkey override
            </summary>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.SerializableCurve">
            <summary>
            @CLASS : SerializableCurve
            
            @ABOUT : Serializable variant of the UnityEngine Animation Curve
                     The Animation Curve is somewhat of a curiosity, it inherits system.object; but CANNOT be casted/boxed as one
                     
                     To allow Animation Curves to be (de-)serialized (to be used as an target for implicit inspector setting) it must be converted to Serializable Curve
                     
                     This implementation is based on the solution found here:
                     https://gamedev.stackexchange.com/questions/119808/how-to-saving-and-loading-animation-curves
                     
            @AUTHOR : Pieter (Unit040)
            
            @VERSION: V1.00 - 08/08/2018 - Implemented to support Implicit Animation Curve Fields in the Unity Inspector
            </summary>
        </member>
        <member name="T:u040.prespective.utility.serialization.InheritedTypeOptions`1">
            <summary>
            Class to populate a list with options available as overrides for a particular class
            (this list is generated lazily at runtime; use to get an overview of options as override for a particular monobehavior, etc.)
            </summary>
            <typeparam name="T">the baseclass to look for overrides of</typeparam>
        </member>
        <member name="F:u040.prespective.utility.serialization.InheritedTypeOptions`1.DefaultOption">
            <summary>
            base type
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.InheritedTypeOptions`1.#ctor(System.Type,System.Boolean)">
            <summary>
            constructor
            </summary>
            <param name="_defaultOption"></param>
        </member>
        <member name="P:u040.prespective.utility.serialization.InheritedTypeOptions`1.SelectedOptionType">
            <summary>
            The selected sequence type to create, should be 'ScenarioSequence' by default 
            </summary>
        </member>
        <member name="P:u040.prespective.utility.serialization.InheritedTypeOptions`1.OptionTypeNames">
            <summary>
            All the names of the types inherited from type T
            </summary>
        </member>
        <member name="P:u040.prespective.utility.serialization.InheritedTypeOptions`1.OptionTypes">
            <summary>
            All types inherited from type T
            </summary>
        </member>
        <member name="T:u040.prespective.utility.serialization.CILUtility">
            <summary>
            utillity class to use reflection but faster with CIL.
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.GetValue(System.Object,System.String)">
            <summary>
            Get the value of a member by the Type and name.
            </summary>
            <param name="_name">The name of the member, for example the testField on this CILTestScript</param>
            <param name="_object">The object on which to search</param>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.GetValue(System.Object,System.Type@,System.String)">
            <summary>
            Set the value of a member by the Type and name.
            </summary>
            <param name="_object">The object on which to search</param>
            <param name="_type">Input will be the Type of class on which the member resides, the out will be the type of the parameter</param>
            <param name="_name">The name of the member</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.SetValue(System.Object,System.String,System.Object)">
            <summary>
            Sets a value by the name
            </summary>
            <param name="_object">Object on which to set the member</param>
            <param name="_name">Name of the member to set</param>
            <param name="_value">Value to set</param>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.GenerateGetMemberDelegate(System.Type,System.String)">
            <summary>
            Generates a delete with which you can Get the value.
            This way you can cache it.
            </summary>
            <example>
            <code>
                GenerateGetMemberDelegate(_type, _name)(_object);
            </code>
            </example>>
            <param name="_type">The type of the object on which the member resides</param>
            <param name="_name">The name of the member</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.GenerateSetMemberDelegate(System.Type,System.String)">
            <summary>
            Generates a delete with which you can Set the value.
            This way you can cache it.
            </summary>
            <example>
            <code>
                GenerateSetMemberDelegate(_object.GetType(), _name)(_object, _value);
            </code>
            </example>>
            <param name="_type">The type of the object on which the member resides</param>
            <param name="_name">The name of the member</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.CallVoidMethod(System.Object,System.String)">
            <summary>
            Calls a void method by the _name of that method and the _object on which to call the method 
            </summary>
            <param name="_object">Object on which to call the method</param>
            <param name="_name">The name of the method to call (case sensitive)</param>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.CallVoidMethod(System.Object,System.String,System.Object[])">
            <summary>
            Calls a method with parameters on the _object by the _name with the parameters 
            </summary>
            <param name="_object">Object on which to call</param>
            <param name="_name">The name of the method</param>
            <param name="_parameters">The parameters to call the method with</param>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.GenerateVoidMethodDelegate(System.Object,System.String)">
            <summary>
            Generate a delegate to call a void method on the _object with the _name
            </summary>
            <param name="_object">Object on which to call the method</param>
            <param name="_name">Name of the method</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetFuncMethodInterface(System.Object,System.String,u040.prespective.utility.serialization.FuncMethodInterface@,System.Type[],System.Reflection.BindingFlags)">
            <summary>
            Returns a Function Method Interface (i.e. injector interface for a method returning a value)
            After creation this interface can be used to call a function method on the target instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            </summary>
            <param name="_object">the instance to create the interface for</param>
            <param name="_methodName">the name of the function method to create an interface for</param>
            <param name="_fmInterface">output interface object</param>
            <param name="_prefferedParams">optional set with preffered parameters; should match with one of the overloads (for overload selection)</param>
            <param name="_bindingFlags">optionally the bindingflags to use in function selection (by default set to instance, (non-)public</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetFuncMethodInterface(System.String,System.Type,u040.prespective.utility.serialization.FuncMethodInterface@,System.Type[],System.Reflection.BindingFlags)">
            <summary>
            Returns a Function Method Interface (i.e. injector interface for a method returning a value)
            After creation this interface can be used to call a function method on the target instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            (NOTE : this variant of the function does not set the target, you will need to do that yourself)
            
            </summary>
            <param name="_methodName">the name of the function method to create an interface for</param>
            <param name="_type">the class type that contains the function</param>
            <param name="_fmInterface">output interface object</param>
            <param name="_prefferedParams">optional set with preffered parameters; should match with one of the overloads (for overload selection)</param>
            <param name="_bindingFlags">optionally the bindingflags to use in function selection (by default set to instance, (non-)public</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetVoidMethodInterface(System.Object,System.String,u040.prespective.utility.serialization.VoidMethodInterface@,System.Type[],System.Reflection.BindingFlags)">
            <summary>
            Returns a Void Method Interface (i.e. injector interface for a method returning NO value)
            After creation this interface can be used to call a function method on the target instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            </summary>
            <param name="_object">the instance to create the interface for</param>
            <param name="_methodName">the name of the function method to create an interface for</param>
            <param name="_vmInterface">output interface object</param>
            <param name="_prefferedParams">optional set with preffered parameters; should match with one of the overloads (for overload selection)</param>
            <param name="_bindingFlags">optionally the bindingflags to use in function selection (by default set to instance, (non-)public</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetVoidMethodInterface(System.String,System.Type,u040.prespective.utility.serialization.VoidMethodInterface@,System.Type[],System.Reflection.BindingFlags)">
            <summary>
            Returns a Void Method Interface (i.e. injector interface for a method returning NO value)
            After creation this interface can be used to call a function method on the target instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            (NOTE : this variant of the function does not set the target, you will need to do that yourself)
            
            </summary>
            <param name="_methodName">the name of the function method to create an interface for</param>
            <param name="_type">the class type that contains the function</param>
            <param name="_vmInterface">output interface object</param>
            <param name="_prefferedParams">optional set with preffered parameters; should match with one of the overloads (for overload selection)</param>
            <param name="_bindingFlags">optionally the bindingflags to use in function selection (by default set to instance, (non-)public</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetMemberInterface(System.Object,System.String,u040.prespective.utility.serialization.MemberInterface@,System.Reflection.BindingFlags)">
            <summary>
            Returns a Member interface (for getting/setting properties and fields within a class instance)
            After creation this interface can be used to inject/observe an instance member
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            </summary>
            <param name="_object">the instance to create the interface for</param>
            <param name="_memberName">the name of the member to create an interface for</param>
            <param name="_interface">output interface object</param>
            <param name="_bindingFlags">optionally the bindingflags to use in member selection (by default set to instance, (non-)public</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetMemberInterface(System.String,System.Type,u040.prespective.utility.serialization.MemberInterface@,System.Reflection.BindingFlags)">
            <summary>
            Returns a Member interface (for getting/setting properties and fields within a class instance)
            After creation this interface can be used to inject/observe an instance member
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            (NOTE : this variant of the function does not set the target, you will need to do that yourself)
            
            </summary>
            <param name="_memberName">the name of the member to create an interface for</param>
            <param name="_type">the class type that contains the function</param>
            <param name="_interface">output interface object</param>
            <param name="_bindingFlags">optionally the bindingflags to use in member selection (by default set to instance, (non-)public</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetMemberSetter(System.Object,System.String,u040.prespective.utility.serialization.DynamicCIL.MemberSetterDelegate@,System.Reflection.BindingFlags)">
            <summary>
            Returns a delegate specific for setting a member (fields/properties) in an instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms))
            
            </summary>
            <param name="_target">the instance to create the interface for</param>
            <param name="_memberName">the name of the member to create an interface for</param>
            <param name="_setter">output setter delegate</param>
            <param name="_bindingFlags">optionally the bindingflags to use in member selection (by default set to instance, (non-)public</param>
            <returns></returns>    
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetMemberSetter(System.String,System.Type,u040.prespective.utility.serialization.DynamicCIL.MemberSetterDelegate@,System.Reflection.BindingFlags)">
            <summary>
            Returns a delegate specific for setting a member (fields/properties) in an instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            (NOTE : this variant of the function does not set the target, you will need to do that yourself)
            
            </summary>
            <param name="_memberName">the name of the member to create an interface for</param>
            <param name="_type">the class type that contains the member</param>
            <param name="_setter">output setter delegate</param>
            <param name="_bindingFlags">optionally the bindingflags to use in member selection (by default set to instance, (non-)public</param>
            <returns></returns>    
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetMemberGetter(System.Object,System.String,u040.prespective.utility.serialization.DynamicCIL.MemberGetterDelegate@,System.Reflection.BindingFlags)">
            <summary>
            Returns a delegate specific for getting a member (fields/properties) in an instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms))
            
            </summary>
            <param name="_target">the instance to create the interface for</param>
            <param name="_memberName">the name of the member to create an interface for</param>
            <param name="_getter">output getter delegate</param>
            <param name="_bindingFlags">optionally the bindingflags to use in member selection (by default set to instance, (non-)public</param>
            <returns></returns> 
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetMemberGetter(System.String,System.Type,u040.prespective.utility.serialization.DynamicCIL.MemberGetterDelegate@,System.Reflection.BindingFlags)">
            <summary>
            Returns a delegate specific for getting a member (fields/properties) in an instance object
            
            (Note : this function makes use of CIL for efficiency, but may not work on AOT platforms)
            (NOTE : this variant of the function does not set the target, you will need to do that yourself)
            
            </summary>
            <param name="_memberName">the name of the member to create an interface for</param>
            <param name="_type">the class type that contains the member</param>
            <param name="_getter">output getter delegate</param>
            <param name="_bindingFlags">optionally the bindingflags to use in member selection (by default set to instance, (non-)public</param>
            <returns></returns> 
        </member>
        <member name="M:u040.prespective.utility.serialization.CILUtility.TryGetClassMember(System.Type,System.String,System.Reflection.MemberInfo@,System.Reflection.BindingFlags)">
            <summary>
            Function used to retrieve the preffered member by name from a class
            </summary>
            <param name="_type">the type to evaluate for the member</param>
            <param name="_memberName">the name to look for</param>
            <param name="_memInfo">the resulting memberInfo object</param>
            <param name="_bindingFlags">optionally the bindingflags to use in member selection (by default set to instance, (non-)public</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.FuncMethodInterface">
            <summary>
            @CLASS : FuncMethodInterface
            
            @ABOUT : Support class for maintaining a single function method interface (i.e. a method returning a value)
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION:v1.00 - 10/04/2019 - Implementation with basic functionalities
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.FuncMethodInterface.Invoke(System.Object)">
            <summary>
            
            </summary>
            <param name="_param"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.FuncMethodInterface.Invoke(System.Object[])">
            <summary>
            
            </summary>
            <param name="_params"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.VoidMethodInterface">
            <summary>
            @CLASS : VoidMethodInterface
            
            @ABOUT : Support class for maintaining a single function method interface (i.e. a method returning NO value)
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION:v1.00 - 10/04/2019 - Implementation with basic functionalities
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.VoidMethodInterface.Invoke(System.Object)">
            <summary>
            
            </summary>
            <param name="_param"></param>
        </member>
        <member name="M:u040.prespective.utility.serialization.VoidMethodInterface.Invoke(System.Object[])">
            <summary>
            
            </summary>
            <param name="_params"></param>
        </member>
        <member name="T:u040.prespective.utility.serialization.MemberInterface">
            <summary>
            @CLASS : MemberInterface
            
            @ABOUT : Support class for maintaining a single member interface (i.e. an interface for setting and getting a property or field)
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION:v1.00 - 10/04/2019 - Implementation with basic functionalities
            </summary>
        </member>
        <member name="P:u040.prespective.utility.serialization.MemberInterface.Value">
            <summary>
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:u040.prespective.utility.serialization.SerializationUtility" -->
        <member name="F:u040.prespective.utility.serialization.SerializationUtility.SERIAL_KEY_PREFIX">
            <summary>
            Prefix used for all custom keys (used for aligning collection types)
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility.SERIAL_TYPE_PREFIX">
            <summary>
            Prefix used for the type definition at the start of a u040-JSON string
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility.SERIAL_BODY_PREFIX">
            <summary>
            Prefix used for the body definition at the start of the u040-JSON string body part
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility.SERIAL_KEY_SPLITTER">
            <summary>
            Key Splitter for splitting Prefix, index and optional value or key indication within the u040-JSON string
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility.SERIAL_NULL">
            <summary>
            Indicator for a NULL value in a u040-JSON string
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.DeserializeObject(System.String,u040.prespective.utility.serialization.SerializationFormat,System.Int32)">
            <summary>
            Control function - Deserialize an object based on a string
            </summary>
            <param name="_serialString">string containing the object description</param>
            <param name="_f">formatting expected on this serialized string</param>
            <param name="_useNCores">how many cores to use for deserialization (NOT YET IMPLEMENTED)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.DeserializeU040JSONObject(System.String,System.Int32)">
            <summary>
            Deserialize an object as u040JSON object
            </summary>
            <param name="_serialString">string containing the serialized object</param>
            <param name="_useNCores">how many cores to use (NOT YET IMPLEMENTED)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.deserializeObjectStringPart(System.String,System.Collections.Generic.List{System.Type},System.Collections.Generic.List{u040.prespective.utility.serialization.ObjectNesting}@,System.Collections.Generic.Dictionary{System.Int32,System.Object[]}@,UnityEngine.Vector2Int[]@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Deserialize the nested objects found in _dataPart; this is achieved by itteratively first deserializing the contained objects
            </summary>
            <param name="_dataPart">string containing this object instances definitions</param>
            <param name="_typeLib">Type library, to allow casting by index</param>
            <param name="_nestedHierarchy">list with object nesting descriptions</param>
            <param name="_deserializedObjects">List with objects deserialized in previous parts</param>
            <param name="_ignoredSections">array of stringparts that have been ignored (may contain broken objects)</param>
            <param name="_incompleteObjects">indicators for potentially broken objects that were deserialized (references indexes)</param>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.deserializeBaseObject(System.String,System.Collections.Generic.List{System.Type},System.Collections.Generic.Dictionary{System.String,System.Object},System.Nullable{u040.prespective.utility.serialization.DSerKey}@)">
            <summary>
            Deserializes the baseobject contained in the u040-Json
            </summary>
            <param name="_data">string describing the base object</param>
            <param name="_tl">type library</param>
            <param name="_params">pre-deserialized object (parameters)</param>
            <param name="_fd">the body serialization key of the baseobject (if any)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.TrySortDictionaryKeysSeperately(System.String[],UnityEngine.Vector2Int[]@,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Function added to sort dictionary keys keeping the 2 key variants in mind - (Fix for Dictionary Serialization issue  20/11/2020 @ PWS)
            
            1st variant '$:TypeIndex(int):RecordIndex(int):IsKey(int)' - This variant is ued in for instance the Prelogic Simulator Settings
            2nd Variant 'RecordIndex(int):IsKey(bool)' - This variant is used in for instance the WorkbookAdapterOwner (settings)
            
            Why 2 variants exists is kind of unclear to me (I can't recall creating 2 versions?) - but with this intermediate filter the dictionary serialization issue seems to be resolved
            </summary>
            <param name="_keys">the Keys for the records found - must match either 1st or second abovementioned variants</param>
            <param name="KeyValueFit">Vector2int describing the key-value fit x = keyIndex in keys arrray, y = valueIndex in keys array, -1 means not found</param>
            <param name="propertyBag">the values we're working with, only forwarded for debugging</param>
            <returns>whether any keys and values could be connected</returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.createCollection(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object},System.Object@)">
            <summary>
            Create a Collection from a deserialized collection string
            </summary>
            <param name="type">the type of collection to create</param>
            <param name="propertyBag">the objects contained as indices</param>
            <param name="_collection">the returned collection object on success</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.isolateDataPart(System.String,u040.prespective.utility.serialization.DSerKey@)">
            <summary>
            Isolate the u040-JSON data/body part of the string
            </summary>
            <param name="_dataPart">contents of the u040-JSON body part</param>
            <param name="_bodyKey">primary body descriptor key (for final typecast)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.deSerializeTypeLib(System.String)">
            <summary>
            Deserialize the type lib string to a list of System.Types for explicit instatiation
            </summary>
            <param name="_libPart">the string with the libpart of the u040-JSON string</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.indexNestedObjects(System.String,UnityEngine.Vector2Int[]@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
            Loops through the _objectPart string by character, and splits the nested objects by enclosing characters
            </summary>
            <param name="_objectPart">string to loop through</param>
            <param name="_ignored">part from the string that was ignored, and may thus contain poorly encoded/broken objects</param>
            <param name="_incomplete">the incomplete objects encountered (refering to their indexes in the _object part list</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.CreateObject(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Instantiates an object of type, based on provided properties
            </summary>
            <param name="type">the type of object to instantiate</param>
            <param name="propertyBag">instance property values referenced by field</param>
            <returns>instantiated object</returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.createReferenceTypeObject(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Creates an instance of a reference type (i.e. c# Class) based on the values in the propertybag
            </summary>
            <param name="type">type to create</param>
            <param name="propertyBag">values to base the instance on</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.createValueTypeObject(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Create an instance of a Value type - This should prefferably use a constructor that fully defines the type (since VT do not allow you to set instance fields after creation)
            </summary>
            <param name="type">type to create</param>
            <param name="propertyBag">values to base the instance on</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.findBestFitCtor(System.Type,System.Collections.Generic.Dictionary{System.String,System.Object}@,System.Boolean,System.Boolean,System.Reflection.ConstructorInfo@,System.Object[]@)">
            <summary>
            Attempt to find the constructor best fitting the type instance to be created
            </summary>
            <param name="_toConstruct">The type to construct</param>
            <param name="_paramValuesByName">Dictionary with keys and value objects</param>
            <param name="_favourComplete">whether to favour more complete constructors (more params, desirable when dealing with value types)</param>
            <param name="_removeCtorParams">whether to remove the parameters used by the constructor</param>
            <param name="_bfCtor">the output best fit constructor</param>
            <param name="_params">the output best fit constructor params</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.getValueParamMatchByName(System.String,System.String,System.Single)">
            <summary>
            Match a constructor parameter with a property by name; evaluate the fit as a float [0 - 1f]
            </summary>
            <param name="_paramName">the constructor parameter name</param>
            <param name="_ValueName">the property value name (likely field name)</param>
            <param name="_defaultChance">base chance this parameter and property have</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.SerializeObject(System.Object,u040.prespective.utility.serialization.SerializationFormat)">
            <summary>
            Serialize an object to a prespecified Serialized Format
            </summary>
            <param name="_o">object to serialize</param>
            <param name="_f">format to result the object in</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.SerializeU040JSON(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Serialize an object as u040-JSON string
            </summary>
            <param name="_subSer">Dictionary of nested objects by keyname</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.getTypeIndex(System.Type,System.Collections.Generic.List{System.Type})">
            <summary>
            Retrieves the index of a type in the list of recorded types
            returns -1 if not found
            </summary>
            <param name="_tt">the type to evaluate</param>
            <param name="_types">List of found Types</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.isRefAliasType(System.Type,u040.prespective.utility.serialization.BaseTypeDef@)">
            <summary>
            Determines if type _t is Reference Alias Type (e.g. component)
            </summary>
            <param name="_t">the type to evaluate</param>
            <param name="_def">the Reference Alias Type Definition</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.SubSerializeObject(System.Object,System.Collections.Generic.List{System.Type}@,System.Int32@,System.Type,System.Int32)">
            <summary>
            Serialize a nested object
            </summary>
            <param name="_o">object instance to serialize</param>
            <param name="_serializedTypes">encountered serialized types, used to generate the type library</param>
            <param name="_tIndex">type index found for this object (type library); used in creating the key in the parent</param>
            <param name="_forceAsType">whether we want to force serialization of this object as a particular type</param>
            <param name="_nLevel">serialization level (self-reference infinite-loop safety measure)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.SubSerializeCollection(System.Type,System.Object,System.Object@,System.Collections.Generic.List{System.Type}@,System.Int32)">
            <summary>
            Serialize a nested Collection object
            </summary>
            <param name="_t">the type of the collection to serialize</param>
            <param name="_in">the instance of the collection to serialize</param>
            <param name="_serializedCollection">serialized version of the collection</param>
            <param name="_serializedTypes">encountered serialized types, used to generate the type library</param>
            <param name="_nLevel">serialization level (self-reference infinite-loop safety measure)</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility.SERIAL_CUSTOM_ENCODINGS">
            <summary>
            Custom encoding settings used when serialing from/to a u040-JSON string
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.serializeCustom(System.String)">
            <summary>
            Serialize a string, accounting for custom characters to be replaced (for transit)
            </summary>
            <param name="_in">string to be serialized</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.deserializeCustom(System.String)">
            <summary>
            Deserialize a string, replacing custom characters replaced in serialization (for transit)
            </summary>
            <param name="_in"></param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility._typeRegistry">
            <summary>
            Private buffer for types used in deserialization
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.GetTypeFromRegistery(System.String)">
            <summary>
            Generator function for getting type references by name
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.GetInheritingTypes(System.Type,System.Boolean)">
            <summary>
            Retrieve all types that are based on the _baseType
            </summary>
            <param name="_baseType">the type to look for as parent</param>
            <param name="_allowSelf">whether or not the type itself should be returned</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.GetTypeAdvanced(System.String)">
            <summary>
            Function used to find a type by name
            </summary>
            <param name="typeName">the (full-)name of the type to look for</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.IsAssignableToGenericType(System.Type,System.Type)">
            <summary>
            Returns true if a given type is assignable to a generic base type
            </summary>
            <param name="_givenType">The given type</param>
            <param name="_genericBaseType">The generic base type, passed without specifying the generic type parameter</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility._serialRecipes">
            <summary>
            Private buffer with serialization recipes
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.getSerializationRecipe(System.Type)">
            <summary>
            Generator for getting a dictionary with serialization functions for a specific type
            </summary>
            <param name="_t">type to get serialization functions for</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility._deserialRecipes">
            <summary>
            Private buffer with deserialization recipes
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.getDeserializationRecipe(System.Type)">
            <summary>
            Generator for getting a dictionary with deserialization functions for a specific type
            </summary>
            <param name="_t">type to get deserialization functions for</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility._referenceAliasTypes">
            <summary>
            Private buffer for the baseType Definitions
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility.refAliasKeys">
            <summary>
            Private buffer for types marked as reference type aliass'
            </summary>
        </member>
        <member name="P:u040.prespective.utility.serialization.SerializationUtility.referenceAliasTypes">
            <summary>
            Generator for a Concurrent Dictionary with Serialization and Deserialization functions for Reference Alias Types
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.genReferenceAliasTypes(System.Int32)">
            <summary>
            Returns a Dictionary with Serialization and Deserialization functions for Reference Alias Types
            (i.e types that cannot be serialized but should be serialized by reference/ path-to-asset)
            </summary>
            <param name="_cores">the number of cores to maximally allow in this dictionary concurrently</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.serialization.SerializationUtility._baseTypes">
            <summary>
            Private buffer for the baseType Definitions
            </summary>
        </member>
        <member name="P:u040.prespective.utility.serialization.SerializationUtility.baseTypes">
            <summary>
            Generator for a Concurrent Dictionary with the (de-)serialization functions for all basetypes
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.SerializationUtility.genBaseTypes(System.Int32)">
            <summary>
            Generates a Concurrent Dictionary with the (de-)serialization functions for all basetypes
            </summary>
            <param name="_cores">the number of cores to maximally allow in this dictionary concurrently</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.SerializationFormat">
            <summary>
            Serialization Format
            </summary>
        </member>
        <member name="T:u040.prespective.utility.serialization.BaseTypeDef">
            <summary>
            @STRUCT : BaseTypeDef
            
            @ABOUT: Struct to contain functions for serializing and deserializing base type definitions
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: V1.00 - 19/06/2018 - First implementation for used in PreSpective
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.BaseTypeDef.type">
            <summary>
            Type of this basetype (for recognition in instance form)
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.BaseTypeDef.serialize">
            <summary>
            Function performed to serialize an instance of this type
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.BaseTypeDef.deserialize">
            <summary>
            Function performed to deserialize an instance of this type
            </summary>
        </member>
        <member name="T:u040.prespective.utility.serialization.DynamicCIL">
            <summary>
            @CLASS : DynamicCIL
            
            @ABOUT : Custom functions for CIL-level Reflection
                     based on several CIL implementation tutorials:
                     CIL Programming : under the hood of .NET programming (Book)
                     
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: v1.00 - 27/04/2018 - Base level implementation for use in the Unity scene streamer (PreStreamer)
            </summary>
        </member>
        <member name="T:u040.prespective.utility.serialization.DynamicCIL.MemberGetterDelegate">
            <summary>
            Delegate that returns the value of member in object obj
            </summary>
            <param name="obj">instance to get the member value from</param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.serialization.DynamicCIL.memberGetterRegistry">
            <summary>
            Registry to manage instances of the member getter delegate, registered by class
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GetMemberType(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="_t"></param>
            <param name="_member"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GetMemberGetter(System.Reflection.MemberInfo,System.Type@)">
            <summary>
            Override used for retrieving the member getter delegate directly from a memberinfo object
            </summary>
            <param name="_m"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GetMemberGetter(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Retrieve a member getting delegate, return if allready exists in instanced registry
            otherwise create and register
            </summary>
            <param name="_t">the type to look for</param>
            <param name="_member">the getter member to look for within the type</param>
            <param name="_bf">optional binding flags to use in member reference, generally not required</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.addMemberGetterDelegate(System.Type,System.Type@,System.String,System.Reflection.BindingFlags)">
            <summary>
            Create and add a member getter delegate to the registry
            </summary>
            <param name="_t">the type to look for</param>
            <param name="_memType"></param>
            <param name="_member">the getter member to look for, and register</param>
            <param name="_bf">optional binding flags to use in member reference, generally not required</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.getMemberInfo(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Retrieve a member info object from a type 
            </summary>
            <param name="_t">the type to reflect</param>
            <param name="_member">the member to look for</param>
            <param name="_bf">optional binding flags to use in member reference, generally not required</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.generateMemberGetter(System.Reflection.MemberInfo,System.Type@)">
            <summary>
            retrieve a dynamic function delegate able to get a member value on custom context
            </summary>
            <param name="_m">the memberinfo describing the field, property or method blueprint to get a value from</param>
            <returns>dynamic function delegate able to get a member value on custom context</returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.DynamicCIL.MemberSetterRefDelegate">
            <summary>
            Delegate that sets a member value in instance object, requires reference object to work
            </summary>
            <param name="obj">the instance to set the value in</param>
            <param name="value">the value to set it to</param>
        </member>
        <member name="T:u040.prespective.utility.serialization.DynamicCIL.MemberSetterDelegate">
            <summary>
            Delegate that sets a member value in instance object, wrapper for MemberSetterRefDelegate
            </summary>
            <param name="obj"></param>
            <param name="value"></param>
        </member>
        <member name="F:u040.prespective.utility.serialization.DynamicCIL.memberSetterRegistry">
            <summary>
            Registry to manage instances of the member setter delegate, registered by class
            </summary>
        </member>
        <member name="F:u040.prespective.utility.serialization.DynamicCIL.paramTypes">
            <summary>
            Base parameter types used in creating the member setter delegates
            </summary>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GetMemberSetter(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Function used to retrieve a member setting delegate
            </summary>
            <param name="_t">Type container of the member</param>
            <param name="_member">string reference to the sought member</param>
            <param name="_bf">optional Bindingflags used in retrieving the member, generally not required</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.addMemberSetterDelegate(System.Type,System.String,System.Reflection.BindingFlags)">
            <summary>
            Create and add a member setter delegate to the registry
            </summary>
            <param name="_t">the type to look for</param>
            <param name="_member">the getter member to look for, and register</param>
            <param name="_bf">optional binding flags to use in member reference, generally not required</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GenerateMemberMethodSetter(System.Reflection.MethodInfo)">
            <summary>
            Function to generate the Member setter delegate when dealing with a method type member
            </summary>
            <param name="_methodInfo">member descriptor</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GenerateMemberSetter(System.Reflection.MemberInfo)">
            <summary>
            Function to generate the Member setter delegate when dealing with a property of field type member
            </summary>
            <param name="memberInfo">member descriptor</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.serialization.DynamicCIL.ConstructorDelegate">
            <summary>
            Prototype delegate for creating custom constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GetConstructor(System.Type)">
            <summary>
            Creates an empty param constructor for the type with name typeName
            </summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.serialization.DynamicCIL.GetConstructor(System.String)">
            <summary>
            Creates an empty param constructor for the type with name typeName
            </summary>
            <param name="_typeName"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1">
            <summary>
            Optimized Buffer used for quick FIFO processing
            (Implmented in DES)
            
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1126728178/RegressiveSortedCollection+-+Optimized+Buffer+used+for+quick+FIFO+processing"> Documentation </a></para>
            
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version 
                ver="1.0.0" 
                author="PWS" 
                date="200603">
            </version>
            <testing>
            [None]
            </testing>
            <typeparam name="T">the type contained in this collection</typeparam>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.StaticBuffer">
            <summary>
            The buffer to assign values to
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.NextEntry">
            <summary>
            The next entry based on latest use
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.Clear">
            <summary>
            Clears the entire buffer
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.HandleNextEntryAndPreventPreInsert">
            <summary>
            get next entry
            </summary>
            <returns>next entry</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.SafePeekNextEntry(`0@)">
            <summary>
            peek next entry
            </summary>
            <param name="_next">next entry</param>
            <returns>found next entry</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.PeekNextEntry">
            <summary>
            peek next entry
            </summary>
            <returns>next entry</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.PeekCurrentEntry">
            <summary>
            peek current entry
            </summary>
            <returns>current entry</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.TrimStart(System.Int32)">
            <summary>
            Trim all entries from the start of the collection
            </summary>
            <param name="_trimStart"></param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.GetItemsByFilter(System.Func{`0,System.Boolean})">
            <summary>
            Get items from collection by filter
            </summary>
            <param name="_filter">filter</param>
            <returns>found items from collection</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.PopAndReturnItemsByFilter(System.Func{`0,System.Boolean})">
            <summary>
            Pop items that match the filter (removes them from the collection) and returns them as list
            </summary>
            <param name="_filter"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.PopItemsByFilter(System.Func{`0,System.Boolean})">
            <summary>
            Only Pops items that match the filter (returns nothing)
            </summary>
            <param name="_filter"></param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.RegressiveSortedCollection`1.InsertRangeAndSort(System.Collections.Generic.List{`0},System.Comparison{`0})">
            <summary>
            Insert a range of objects and sorts the new total collection
            </summary>
            <param name="_newItems"></param>
            <param name="_sortingFunction"></param>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.DictionaryUtils">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.DictionaryUtils.AddOrUpdate``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>
            add or updated value in dictionairy
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="_dict">dictionairy</param>
            <param name="_key">dictionairy key</param>
            <param name="_value">dictionairy new value to set</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.DictionaryUtils.TryCopyValue``3(System.Collections.Generic.Dictionary{``0,``1},``0,``2@)">
            <summary>
            try to copy over value at key
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="_dict">dictionairy</param>
            <param name="_key">dictionairy key</param>
            <param name="_value">value to copy over</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.DictionaryUtils.Stringify``2(System.Collections.Generic.List{System.Collections.Generic.Dictionary{``0,``1}},System.Char,System.Char)">
            <summary>
            make string of list ditionairies
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="_listDict">list of dictionairy</param>
            <param name="_keyValueSplitter">key value splitter</param>
            <param name="_kvSetSplitter">in between values splitter</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.DictionaryUtils.Stringify``2(System.Collections.Generic.Dictionary{``0,``1},System.Char,System.Char)">
            <summary>
            make string of dictionairy
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="_dict">dictionairy</param>
            <param name="_keyValueSplitter">key value splitter</param>
            <param name="_kvSetSplitter">in between values splitter</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OnTypeSortingDelegate`1">
            <summary>
            Delegate for sorting objects
            </summary>
            <typeparam name="T">Type of objects to compare</typeparam>
            <param name="_a">Object to compare</param>
            <param name="_b">Object to compare</param>
            <returns>1 or -1</returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.IndexedSorter`1">
            <summary> // ToDo: fix class description
            <description>
            Description
            </description>
            <versions>
              <version 
                  version="1.0.0" 
                  author="Name"
                  date="DD-MM-YYYY">
                  <summary>
                     Summary
                  </summary>
              </version>
            </versions>
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Constructor for list
            </summary>
            <param name="_list">List of T</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.#ctor(`0[])">
            <summary>
            Constructor for array
            </summary>
            <param name="_array">Array of T</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.createIndex(System.Collections.Generic.List{`0})">
            <summary>
            Get indexes for list values
            </summary>
            <param name="_list">List to get indexes from</param>
            <returns>List with indexes</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.createIndex(`0[])">
            <summary>
            Get indexes for list values
            </summary>
            <param name="_array">Array to get indexes from</param>
            <returns>List with indexes</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.Sort(u040.prespective.utility.collectionmanagement.OnTypeSortingDelegate{`0})">
            <summary>
            Sort the list of indexes
            </summary>
            <param name="_func">Sorting function</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.GetSortedList">
            <summary>
            Get the sorted list as a list
            </summary>
            <returns>The sorted list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.GetSortedArray">
            <summary>
            Get the sorted list as an array
            </summary>
            <returns>The sorted list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.GetSortedIndexes">
            <summary>
            Get the sorted indexes as a list
            </summary>
            <returns>The sorted indexes as a list of integers</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.GetNewIndexForOldIndex(System.Int32)">
            <summary>
            Get the new index of an object with the old index
            </summary>
            <param name="_old">Old index of the object</param>
            <returns>New index of the object or -1 if the object can not be found</returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.IndexedSorter`1.ComparableListItem`1">
            <summary> // ToDo: fix class description
            <description>
            Description
            </description>
            <versions>
              <version 
                  version="1.0.0" 
                  author="Name"
                  date="DD-MM-YYYY">
                  <summary>
                     Summary
                  </summary>
              </version>
            </versions>
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.IndexedSorter`1.ComparableListItem`1.#ctor(`1,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="_item">item</param>
            <param name="_index">Index of item</param>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1">
            <summary>
            Impromptu n-to-n relationship manager
            (e.g. in DES a cue can have intersections with multiple actors; and an actor can have intersections with multiple cues - both direction registration is desirable for quick lookup)
            </summary>
            <typeparam name="T">the type contained for linking the the n-to-n relations (generally int)</typeparam>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.forwardRegistrations">
            <summary>
            The Forward Registration table
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.reverseRegistrations">
            <summary>
            The Reverse Registration table
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.enforceUniqueIDSets">
            <summary>
            whether an ID cannot exist as key in both the Forward and Reverse List
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.comparer">
            <summary>
            Function used for comparison A == B
            </summary>
        </member>
        <member name="P:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.Count">
            <summary>
            Total amount forward and reverse registrations present
            </summary>
        </member>
        <member name="P:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ForwardRegistrationsPresent">
            <summary>
            If has forward registrations present
            </summary>
        </member>
        <member name="P:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ReverseRegistrationsPresent">
            <summary>
            If has reverse registrations present
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.#ctor(System.Func{`0,`0,System.Boolean},System.Boolean)">
            <summary>
            Creates a new Bidirectional Registration
            </summary>
            <param name="_comparer">the function to determine if entry A is equal to entry B</param>
            <param name="_enforceUniqueIDSets">whether an ID cannot exist as key in both the Forward and Reverse List (Default is true, since that case would make some operations impossible)</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ForwardHasRegistration(`0,`0)">
            <summary>
            Returns if the FORWARD Dictionary identified with _fwdID has an entry _reverseID 
            </summary>
            <param name="_forwardID"></param>
            <param name="_reverseID"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetForwardRegistrations(`0,`0[]@)">
            <summary>
            Get forward registration based on id
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_results">found registration</param>
            <returns>if found</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetAllForwardRegistrationKeys">
            <summary>
            Get forward registration keys
            </summary>
            <returns>forward registration keys</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetAllReverseRegistrationKeys">
            <summary>
            Get reverse Registration keys
            </summary>
            <returns>reverse registration keys</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ReverseHasRegistration(`0,`0)">
            <summary>
            Returns if the REVERSE Dictionary identified with _reverseID has an entry _forwardID 
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_forwardID">forward id</param>
            <returns>is present in reverse registration</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetReverseRegistrations(`0,`0[]@)">
            <summary>
            Get reverse registration of id
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_results">found registration</param>
            <returns>if found</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ForwardRemoveAllEntriesWithCustomCompare(`0,System.Func{`0,`0,System.Boolean})">
            <summary>
            Remove all forward entries on id
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_customComparer">custom compare function</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetForwardEntriesWithCustomCompare(`0,System.Func{`0,`0,System.Boolean},System.Collections.Generic.List{`0}@)">
            <summary>
            Find forward registrations on id
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_customComparer">custom compare function</param>
            <param name="_results">found registrations</param>
            <returns>if found</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetAggregatedForwardContentWithCustomCompare(`0,System.Func{`0,`0,System.Boolean},System.Collections.Generic.List{`0}@)">
            <summary>
            Find forward registrations on id aggregated
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_customComparer">custom compare function</param>
            <param name="_results">found registrations</param>
            <returns>if found</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ForwardRemoveAllEntries(`0)">
            <summary>
            Remove all forward entries
            </summary>
            <param name="_forwardID">forward id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ForwardRemoveEntry(`0,`0)">
            <summary>
            Remove forward entry on id
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_reverseID">reverse id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.reverseRemoveSecond(`0,`0)">
            <summary>
            Reverse registration remove done after forward remove
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_forwardID">forward id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ReverseRemoveAllEntriesWithCustomCompare(`0,System.Func{`0,`0,System.Boolean})">
            <summary>
            Remove all reverse entries
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_customComparer">custom compare function</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetReverseEntriesWithCustomCompare(`0,System.Func{`0,`0,System.Boolean},System.Collections.Generic.List{`0}@)">
            <summary>
            Find reverse registrations of id
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_customComparer">custom compare function</param>
            <param name="_results">found registrations</param>
            <returns>if found</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.GetAggregatedReverseContentWithCustomCompare(`0,System.Func{`0,`0,System.Boolean},System.Collections.Generic.List{`0}@)">
            <summary>
            Find reverse registrations on id aggregated
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_customComparer">custom compare function</param>
            <param name="_results">found registrations</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ReverseRemoveAllEntries(`0)">
            <summary>
            Remove all reverse registrations
            </summary>
            <param name="_reverseID">reverse id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ReverseRemoveEntry(`0,`0)">
            <summary>
            Remove reverse registration
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_forwardID">forward id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.forwardRemoveSecond(`0,`0)">
            <summary>
            Forward remove after reverse remove
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_reverseID">reverse id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ForwardAddEntry(`0,`0)">
            <summary>
            Add forward registration
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_reverseID">reverse id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.secondReverseAddEntry(`0,`0)">
            <summary>
            Add reverse id after forward already added
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_forwardID">forward id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ReverseAddEntry(`0,`0)">
            <summary>
            Add reverse registration
            </summary>
            <param name="_reverseID">reverse id</param>
            <param name="_forwardID">forward id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.secondForwardAddEntry(`0,`0)">
            <summary>
            Add forward id after reverse already added
            </summary>
            <param name="_forwardID">forward id</param>
            <param name="_reverseID">reverse id</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.unregisterDictEntry(`0,`0,System.Collections.Generic.Dictionary{`0,u040.prespective.utility.collectionmanagement.BidirectionalRegistration{`0}.RegistrationData{`0}},System.Func{`0,`0,System.Boolean})">
            <summary>
            Remove a Dictionary Entry
            </summary>
            <param name="_dictID">ID to look for in this dictionary</param>
            <param name="_listID">ID to look for in the contained dictionary lists</param>
            <param name="_dictionary">Dictionary to look through</param>
            <param name="_reverseRegistration">optional wrapped function to call if successful (e.g. if we add an ID in this register, we'll also want to add this ID in the opposing register)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.registerNewDictEntry(`0,`0,System.Collections.Generic.Dictionary{`0,u040.prespective.utility.collectionmanagement.BidirectionalRegistration{`0}.RegistrationData{`0}},System.Func{`0,`0,System.Boolean})">
            <summary>
            Create a new Dictionary Entry
            </summary>
            <param name="_dictionaryID">ID to look for in this dictionary</param>
            <param name="_arrayID">ID to look for in the contained dictionary arrays</param>
            <param name="_dictionary">Dictionary to look through</param>
            <param name="_reverseRegistration">optional wrapped function to call if successful (e.g. if we add an ID in this register, we'll also want to add this ID in the opposing register)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.getIDIndexInArray(`0,`0[],System.Int32)">
            <summary>
            Returns the index of the _idToFind in the array _ids
            (NOTE : arrays are passed by reference, so no risk of re-instantiation)
            </summary>
            <param name="_idToFind">the ID to look for</param>
            <param name="_ids">the full array with IDs</param>
            <param name="_amountIDS">amount of ids</param>
            <returns>index of in array of id (-1 if not present)</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.Clear">
            <summary>
            Clears regrations of data
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.ToString" -->
        <member name="T:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.RegistrationData`1">
            <summary>
            Registered data storing class
            </summary>
            <typeparam name="T1">Type of data</typeparam>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.RegistrationData`1.DataArray">
            <summary>
            Array of data
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.RegistrationData`1.CurrentAmountDataInArray">
            <summary>
            Amount of data stored in the array (the array can be longer then the data stored in it)
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BidirectionalRegistration`1.RegistrationData`1.#ctor(`1[],System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="_array">array to of data</param>
            <param name="_amountFilled">amount array is filled with data</param>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OnBinaryTreeSorterAction`1">
            <summary>
            sorting function for binary tree
            </summary>
            <typeparam name="T">type of data</typeparam>
            <param name="_a">data 1 compare</param>
            <param name="_b">data 2 compare</param>
            <returns>is should be moved left</returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.BinaryTree`1">
            <summary>
            <description>
            Sorts enumerable's with given function using binary tree
            </description>
            <version 
                ver="1.0.0" 
                author="TGE" 
                date="201106">
                Made first version that can order lists and arrays independent of data type
            </version>
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BinaryTree`1.Sort(System.Collections.Generic.List{`0},u040.prespective.utility.collectionmanagement.OnBinaryTreeSorterAction{`0})">
            <summary>
            Get sorted result of list
            </summary>
            <param name="_list">list</param>
            <param name="_sortingFunction">sorting function for binary tree</param>
            <returns>sorted list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BinaryTree`1.Sort(`0[],u040.prespective.utility.collectionmanagement.OnBinaryTreeSorterAction{`0})">
            <summary>
            Get sorted result of list
            </summary>
            <param name="_list">list</param>
            <param name="_sortingFunction">sorting function for binary tree</param>
            <returns>sorted list</returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1">
            <summary>
            single branch of binary tree (can be the main trunk)
            </summary>
            <typeparam name="T1">type of data checked here</typeparam>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.Index">
            <summary>
            index of data
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.Data">
            <summary>
            data
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.leftBranch">
            <summary>
            left branch
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.rightBranch">
            <summary>
            right branch
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.hasLeftBranch">
            <summary>
            if has left branch
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.hasrightBranch">
            <summary>
            if has right branch
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.#ctor(System.Int32,`0)">
            <summary>
            constructor
            </summary>
            <param name="_dummyIndex">index</param>
            <param name="_dummyData">data</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.AddValue(System.Int32,`0,u040.prespective.utility.collectionmanagement.OnBinaryTreeSorterAction{`0})">
            <summary>
            adds value to binary tree
            </summary>
            <param name="_index">index of data</param>
            <param name="_compareData">compare data</param>
            <param name="_sortingFunction">sorting function</param>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.BinaryTree`1.BinaryBranch`1.GetSorting">
            <summary>
            gets the sorting found by binary tree
            </summary>
            <returns>sorted indices</returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.TypedList">
            <summary>
            Helper static library class for List/Enumeration functions
            (should prevent you from having to use Linq most of the time)
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <description>
            Twincat ADS stream adapter uses block read and write
            </description>
            <versions>
            <version 
                  version="1.0.0" 
                  author="Pieter Weterings" 
                  date="08-02-2021">
                  <summary>
                     Twincat ADS stream adapter uses block read and write
                  </summary>
              </version>
            </versions>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.TypedList.cachedListType">
            <summary>
            Cache for the getting the type of a generic list for the <see cref="M:u040.prespective.utility.collectionmanagement.TypedList.IsGenericList(System.Type)"/>
            </summary>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedObjects``1">
            <summary>
            Gets all components of type
            </summary>
            <typeparam name="T">Type to search for</typeparam>
            <returns>All components of type T in the active scene.</returns>
            ToDo: Flags do not seem to make an impact on the inclusion of an object in the return list.
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedObjects(System.Type)">
            <summary>
            Gets all components of type
            </summary>
            <param name="_type">Type to search for</param>
            <returns>All components of type _type in the active scene</returns>
            <exception cref="T:System.Exception">ArgumentException when type _type is not a Component</exception>
            ToDo: Flags do not seem to make an impact on the inclusion of an object in the return list.
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedObjects``1(UnityEngine.Transform,System.Boolean)">
            <summary>
            Gets all components of type within a container (transform)
            </summary>
            <typeparam name="T">Type to search for</typeparam>
            <param name="_container">Container of transforms</param>
            <param name="_directChildrenOnly">Check direct children only</param>
            <returns>All components of type T in the _container Transform</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedComponentsUpTo``2(UnityEngine.Transform)">
            <summary>
            Gets all components of type T1 or type T2 within a container (transform)
            </summary>
            <typeparam name="T1">Type to search for</typeparam>
            <typeparam name="T2">Type to search for</typeparam>
            <param name="_container">Container of transforms</param>
            <returns>All components of type T1 and T2 in the _container Transform</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedComponentsUpTo``2(System.Type,UnityEngine.Transform,System.Collections.Generic.List{``1}@,System.Boolean)">
            <summary>
            Gets all components of type T1 within a container (transform)
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="_type"></param>
            <param name="_container">container</param>
            <param name="_encounteredUpTo"></param>
            <param name="_directChildrenOnly"></param>
            <returns>all components of type T1 and T2 in the _container Transform</returns>
            <exception cref="T:System.Exception">ArgumentException when type _type is not a Component</exception>
            ToDo: What is this function?
            ToDo: Fix function xml.
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedComponentsFromObjectsInList``2(System.Collections.Generic.List{``0})">
            <summary>
            Gets all components of type within a list
            </summary>
            <typeparam name="T1">Type of list of components</typeparam>
            <typeparam name="T2">Type for the return list of components</typeparam>
            <param name="_typedList">Input list of components that will be searched through</param>
            <returns>All components of type T2 in list of type T1</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllInheritantInstances``1(System.Collections.Generic.List{System.Object})">
            <summary>
            Get all objects in a list that inherit from type T
            </summary>
            <typeparam name="T">Type to search for</typeparam>
            <param name="_instances">List of objects to search through</param>
            <returns>Return all objects in a list that inherit from type T</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllInheritantInstances``1(System.Object[])">
            <summary>
            Get all objects in an array that inherit from type T
            </summary>
            <typeparam name="T">Type to search for</typeparam>
            <param name="_instances">Array of objects to search through</param>
            <returns>Return all objects in an array that inherit from type T</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedParents``1(UnityEngine.Transform)">
            <summary>
            Get all parents of type T within a container (Transform)
            </summary>
            <typeparam name="T">Type to search for</typeparam>
            <param name="_container">Container of transforms</param>
            <returns>Parents of type T found in the _container</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedComponents``1(UnityEngine.Transform,System.Boolean,System.Boolean)">
            <summary>
            Get all components of type T within a container (Transform)
            </summary>
            <typeparam name="T">Type of Component to search for</typeparam>
            <param name="_container">Container of transforms</param>
            <param name="_directChildrenOnly">Check direct children only</param>
            <param name="_includeInactive">Include inactive components</param>
            <returns>Components of type T found in the _container</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedComponents``1(System.Type,UnityEngine.Transform,System.Boolean)">
            <summary>
            Get all components of type within a container (Transform)
            </summary>
            <typeparam name="T">Type of Component to return</typeparam>
            <param name="_type">Type of Component to search for</param>
            <param name="_container">Container of transforms</param>
            <param name="_directChildrenOnly">Check direct children only</param>
            <returns>Components of type _type found in the _container</returns>
            <exception cref="T:System.Exception">ArgumentException when type _type is not a Component</exception>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetAllTypedComponentsArray``1(UnityEngine.Transform,System.Boolean)">
            <summary>
            Get all components of type T within an array
            </summary>
            <typeparam name="T">Type of component to search for</typeparam>
            <param name="_container">Container of transforms to search through</param>
            <param name="_directChildrenOnly">Check direct children only</param>
            <returns>Components of type T found in the _container</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetFirstChildOfType``1(UnityEngine.Transform,System.Boolean)">
            <summary>
            Get all children components of Type T
            </summary>
            <typeparam name="T">Type of component to search for</typeparam>
            <param name="_container">Container of transforms to search through</param>
            <param name="_considerSelf">Check self</param>
            <returns>Children of type T within the _container</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.GetFirstParentOfType``1(UnityEngine.Transform,System.Boolean)">
            <summary>
            Get all parents components of Type T
            </summary>
            <typeparam name="T">Type of component to search for</typeparam>
            <param name="_container">Container of transforms to search through</param>
            <param name="_considerSelf">Check self</param>
            <returns>Parents of type T within the _container</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.Cycle``1(System.Collections.Generic.List{``0}@,System.Int32)">
            <summary>
            Cycle a list of items left or right
            </summary>
            <param name="_list">List to cycle</param>
            <param name="_n">Amount of cycles</param>
            <typeparam name="T">Type of list</typeparam>
            <exception cref="T:System.Exception">ArgumentException for empty list or null ref</exception>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.AppendLists``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            Combine two lists
            </summary>
            <typeparam name="T">Type of lists</typeparam>
            <param name="_listA">List to be combined with the other list</param>
            <param name="_listB">List to be combined with the other list</param>
            <returns>A list that combines _listA and _listB</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.AppendArrays``1(``0[],``0[])">
            <summary>
            Combine two arrays
            </summary>
            <typeparam name="T">Type of arrays</typeparam>
            <param name="_arrayA">Array to combine with another array</param>
            <param name="_arrayB">Array to combine with another array</param>
            <returns>`Combined array of _arrayA and _arrayB</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ToString``2(System.Collections.Generic.Dictionary{``0,``1},System.String,System.Boolean)">
            <summary>
            A ToString function for dictionaries that can output in a custom schema or in a JSON schema
            </summary>
            <param name="_dictionary">The dictionary to convert to a string</param>
            <param name="_appendString">The separator between dictionary elements</param>
            <param name="_toJson">Should use JSON schema (https://www.json.org/json-en.html)</param>
            <typeparam name="T1">Type of dictionary keys</typeparam>
            <typeparam name="T2">Type of dictionary values</typeparam>
            <returns>A string with all keys and value pairs of a dictionary with a custom schema or in a JSON schema</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ToString``1(System.Collections.Generic.List{``0},System.String,System.Boolean)">
            <summary>
            A ToString function for lists that can output in a custom schema or in a JSON schema
            </summary>
            <typeparam name="T">Type of list</typeparam>
            <param name="_list">The list to convert to a string</param>
            <param name="_appendString">The separator between list elements</param>
            <param name="_toJson">Should use JSON schema (https://www.json.org/json-en.html)</param>
            <returns>A string with all elements of a list with a custom schema or in a JSON schema</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ToString``1(System.Collections.Generic.List{System.Collections.Generic.List{``0}},System.String,System.Boolean)">
            <summary>
            A ToString function for a list of lists that can output in a custom schema or in a JSON schema
            </summary>
            <typeparam name="T">Type of lists in list</typeparam>
            <param name="_list">The list of lists to convert into a string</param>
            <param name="_appendString">The separator between list elements</param>
            <param name="_toJson">Should use JSON schema (https://www.json.org/json-en.html)</param>
            <returns>A string with all elements of a list of lists with a custom schema or in a JSON schema</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ToString``1(``0[],System.String,System.Boolean)">
            <summary>
            A ToString function for arrays that can output in a custom schema or in a JSON schema
            </summary>
            <typeparam name="T">Type of array</typeparam>
            <param name="_array">The array to convert to a string</param>
            <param name="_appendString">The separator between list elements</param>
            <param name="_toJson">Should use JSON schema (https://www.json.org/json-en.html)</param>
            <returns>A string with all elements of an array with a custom schema or in a JSON schema</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.MakeDistinct``1(System.Collections.Generic.List{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Get a list of distinct values in a list
            </summary>
            <param name="_list">Input list to check for distinct values</param>
            <param name="_isSimilarTest">Function that returns true if two values are the same</param>
            <returns>A list of distinct values</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ParseJsonArrayStringToList(System.String,System.Boolean)">
            <summary>
            Parse a JSON string to a list of strings
            </summary>
            <param name="_string">Input string</param>
            <param name="_returnSingleAsFirstEntry">Should add _string as first entry of the return list if the string is not a JSON string</param>
            <returns>A list of elements in a JSON string or a list with the input _string as the first entry</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ConvertEntriesList``2(System.Collections.Generic.List{``0},System.Func{``0,``1})">
            <summary>
            Convert a list from one type to a list of another type
            </summary>
            <typeparam name="T1">Type of objects to be converted</typeparam>
            <typeparam name="T2">Type the objects will be converted in to</typeparam>
            <param name="_list">List of type T1 to be converted</param>
            <param name="_func">A function that takes an object of type T1 and returns an object of Type T2</param>
            <returns>A list of type T2 containing the converted items of _list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ConvertEntries``2(System.Collections.Generic.List{``0},System.Func{``0,``1})">
            <summary>
            Convert a list from one type to an array of another type
            </summary>
            <typeparam name="T1">Type of objects to be converted</typeparam>
            <typeparam name="T2">Type the objects will be converted in to</typeparam>
            <param name="_list">List of type T1 to be converted</param>
            <param name="_func">A function that takes an object of type T1 and returns an object of Type T2</param>
            <returns>An array of type T2 containing the converted items of _list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ConvertEntriesList``2(System.Collections.Generic.List{System.Collections.Generic.List{``0}},System.Func{``0,``1})">
            <summary>
            Convert a list of lists from one type to a list of lists of another type
            </summary>
            <typeparam name="T1">Type of objects to be converted</typeparam>
            <typeparam name="T2">Type the objects will be converted in to</typeparam>
            <param name="_list">List of lists of type T1 to be converted</param>
            <param name="_func">A function that takes an object of type T1 and returns an object of Type T2</param>
            <returns>A list of lists of type T2 containing the converted items of _list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ConvertEntriesArray``2(``0[][],System.Func{``0,``1})">
            <summary>
            Convert a array of arrays from one type to an array of arrays of another type
            </summary>
            <typeparam name="T1">Type of objects to be converted</typeparam>
            <typeparam name="T2">Type the objects will be converted in to</typeparam>
            <param name="_array">Array of arrays of type T1 to be converted</param>
            <param name="_func">A function that takes an object of type T1 and returns an object of Type T2</param>
            <returns>An array of arrays of type T2 containing the converted items of _array</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ConvertEntriesList``2(``0[],System.Func{``0,``1},System.Boolean)">
            <summary>
            Convert an array from one type to an array of another type
            </summary>
            <typeparam name="T1">Type of objects to be converted</typeparam>
            <typeparam name="T2">Type the objects will be converted in to</typeparam>
            <param name="_array">Array of type T1 to be converted</param>
            <param name="_conversionFunction">A function that takes an object of type T1 and returns an object of Type T2</param>
            <param name="_removeNulls">Should not convert null values in _array</param>
            <returns>A list of type T2 containing the converted items of _list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ConvertEntries``2(``0[],System.Func{``0,``1},System.Boolean)">
            <summary>
            Convert an array from one type to another type
            </summary>
            <typeparam name="T1">Type of objects to be converted</typeparam>
            <typeparam name="T2">Type the objects will be converted in to</typeparam>
            <param name="_array">Array of type T1 to be converted</param>
            <param name="_func">A function that takes an object of type T1 and returns an object of Type T2</param>
            <param name="_useParallelFor">Should use a parallel loop for converting objects</param>
            <returns>An array of type T2 containing the converted items of _list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ShallowClone``1(System.Collections.Generic.List{``0})">
            <summary>
            Create a shallow copy of a list
            </summary>
            <typeparam name="T">Type of the list to copy</typeparam>
            <param name="_list">List to copy</param>
            <returns>List with items of the input list</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ShallowClone``1(System.Collections.Generic.List{System.Collections.Generic.List{``0}})">
            <summary>
            Create a shallow copy of a list of lists
            </summary>
            <typeparam name="T">Type of list in lists</typeparam>
            <param name="_list">A list of lists</param>
            <returns>List of lists with items of the input list of lists</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.FindIndex``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Find the index of an object in a list
            </summary>
            <typeparam name="T">Type of list and item to search for</typeparam>
            <param name="_list">List to find object in</param>
            <param name="_item">Object to search for</param>
            <returns>The index of the object in the list or -1 as an error value</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.IndexInRange``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Check whether a given index is within range of the list
            </summary>
            <typeparam name="T">Type of list</typeparam>
            <param name="_list">The list to check</param>
            <param name="_index">The index to check</param>
            <returns>Whether index is within range</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.Swap``1(System.Collections.Generic.List{``0},System.Int32,System.Int32)">
            <summary>
            Swap tow objects in a list
            </summary>
            <typeparam name="T">Type of the list to swap objects in</typeparam>
            <param name="_source">The list to swap objects in</param>
            <param name="_indexA">Object that will be swapped</param>
            <param name="_indexB">Object that will be swapped</param>
            <returns>List where the objects at indexes _indexA and _indexB are swapped</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.ToList``1(``0[])">
            <summary>
            Make a list from an array
            </summary>
            <typeparam name="T">Type of array and return list</typeparam>
            <param name="_array">Array to convert to a list</param>
            <returns>List with items from array</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.FindIndex``1(``0[],``0,System.Func{``0,``0,System.Boolean})">
            <summary>
            finds the index of array connected to check value by given function
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">array</param>
            <param name="_checkValue">value to find index of</param>
            <param name="_checkFunction">function to check if this is the index you want (first value array value, second value given check value)</param>
            <returns>found index (-1 if not present)</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.FindIndex``1(System.Collections.Generic.List{``0},``0,System.Func{``0,``0,System.Boolean})">
            <summary>
            finds the index of list connected to check value by given function
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_list">list</param>
            <param name="_checkValue">value to find index of</param>
            <param name="_checkFunction">function to check if this is the index you want (first value array value, second value given check value)</param>
            <returns>found index (-1 if not present)</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.TypedList.IsGenericList(System.Type)">
            <summary>
            Extension method to find out whether this is a generic list  
            </summary>
            <param name="_type">The type that will be checked if it is a generic list</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.CreateOctree">
            <summary>
            @CLASS : CreateOctree
            
            @ABOUT : Creates octree
                     
            @AUTHOR : Tymen (Unit040)
            
            @VERSION : 1.00 - Makes a octree of points or bounds(07-06-2018)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.#ctor(UnityEngine.Vector3,UnityEngine.Vector3)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.#ctor(UnityEngine.Vector3,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.AddNode(UnityEngine.Vector3,UnityEngine.Vector3)" -->
        <member name="M:u040.prespective.utility.collectionmanagement.CreateOctree.AddNode(UnityEngine.Bounds)">
            <summary>
            adds bounds to check
            </summary>
            <param bounds="b"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.AddNode(System.Collections.Generic.List{UnityEngine.Bounds})" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.AddNode(System.Collections.Generic.List{UnityEngine.Vector3})" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.AddNode(UnityEngine.Vector3[])" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.AddNode(UnityEngine.Vector3)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.MakeOctree(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.getBox(UnityEngine.Bounds,UnityEngine.Vector3)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.checkInsideBox(UnityEngine.Bounds,UnityEngine.Bounds,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.checkFilled(UnityEngine.Bounds,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.MakeOCtreeOfPoints(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.checkPointsInsideBox(UnityEngine.Bounds,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,UnityEngine.Vector3},System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.collectionmanagement.CreateOctree.makesBoxes(UnityEngine.Bounds)" -->
        <member name="M:u040.prespective.utility.collectionmanagement.CreateOctree.GetVolumeOfOctreeForBounds">
            <summary>
            determines volume of octree boxes for bounds octree
            </summary>
            <returns>volume</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.CreateOctree.GetVolumeOfOctreeForPoints">
            <summary>
            determines volume of octree boxes for points octree
            </summary>
            <returns>volume</returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.BoxVerticesData">
            <summary>
            stores the data of the octree
            </summary>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OctreeTriangleData">
            <summary>
            stores the data of a triangle octree
            </summary>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OctreeUtility">
            <summary>
            Static Library Class with Utility functions for creating and maintaining an Octree
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version ver="1.0.0" author="TGE" date="190320">Makes a octree of triangles</version>
            <version ver="1.0.5" author="TGE" date="190322">Added find best fit box around mesh to octree of triangles</version>
            <version ver="1.1.0" author="TGE" date="190712">Makes a octree of triangles and returns all depth level values</version>
            <version ver="1.2.0" author="TGE" date="190820">Makes a octree of triangles with byte addressing</version>
            <version ver="1.2.0" author="TGE" date="190823">Can now give starting cube for creating octree</version>
            <testing>
            [None]
            </testing>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OctreeUtility.OnProcessMainCubeAction">
            <summary>
            processing main cube
            </summary>
            <param name="_cube">cube</param>
            <param name="_trianglesIndices">triangle indices</param>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OctreeUtility.OnProcessCubesAction`1">
            <summary>
            processing the main cubes sub cubes
            </summary>
            <typeparam name="T">type of octree data</typeparam>
            <param name="_subCube">sub cube of main to process</param>
            <param name="_headMatrix">objects local to world matrix</param>
            <param name="_localRot">local rotation cube</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_trianglesIndices">triangle indices</param>
            <param name="_index">sub cube index</param>
            <param name="_result">resulting octree data</param>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OctreeUtility.OnProcessSub`1">
            <summary>
            processing sub cube
            </summary>
            <typeparam name="T">type of octree data</typeparam>
            <param name="_foundTriIndices">found triangle indices</param>
            <param name="_octreeData">reference resulting octree data</param>
            <returns>if found result</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.MakOctreeOfTriangles(UnityEngine.GameObject,System.Int32,System.Single,System.Boolean,System.Boolean)">
            <summary>
            makes an octree of the triangles of a mesh
            </summary>
            <param name="_go">game object with mesh to created octree of its triangles</param>
            <param name="_maxDepthLevel">maximum depth levels</param>
            <param name="_enlargingFactor">how much to make the cube larger</param>
            <param name="_uniformSize">cubes have uniform size</param>
            <param name="_useOptimalRotation">find optimal rotation</param>
            <returns>octree cubes filled</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.MakOctreeOfTriangles(UnityEngine.GameObject,UnityEngine.GameObject,System.Int32,System.Boolean)">
            <summary>
            makes an octree of the triangles of a mesh with given octree start cube
            </summary>
            <param name="_go">game object with mesh to created octree of its triangles</param>
            <param name="_cube">start cube</param>
            <param name="_maxDepthLevel"> maximum depth level</param>
            <param name="_destroyCubeAfterUse">if start cube should be destroyed after use</param>
            <returns>octree cubes filled</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.checkTriangleInCube(System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Int32[],System.Int32,System.Int32,System.Collections.Generic.List{u040.prespective.utility.collectionmanagement.OctreeTriangleData}@)">
            <summary>
            checks if the cube contains any triangles(if it does have triangles recursively checks it created cubes)
            </summary>
            <param nmae="_cube">cube</param>
            <param name="_headMatrix">head local to global matrix with rotation</param>
            <param name="_localRot">local rotation of cubes</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_trianglesIndices">triangle indices inside cube</param>
            <param name="_depth">depth level</param>
            <param name="_maxDepthLevel">maximum depth level</param>
            <param name="_triangleData">triangle data of the octree</param>
            <returns>if made triangle data</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.MakeOCtreeOfTrianglesGetAllDepthValues(UnityEngine.GameObject,System.Int32,System.Single,System.Boolean,System.Boolean)">
            <summary>
            makes an octree of the triangles of a mesh and returns all depth levels filled cubes
            </summary>
            <param name="_go">game object with mesh to created octree of its triangles</param>
            <param name="_maxDepthLevel">maximum depth levels</param>
            <param name="_enlargingFactor">how much to make the cube larger</param>
            <param name="_uniformSize">cubes have uniform size</param>
            <param name="_useOptimalRotation">find optimal rotation</param>
            <returns>octree cubes filled all depth levels</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.MakeOCtreeOfTrianglesGetAllDepthValues(UnityEngine.GameObject,UnityEngine.GameObject,System.Int32,System.Boolean)">
            <summary>
            makes an octree of the triangles of a mesh and returns all depth levels filled cubes with given octree start cube
            </summary>
            <param name="_go">game object with mesh to created octree of its triangles</param>
            <param name="_cube">start cube</param>
            <param name="_maxDepthLevel">maximum depth level</param>
            <param name="_destroyCubeAfterUse">if start cube should be destroyed after use</param>
            <returns>octree cubes filled all depth levels</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.checkTriangleInCubeAllDepthlevelsValues(System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Int32[],System.Int32,System.Int32,System.Collections.Generic.List{System.Collections.Generic.List{u040.prespective.utility.collectionmanagement.OctreeTriangleData}}@)">
            <summary>
            checks if the cube contains any triangles for all depth levels(if it does have triangles recursively checks it created cubes)
            </summary>
            <param name="_cube">cube</param>
            <param name="_headMatrix">head local to global matrix with rotation</param>
            <param name="_localRot">local rotation of cubes</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_trianglesIndices">triangle indices inside cube</param>
            <param name="_depth">depth level</param>
            <param name="_maxDepthLevel">maximum depth level</param>
            <param name="_triangleData">triangle data of the octree off depth levels</param>
            <returns>if made triangle data</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.MakeByteOCtreeOfTriangles(UnityEngine.GameObject,System.Int32,System.Single,System.Boolean,System.Boolean)">
            <summary>
            makes an octree of the triangles of a mesh
            </summary>
            <param name="_go">game object with mesh to created octree of its triangles</param>
            <param name="_maxDepthLevel">maximum depth level</param>
            <param name="_enlargingFactor">how much to make the cube larger</param>
            <param name="_uniformSize">cubes have uniform size</param>
            <param name="_useOptimalRotation">find optimal rotation</param>
            <returns>octree cubes filled</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.MakeByteOCtreeOfTriangles(UnityEngine.GameObject,UnityEngine.GameObject,System.Int32,System.Boolean)">
            <summary>
            makes an octree of the triangles of a mesh with given octree start cube
            </summary>
            <param name="_go">game object with mesh to created octree of its triangles</param>
            <param name="_cube">start cube</param>
            <param name="_maxDepthLevel">maximum depth level</param>
            <param name="_destroyCubeAfterUse">if start cube should be destroyed after use</param>
            <returns>octree cubes filled</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.checkTriangleInCube(System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Int32[],System.Int32,System.Int32,System.Byte,System.Collections.Generic.List{u040.prespective.utility.collectionmanagement.OctreeTriangleByteData}@)">
            <summary>
            checks if the cube contains any triangles(if it does have triangles recursively checks it created cubes)
            </summary>
            <param name="_cube">cube</param>
            <param name="_headMatrix">head local to global matrix</param>
            <param name="_localRot">local rotation cube</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_trianglesIndices">triangle indices inside cube</param>
            <param name="_depth">depth level</param>
            <param name="_maxDepthLevel">maximum depth level</param>
            <param name="_localAddress">local byte address</param>
            <param name="_octreeData">triangle data of the octree</param>
            <returns>if made triangle data</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.mainCubeProcessTriangleOctree``1(UnityEngine.GameObject,UnityEngine.GameObject,System.Boolean,u040.prespective.utility.collectionmanagement.OctreeUtility.OnProcessMainCubeAction,u040.prespective.utility.collectionmanagement.OctreeUtility.OnProcessCubesAction{``0})">
            <summary>
            the base processing of the main cube and its sub cubes
            </summary>
            <typeparam name="T">Type of the resulting processed data</typeparam>
            <param name="_go">game object to make octree for</param>
            <param name="_cube">start cube</param>
            <param name="_destroyCubeAfterUse">if start cube should be destroyed after use</param>
            <param name="_mainCubeAct">delegate for the processing of the main cube</param>
            <param name="_subCubeAct">delegate for processing of the main cubes sub cubes</param>
            <returns>resulting octree data</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.subCubeProcessTriangleOctree``1(System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Int32[],u040.prespective.utility.collectionmanagement.OctreeUtility.OnProcessSub{``0},System.Collections.Generic.List{``0}@)">
            <summary>
            the recursive processing of sub cubes
            </summary>
            <typeparam name="T">Type of the resulting processed data</typeparam>
            <param name="_cube">sub cube to process</param>
            <param name="_headMatrix">head local to global matrix</param>
            <param name="_localRot">local rotation cube</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_trianglesIndices">triangle indices inside above cube</param>
            <param name="_act">delegate if the cube is part of the octree</param>
            <param name="_data">data of the octree</param>
            <returns>if created octree level</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.createCube(UnityEngine.GameObject,System.Single,System.Boolean,System.Boolean)">
            <summary>
            creates a cube based on a mesh
            </summary>
            <param name="_go">game object</param>
            <param name="_enlargingFactor">how much to make the cube larger</param>
            <param name="_uniformSize">cubes have uniform size</param>
            <param name="_useOptimalRotation">find optimal rotation</param>
            <returns>cube</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.createCube(UnityEngine.MeshFilter,System.Single,System.Boolean,System.Boolean)">
            <summary>
            creates a cube based on a mesh
            </summary>
            <param name="_mf">mesh filter</param>
            <param name="_enlargingFactor">how much to make the cube larger</param>
            <param name="_uniformSize">cubes have uniform size</param>
            <param name="_useOptimalRotation">find optimal rotation</param>
            <returns>cube</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.makeCubes(System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DQuaternion)">
            <summary>
            makes the sub cubes of a cube (cuts it in 8 equal pieces)
            </summary>
            <param name="_cube">cube to make sub cubes off</param>
            <param name="_localRot">local rotation cube</param>
            <returns>sub cubes</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.getCubeEdges(System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            gets the edge description of the cube
            </summary>
            <param name="_cube">cube how edges to get</param>
            <param name="_headMatrix">head local to global matrix with rotation</param>
            <param name="_localRot">local rotation cube</param>
            <returns>edges</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.getPotimalRotationAndSize(UnityEngine.MeshFilter,System.Single,System.Single,UnityEngine.Vector3@)">
            <summary>
            get the optimal orientation of the cube to make the octree using the mesh bounds
            </summary>
            <param name="_mf">mesh filter</param>
            <param name="_amountOfAngles">amount of angles to check through in x, y and z</param>
            <param name="_enlargingFactor">how much to make the cube larger</param>
            <param name="_size">optimal cube size</param>
            <returns>optimal added rotation</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.determineBoundSize(UnityEngine.Matrix4x4,UnityEngine.Vector3[])">
            <summary>
            determines the bound size of mesh in world space
            </summary>
            <param name="_worldMatrix">local to world transform matrix</param>
            <param name="_vert">vertices</param>
            <returns>bound size</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.makePlanesOfCube(System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DQuaternion)">
            <summary>
            gets the planes data needed to do the planes intersect calculation
            </summary>
            <param name="_cube">cube to make the planes from</param>
            <param name="_headMatrix">head local to global matrix with rotation</param>
            <param name="_localRot">local rotation cube</param>
            <returns>planes data</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.checkTriangle(System.Int32,u040.prespective.math.doubles.DMatrix4x4,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DBounds3D,u040.prespective.math.doubles.DVector3[][],u040.prespective.math.doubles.DMatrix4x4,u040.prespective.utility.collectionmanagement.OctreeUtility.DataCubePlane[])">
            <summary>
            checks if triangle is fully or partially present in cube
            </summary>
            <param name="_index">triangle index</param>
            <param name="_localToWorldMatrix">local to world transform matrix</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_cubeb">cube bounds</param>
            <param name="_cubeEdges">the cube edges</param>
            <param name="_cubePointInv">world to local of cube transform matrix</param>
            <param name="_planes">planes of cube</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.checkInsidePlane(u040.prespective.math.doubles.DMatrix4x4,u040.prespective.math.doubles.DVector3)">
            <summary>
            checks if the point is on the plane
            </summary>
            <param name="_worldToLocal">plane world to local matrix</param>
            <param name="_point">point</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.collectionmanagement.OctreeUtility.checkLineIntersectsWithTriangle(u040.prespective.math.doubles.DVector3[],u040.prespective.math.doubles.DVector3[],u040.prespective.math.doubles.DVector3)">
            <summary>
            checks if the line has a intersection with the triangle
            </summary>
            <param name="_edge">edge to check</param>
            <param name="_dglobalVerts">global vertices of triangle</param>
            <param name="_dglobalPlanarNormal">global planar normal of triangle</param>
            <returns>if has intersection</returns>
        </member>
        <member name="T:u040.prespective.utility.collectionmanagement.OctreeUtility.DataCubePlane">
            <summary>
            stores the data of the cube planes
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.OctreeUtility.DataCubePlane.Normal">
            <summary>
            normal of plane
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.OctreeUtility.DataCubePlane.Point">
            <summary>
            point on plane
            </summary>
        </member>
        <member name="F:u040.prespective.utility.collectionmanagement.OctreeUtility.DataCubePlane.WorldToLocalMatrix">
            <summary>
            world to local matrix of plane
            </summary>
        </member>
        <member name="T:u040.prespective.utility.MeshType">
            <summary>
            types of meshes
            </summary>
        </member>
        <member name="T:u040.prespective.utility.PreSpectiveUtility">
            <summary>
            General utility functions for prespective
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version ver="1.0.0" author="TGE"  date="190117">Implemented basic utility functions from PreScissorUtility </version>
            <version ver="1.1.0" author="TGE"  date="190320">Implemented outer vertices functions, planar normal function and find normal surface from PreScissorUtility </version>
            <version ver="1.2.0" author="TGE"  date="190410">Implemented make transform path </version>
            <version ver="1.2.1" author="TGE"  date="190411">Changed find centre mesh to also can check it children to find centre </version>
            <version ver="1.2.5" author="TGE"  date="190415">Implemented base save as asset </version>
            <version ver="1.3.0" author="TGE"  date="190415">Implemented prefab function from prefab handler </version>
            <version ver="1.3.5" author="TGE"  date="190416">Implemented getting transform paths </version>
            <version ver="1.3.5" author="TGE"  date="190416">Implemented getting transform paths </version>
            <version ver="1.3.6" author="TGE"  date="190417">Refactored save as asset to also check if already an asset and what to do then </version>
            <version ver="1.4.0" author="TGE"  date="190418">Refactored contains check to have object contains and merged the array and list contains to a enumerable contains did merge also for the sum </version>
            <version ver="1.4.1" author="TGE"  date="190418">Implemented find index functions </version>
            <version ver="1.4.2" author="TGE, BBS"  date="190424">Implemented find dictionary value functions </version>
            <version ver="1.4.3" author="TGE"  date="190425">Implemented making functions directly calleble from variable </version>
            <version ver="1.4.4" author="TGE"  date="190426">Implemented find outer vertices double precision </version>
            <version ver="1.4.5" author="TGE"  date="190426">Implemented to double functions for vector3 enumerable and to float for dvector3 enumerable </version>
            <version ver="1.4.6" author="TGE"  date="190829">Implemented the local point, direction and vector transformations </version>
            <version ver="1.4.7" author="TGE, BBS"  date="191203">Implemented get transform from transform path </version>
            <version ver="1.4.8" author="TGE"  date="200114">Implemented check standard assets of unity through asset path </version>
            <testing>
            [None]
            </testing>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.LongestLength(UnityEngine.Vector3)">
            <summary>
            the longest axis of a vector
            </summary>
            <param name="_v">vector</param>
            <returns>longest axis</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ShortetsLength(UnityEngine.Vector3)">
            <summary>
            the shortest axis of a vector
            </summary>
            <param name="_v">vector</param>
            <returns>shortest axis</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.VectorHighestLowestCheck(UnityEngine.Vector3,UnityEngine.Vector3@,UnityEngine.Vector3@)">
            <summary>
            highest and lowest vertices values of 2 vectors
            </summary>
            <param name="_low">reference lowest</param>
            <param name="_high">reference highest</param>
            <param name="_check">vector to compare to</param>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetHighestParent(UnityEngine.GameObject)">
            <summary>
            gets the highest parent of game object
            </summary>
            <param name="_parentCheck">game object to get highest parent from</param>
            <returns>highest parent</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetAllUniqueParents(UnityEngine.GameObject[])">
            <summary>
            gets all the unique parents of a array of game objects
            </summary>
            <param name="_parentsCheck">game objects to get highest parent from</param>
            <returns>array of parents</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDictonairy``1(System.Collections.Generic.List{``0})">
            <summary>
            make dictionary form list (keys are list keys)
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">to change to dictionary</param>
            <returns>dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDictonairy``1(``0[])">
            <summary>
            make dictionary form array (keys are array keys)
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">to change to dictionary</param>
            <returns>dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToConcurrentDictonairy``1(System.Collections.Generic.List{``0})">
            <summary>
            make concurrent dictionary form list (keys are list keys) (processor count is taken from environment)
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">to change to concurrent dictionary</param>
            <returns>concurrent dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToConcurrentDictonairy``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            make concurrent dictionary form list (keys are list keys)
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">to change to concurrent dictionary</param>
            <param name="_ncpu">number of processors</param>
            <returns>concurrent dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToConcurrentDictonairy``1(``0[])">
            <summary>
            make concurrent dictionary form array (keys are array keys) (processor count is taken from environment)
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">to change to concurrent dictionary</param>
            <returns>concurrent dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToConcurrentDictionary``2(System.Collections.Generic.KeyValuePair{``0,``1}[])">
            <summary>
            make concurrent dictionary form key value pair array (processor count is taken from environment)
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="_input">to change to concurrent dictionary</param>
            <returns>concurrent dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToConcurrentDictonairy``1(``0[],System.Int32)">
            <summary>
            make concurrent dictionary form array (keys are array keys)
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">to change to concurrent dictionary</param>
            <param name="_ncpu">number of processors</param>
            <returns>concurrent dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble(UnityEngine.Vector3[])">
            <summary>
            makes it double vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            makes it double vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble``1(System.Collections.Generic.Dictionary{``0,UnityEngine.Vector3})">
            <summary>
            makes it double vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble``1(System.Collections.Generic.Dictionary{UnityEngine.Vector3,``0})">
            <summary>
            makes it double vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble(System.Collections.Generic.Dictionary{UnityEngine.Vector3,UnityEngine.Vector3})">
            <summary>
            makes it double vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble``1(System.Collections.Concurrent.ConcurrentDictionary{``0,UnityEngine.Vector3})">
            <summary>
            makes it double vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble``1(System.Collections.Concurrent.ConcurrentDictionary{UnityEngine.Vector3,``0})">
            <summary>
            makes it double vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDouble(System.Collections.Concurrent.ConcurrentDictionary{UnityEngine.Vector3,UnityEngine.Vector3})">
            <summary>
            makes it double vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDoubleDictionairy(UnityEngine.Vector3[])">
            <summary>
            makes it double vector3 and makes it a dictionary
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDoubleDictionairy(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            makes it double vector3 and makes if a dictionary
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDoubleConcurrentDictionairy(UnityEngine.Vector3[])">
            <summary>
            makes it double vector3 and makes it a concurrent dictionary
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDoubleConcurrentDictionairy(UnityEngine.Vector3[],System.Int32)">
            <summary>
            makes it double vector3 and makes it a concurrent dictionary
            </summary>
            <param name="_array">enumerator</param>
            <param name="_ncpu">number of processors</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDoubleConcurrentDictionairy(System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            makes it double vector3 and makes if a concurrent dictionary
            </summary>
            <param name="_array">enumerator</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToDoubleConcurrentDictionairy(System.Collections.Generic.List{UnityEngine.Vector3},System.Int32)">
            <summary>
            makes it double vector3 and makes if a concurrent dictionary
            </summary>
            <param name="_array">enumerator</param>
            <param name="_ncpu">number of processors</param>
            <returns>double vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat(u040.prespective.math.doubles.DVector3[])">
            <summary>
            makes it vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3})">
            <summary>
            makes it vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat``1(System.Collections.Generic.Dictionary{``0,u040.prespective.math.doubles.DVector3})">
            <summary>
            makes it vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat``1(System.Collections.Generic.Dictionary{u040.prespective.math.doubles.DVector3,``0})">
            <summary>
            makes it vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat(System.Collections.Generic.Dictionary{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3})">
            <summary>
            makes it vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat``1(System.Collections.Concurrent.ConcurrentDictionary{``0,u040.prespective.math.doubles.DVector3})">
            <summary>
            makes it vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat``1(System.Collections.Concurrent.ConcurrentDictionary{u040.prespective.math.doubles.DVector3,``0})">
            <summary>
            makes it vector3
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ToFloat(System.Collections.Concurrent.ConcurrentDictionary{u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3})">
            <summary>
            makes it vector3
            </summary>
            <param name="_array">enumerator</param>
            <returns>vector3</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CreateBatches``1(``0[],System.Int32)">
            <summary>
            Makes a concurrent dictionary for batches of array
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">array</param>
            <param name="_ncpu">number of processors</param>
            <returns>concurrent dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CreateBatches``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Makes a concurrent dictionary for batches of list
            </summary>
            <typeparam name="T">type</typeparam>
            <param name="_input">array</param>
            <param name="_ncpu">number of processors</param>
            <returns>concurrent dictionary</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDifference(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return whether a value is in between a certain range
            </summary>
            <param name="_testValue">value that should be in a range</param>
            <param name="_originalValue">the exact value to compare to</param>
            <param name="_difference">difference to check between</param>
            <returns>is between range</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDeviation(System.Single,System.Single,System.Single)">
            <summary>
            Return whether a value is in between a certain range (percentage of deviation)
            </summary>
            <param name="_testValue">value that should be in a range</param>
            <param name="_originalValue">the exact value to compare to</param>
            <param name="_deviationPercentage">percentage of deviation</param>
            <returns>is between values</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDifference(System.Single,System.Single,System.Single)">
            <summary>
            Return whether a value is in between a certain range
            </summary>
            <param name="_testValue">value that should be in a range</param>
            <param name="_originalValue">the exact value to compare to</param>
            <param name="_difference">difference to check between</param>
            <returns>is between range</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDeviation(System.Double,System.Double,System.Double)">
            <summary>
            Return whether a value is in between a certain range (percentage of deviation)
            </summary>
            <param name="_testValue">value that should be in a range</param>
            <param name="_originalValue">the exact value to compare to</param>
            <param name="_deviationPercentage">percentage of deviation</param>
            <returns>is between values</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDifference(System.Double,System.Double,System.Double)">
            <summary>
            Return whether a value is in between a certain range
            </summary>
            <param name="_testValue">value that should be in a range</param>
            <param name="_originalValue">the exact value to compare to</param>
            <param name="_difference">difference to check between</param>
            <returns>is between range</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckEqualPairs(System.Collections.Generic.KeyValuePair{System.Single,System.Single},System.Collections.Generic.KeyValuePair{System.Single,System.Single})">
            <summary>
            comparison check between 2 pairs of floats
            </summary>
            <param name="_f">floats</param>
            <param name="_c">floats</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckEqualPairs(System.Collections.Generic.KeyValuePair{System.Double,System.Double},System.Collections.Generic.KeyValuePair{System.Double,System.Double})">
            <summary>
            comparison check between 2 pairs of floats
            </summary>
            <param name="_f">doubles</param>
            <param name="_c">checks</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDeviationPairs(System.Collections.Generic.KeyValuePair{System.Single,System.Single},System.Collections.Generic.KeyValuePair{System.Single,System.Single},System.Single)">
            <summary>
            comparison check with deviation between 2 pairs of floats
            </summary>
            <param name="_f">floats</param>
            <param name="_c">checks</param>
            <param name="_deviation">deviation</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDeviationPairs(System.Collections.Generic.KeyValuePair{System.Double,System.Double},System.Collections.Generic.KeyValuePair{System.Double,System.Double},System.Double)">
            <summary>
            comparison check with deviation between 2 pairs of floats
            </summary>
            <param name="_f">doubles</param>
            <param name="_c">checks</param>
            <param name="_deviation">deviation</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDifferencePairs(System.Collections.Generic.KeyValuePair{System.Single,System.Single},System.Collections.Generic.KeyValuePair{System.Single,System.Single},System.Single)">
            <summary>
            comparison check with difference between 2 pairs of floats
            </summary>
            <param name="_f">floats</param>
            <param name="_c">checks</param>
            <param name="_difference">difference</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDifferencePairs(System.Collections.Generic.KeyValuePair{System.Double,System.Double},System.Collections.Generic.KeyValuePair{System.Double,System.Double},System.Double)">
            <summary>
            comparison check with difference between 2 pairs of floats
            </summary>
            <param name="_f">doubles</param>
            <param name="_c">checks</param>
            <param name="_difference">difference</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckEqualTriple(System.Collections.Generic.KeyValuePair{System.Single,System.Collections.Generic.KeyValuePair{System.Single,System.Single}},System.Collections.Generic.KeyValuePair{System.Single,System.Collections.Generic.KeyValuePair{System.Single,System.Single}})">
            <summary>
            comparison check between 2 triples of floats
            </summary>
            <param name="_f">floats</param>
            <param name="_c">checks</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDeviationTriple(System.Collections.Generic.KeyValuePair{System.Single,System.Collections.Generic.KeyValuePair{System.Single,System.Single}},System.Collections.Generic.KeyValuePair{System.Single,System.Collections.Generic.KeyValuePair{System.Single,System.Single}},System.Single)">
            <summary>
            comparison check with deviation between 2 triples of floats
            </summary>
            <param name="_f">floats</param>
            <param name="_c">checks</param>
            <param name="_deviation">deviation</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDifferenceTriple(System.Collections.Generic.KeyValuePair{System.Single,System.Collections.Generic.KeyValuePair{System.Single,System.Single}},System.Collections.Generic.KeyValuePair{System.Single,System.Collections.Generic.KeyValuePair{System.Single,System.Single}},System.Single)">
            <summary>
            comparison check with difference between 2 triples of floats
            </summary>
            <param name="_f">floats</param>
            <param name="_c">checks</param>
            <param name="_difference">difference</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckEqualTriple(System.Collections.Generic.KeyValuePair{System.Double,System.Collections.Generic.KeyValuePair{System.Double,System.Double}},System.Collections.Generic.KeyValuePair{System.Double,System.Collections.Generic.KeyValuePair{System.Double,System.Double}})">
            <summary>
            comparison check between 2 triples of floats
            </summary>
            <param name="_f">doubles</param>
            <param name="_c">checks</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDeviationTriple(System.Collections.Generic.KeyValuePair{System.Double,System.Collections.Generic.KeyValuePair{System.Double,System.Double}},System.Collections.Generic.KeyValuePair{System.Double,System.Collections.Generic.KeyValuePair{System.Double,System.Double}},System.Double)">
            <summary>
            comparison check with deviation between 2 triples of floats
            </summary>
            <param name="_f">doubles</param>
            <param name="_c">checks</param>
            <param name="_deviation">deviation</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckDifferenceTriple(System.Collections.Generic.KeyValuePair{System.Double,System.Collections.Generic.KeyValuePair{System.Double,System.Double}},System.Collections.Generic.KeyValuePair{System.Double,System.Collections.Generic.KeyValuePair{System.Double,System.Double}},System.Double)">
            <summary>
            comparison check with difference between 2 triples of floats
            </summary>
            <param name="_f">doubles</param>
            <param name="_c">checks</param>
            <param name="_difference">difference</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ArrayResizeInEditorWindow``1(``0[],System.Int32@)">
            <summary>
            resizes the array well keeping the still present original values for an array in the editor window
            </summary>
            <typeparam name="T">array type</typeparam>
            <param name="_array">array that is resized</param>
            <param name="_size">reference to the new size of the array</param>
            <returns>array</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheck(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            contains check integer
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheck(System.Collections.Generic.IEnumerable{System.Single},System.Single)">
            <summary>
            contains check float
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheck(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            contains check double
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheck(System.Collections.Generic.IEnumerable{UnityEngine.Vector3},UnityEngine.Vector3)">
            <summary>
            contains check vector3
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheck(System.Collections.Generic.IEnumerable{u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DVector3)">
            <summary>
            contains check vector3
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheck``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            contains check component
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheckObject``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            contains check unity object
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsCheck(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            contains check string
            </summary>
            <param name="_array">enumerator</param>
            <param name="_value">check value</param>
            <returns>if contains</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T">component</typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``2(System.Collections.Generic.Dictionary{``0,``1},``1)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1">component</typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheckObject``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T">object</typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheckObject``2(System.Collections.Generic.Dictionary{``0,``1},``1)">
            <summary>
            object contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1">object</typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Generic.Dictionary{System.Int32,``0},System.Int32)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Generic.Dictionary{``0,System.Int32},System.Int32)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Generic.Dictionary{System.Single,``0},System.Single)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Generic.Dictionary{``0,System.Single},System.Single)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Generic.Dictionary{System.Double,``0},System.Double)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Generic.Dictionary{``0,System.Double},System.Double)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Generic.Dictionary{System.String,``0},System.String)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Generic.Dictionary{``0,System.String},System.String)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Generic.Dictionary{UnityEngine.Vector3,``0},UnityEngine.Vector3)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Generic.Dictionary{``0,UnityEngine.Vector3},UnityEngine.Vector3)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Generic.Dictionary{u040.prespective.math.doubles.DVector3,``0},u040.prespective.math.doubles.DVector3)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Generic.Dictionary{``0,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DVector3)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T">component</typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``1)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1">component</typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheckObject``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T">object</typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheckObject``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``1)">
            <summary>
            object contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1">object</typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,``0},System.Int32)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Concurrent.ConcurrentDictionary{``0,System.Int32},System.Int32)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Concurrent.ConcurrentDictionary{System.Single,``0},System.Single)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Concurrent.ConcurrentDictionary{``0,System.Single},System.Single)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Concurrent.ConcurrentDictionary{System.Double,``0},System.Double)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Concurrent.ConcurrentDictionary{``0,System.Double},System.Double)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Concurrent.ConcurrentDictionary{System.String,``0},System.String)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Concurrent.ConcurrentDictionary{``0,System.String},System.String)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Concurrent.ConcurrentDictionary{UnityEngine.Vector3,``0},UnityEngine.Vector3)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Concurrent.ConcurrentDictionary{``0,UnityEngine.Vector3},UnityEngine.Vector3)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsKeyCheck``1(System.Collections.Concurrent.ConcurrentDictionary{u040.prespective.math.doubles.DVector3,``0},u040.prespective.math.doubles.DVector3)">
            <summary>
            component contains in dictionary keys check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ContainsValueCheck``1(System.Collections.Concurrent.ConcurrentDictionary{``0,u040.prespective.math.doubles.DVector3},u040.prespective.math.doubles.DVector3)">
            <summary>
            component contains in dictionary values check
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_check">value to check</param>
            <returns>contains check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Int32[],System.Int32)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Collections.Generic.List{System.Single},System.Single)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Single[],System.Single)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Collections.Generic.List{System.Double},System.Double)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Double[],System.Double)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.String[],System.String)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(System.Collections.Generic.List{UnityEngine.Vector3},UnityEngine.Vector3)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex(UnityEngine.Vector3[],UnityEngine.Vector3)">
            <summary>
            find index of value
            </summary>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            find index of value
            </summary>
            <typeparam name="T">component type</typeparam>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndex``1(``0[],``0)">
            <summary>
            find index of value
            </summary>
            <typeparam name="T">component type</typeparam>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndexObject``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            find index of value
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindIndexObject``1(``0[],``0)">
            <summary>
            find index of value
            </summary>
            <typeparam name="T">object type</typeparam>
            <param name="_input">enumerable</param>
            <param name="_value">value to find</param>
            <returns>index (-1 is no index found)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnKey``1(System.Collections.Generic.Dictionary{System.Int32,``0},System.Int32,System.Collections.Generic.KeyValuePair{System.Int32,``0}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnValue``1(System.Collections.Generic.Dictionary{``0,System.Int32},System.Int32,System.Collections.Generic.KeyValuePair{``0,System.Int32}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnKey``1(System.Collections.Generic.Dictionary{System.Single,``0},System.Single,System.Collections.Generic.KeyValuePair{System.Single,``0}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnValue``1(System.Collections.Generic.Dictionary{``0,System.Single},System.Single,System.Collections.Generic.KeyValuePair{``0,System.Single}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnKey``1(System.Collections.Generic.Dictionary{System.Double,``0},System.Double,System.Collections.Generic.KeyValuePair{System.Double,``0}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnValue``1(System.Collections.Generic.Dictionary{``0,System.Double},System.Double,System.Collections.Generic.KeyValuePair{``0,System.Double}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnKey``1(System.Collections.Generic.Dictionary{System.String,``0},System.String,System.Collections.Generic.KeyValuePair{System.String,``0}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnValue``1(System.Collections.Generic.Dictionary{``0,System.String},System.String,System.Collections.Generic.KeyValuePair{``0,System.String}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnKey``1(System.Collections.Generic.Dictionary{UnityEngine.Vector3,``0},UnityEngine.Vector3,System.Collections.Generic.KeyValuePair{UnityEngine.Vector3,``0}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnValue``1(System.Collections.Generic.Dictionary{``0,UnityEngine.Vector3},UnityEngine.Vector3,System.Collections.Generic.KeyValuePair{``0,UnityEngine.Vector3}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnKey``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnValue``2(System.Collections.Generic.Dictionary{``0,``1},``1,System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnKeyObject``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindDictionairyValueOnValueObject``2(System.Collections.Generic.Dictionary{``0,``1},``1,System.Collections.Generic.KeyValuePair{``0,``1}@)">
            <summary>
            find value of dictionary
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T1"></typeparam>
            <param name="_dict">dictionary</param>
            <param name="_compare">compare value</param>
            <param name="_result">resulting found value</param>
            <returns>if found value</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetGoodPath(System.String,System.String,System.String,System.String,System.Boolean)">
            <summary>
            makes correct path for inputs
            </summary>
            <param name="_name">file name</param>
            <param name="_folderPath">folder path</param>
            <param name="_extention">extension (.mat, .asset, ....)</param>
            <param name="_defaultName">name to take if it has no name</param>
            <param name="_overwrite">over writes a file if present</param>
            <returns>path</returns>
        </member>
        <member name="F:u040.prespective.utility.PreSpectiveUtility.applicationPath">
            <summary>
            Buffer to facilitate calling from off-thread
            </summary>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetApplicationPath">
            <summary>
            gets the path to the application (the one below the asset folder)
            </summary>
            <returns>application path (ends on /)</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetRelativeScenePath">
            <summary>
            Returns the Scene Path relative to the Asset Folder
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckPathStandardAsset(System.String)">
            <summary>
            checks if this is a standard asset of unity
            </summary>
            <param name="_path">asset path</param>
            <returns>if standard asset</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CheckPathPrefab(System.String)">
            <summary>
            checks if it is a path of a prefab
            </summary>
            <param name="_path">path</param>
            <returns>if prefab</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetUnityProjectFolderPath(System.String,System.String@)">
            <summary>
            gets folder path from asset folder of given path
            </summary>
            <param name="_path">path</param>
            <param name="_folderPath">folder path from asset folder</param>
            <returns>if found folder path from asset folder</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.TurnOffColliders(System.Collections.Generic.List{UnityEngine.Transform})">
            <summary>
            turns off the colliders that are not part of the measurement
            </summary>
            <param name="_listOfTransformsToIgnore">list of transforms that must be ignored</param>
            <returns>colliders that are turned off</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.TurnOffColliders(System.Collections.Generic.List{UnityEngine.GameObject})">
            <summary>
            turns off the colliders that are not part of the measurement
            </summary>
            <param name="_listOfGameObjectsToIgnore">list of game objects that must be ignored</param>
            <returns>colliders that are turned off</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.AddingCollidersToMeshes(UnityEngine.Transform[],System.Collections.Generic.List{UnityEngine.GameObject}@,System.Collections.Generic.List{UnityEngine.GameObject}@,System.Collections.Generic.List{UnityEngine.GameObject}@)">
            <summary>
            adds the mesh colliders to mesh in given game objects and their children (if empty array it is done for all game objects in the scene)
            and turns off the colliders that are not necessary
            </summary>
            <param name="_tr">the transform and their children to adds mesh colliders to if empty it takes all the game objects in the scene</param>
            <param name="_addedColliders">result of game objects with colliders added to them</param>
            <param name="_turnedOffColliders">result of game objects with their colliders turned off</param>
            <param name="_turnedOnColliders">result of game objects with their colliders turned on</param>
            <returns>mesh found here for the measurement</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.AddingCollidersToMeshes(UnityEngine.GameObject[],System.Collections.Generic.List{UnityEngine.GameObject}@,System.Collections.Generic.List{UnityEngine.GameObject}@,System.Collections.Generic.List{UnityEngine.GameObject}@)">
            <summary>
            adds the mesh colliders to mesh in given game objects and their children (if empty array it is done for all game objects in the scene)
            and turns off the colliders that are not necessary
            </summary>
            <param name="_ngo">the game objects and their children to adds mesh colliders to if empty it takes all the game objects in the scene</param>
            <param name="_addedColliders">result of game objects with colliders added to them</param>
            <param name="_turnedOffColliders">result of game objects with their colliders turned off</param>
            <param name="_turnedOnColliders">result of game objects with their colliders turned on</param>
            <returns>mesh found here for the measurement</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ResetColliders(System.Collections.Generic.List{UnityEngine.GameObject},System.Collections.Generic.List{UnityEngine.GameObject},System.Collections.Generic.List{UnityEngine.GameObject})">
            <summary>
            puts the colliders back into the original configuration
            </summary>
            <param name="_addedColliders">game objects with colliders added to them</param>
            <param name="_turnedOffColliders">game objects with colliders turned off</param>
            <param name="_turnedOnColliders">game objects with colliders turned on</param>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ResetColliders(System.Collections.Generic.List{UnityEngine.Transform},System.Collections.Generic.List{UnityEngine.Transform})">
            <summary>
            puts the colliders back into the original configuration
            </summary>
            <param name="_addedColliders">transforms with colliders added to them</param>
            <param name="_turnedOffColliders">transforms with colliders turned of</param>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetCentreMeshGlobalSpace(UnityEngine.GameObject,System.Boolean)">
            <summary>
            gets centre mesh in global space
            </summary>
            <param name="_go">game object</param>
            <param name="_checkChildren">gets the average centre based on children and itself</param>
            <returns>centre</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetCentreMeshGlobalSpace(UnityEngine.MeshFilter)">
            <summary>
            gets centre mesh in global space
            </summary>
            <param name="_mf">mesh filter</param>
            <returns>centre</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.VerticeLimitCheck(UnityEngine.Mesh)">
            <summary>
            finds the vertex limit of mesh and gives warning if exceeded it
            </summary>
            <param name="_mesh">mesh</param>
            <returns>if vertex limit reached</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetWorldSpaceScale(UnityEngine.Transform)">
            <summary>
            gets world space scale
            </summary>
            <param name="_t">transform</param>
            <returns>world space scale</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetWorldSpaceInverseScale(UnityEngine.Transform)">
            <summary>
            gets world space inverse scale
            </summary>
            <param name="_t">transform</param>
            <returns>world space inverse scale</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetPlanarNormalDouble(UnityEngine.Vector3,UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>
            gets the planar normal with double precision
            </summary>
            <param name="_v1">first point</param>
            <param name="_v2">second point</param>
            <param name="_v3">third point</param>
            <returns>planar normal</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetPlanarNormalDouble(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3)">
            <summary>
            gets the planar normal with double precision
            </summary>
            <param name="_v1">first point</param>
            <param name="_v2">second point</param>
            <param name="_v3">third point</param>
            <returns>planar normal</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindOuterVertices(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Double@,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3[]}@,System.Collections.Generic.List{UnityEngine.Vector2Int}@)">
            <summary>
            finds the outer vertices
            </summary>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_perimeter">perimeter</param>
            <param name="_outerEdges">outer edges</param>
            <param name="_outerVerticeIndices">vertex indices of outer edges</param>
            <returns>outer vertices</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindOuterVertices(System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Collections.Generic.List{System.Int32},System.Double@,System.Collections.Generic.List{u040.prespective.math.doubles.DVector3[]}@,System.Collections.Generic.List{UnityEngine.Vector2Int}@)">
            <summary>
            finds the outer vertices and the perimeter
            </summary>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_triIndeces">triangle indices of normal surface</param>
            <param name="_perimeter">perimeter</param>
            <param name="_outerEdges">outer edges</param>
            <param name="_outerVerticeIndices">vertex indices of outer edges</param>
            <returns>outer vertices</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.checkEdge(System.Int32,System.Int32,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,System.Int32[],u040.prespective.math.doubles.DVector3[])">
            <summary>
            check if it has the edge vert1, vert2
            </summary>
            <param name="_tri1">triangle index 1</param>
            <param name="_tri2">triangle index 2</param>
            <param name="_vert1">vertex 1</param>
            <param name="_vert2">vertex 2</param>
            <param name="_triCheck">array of length 3 with the triangle indices to check</param>
            <param name="_vertCheck">array of length 3 with the vertices to check</param>
            <returns>check</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.OrderOuterVetices(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3[]})">
            <summary>
            orders the outer vertices along the edges
            </summary>
            <param name="_outerEgdes">outer edges</param>
            <returns>ordered outer vertices</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.OrderOuterVeticesWithMaximumDistance(System.Collections.Generic.List{u040.prespective.math.doubles.DVector3[]},System.Double)">
            <summary>
            orders the outer vertices along the edges with in indicated maximum distance between vertices to been seen as on the same position
            WARNING this function should preferably not be used it should only be used with vertices that are made with a floating point error in all other cases use orderOuterVetices
            </summary>
            <param name="_outerEgdes">outer edges</param>
            <param name="_maximumDistance">maximum distance allowed between edge points</param>
            <returns>ordered outer vertices</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindNormalSurface(UnityEngine.Transform,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Double,System.Boolean,System.Boolean)">
            <summary>
            finds normal surfaces
            </summary>
            <param name="_t">transform of mesh</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_angleDiff">maximum angle difference allowed within normal planes in degrees</param>
            <param name="_withProgressBar">if progress bar should be shown in this part if false it is shown in the triangle matching part and not here else if true only here</param>
            <param name="_cancelableProgressBar">if progress bar is cancel-able</param>
            <returns>list of normal surfaces with their normal if cancelled returns null</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindNormalSurface(UnityEngine.Transform,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Collections.Generic.List{System.Int32},System.Double,System.Boolean,System.Boolean)">
            <summary>
            finds normals surface of a given number of triangle indices
            </summary>
            <param name="_t">transform of mesh</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_triIndices">triangle indices to check over</param>
            <param name="_angleDiff">maximum angle difference allowed within normal planes in degrees</param>
            <param name="_withProgressBar">if progress bar should be shown in this part if false it is shown in the triangle matching part and not here else if true only here</param>
            <param name="_cancelableProgressBar">if progress bar is cancel-able</param>
            <returns>list of normal surfaces with their normal if cancelled returns null</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindNormalSurface(u040.prespective.math.doubles.DMatrix4x4,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Double,System.Boolean,System.Boolean)">
            <summary>
            finds normal surfaces
            </summary>
            <param name="_localToWorld">local to world matrix of mesh</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_angleDiff">maximum angle difference allowed within normal planes in degrees</param>
            <param name="_withProgressBar">if progress bar should be shown in this part if false it is shown in the triangle matching part and not here else if true only here</param>
            <param name="_cancelableProgressBar">if progress bar is cancel-able</param>
            <returns>list of normal surfaces with their normal if cancelled returns null</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindNormalSurface(u040.prespective.math.doubles.DMatrix4x4,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Collections.Generic.List{System.Int32},System.Double,System.Boolean,System.Boolean)">
            <summary>
            finds normals surface of a given number of triangle indices
            </summary>
            <param name="_localToWorld">local to world matrix of mesh</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_triIndices">triangle indices to check over</param>
            <param name="_angleDiff">maximum angle difference allowed within normal planes in degrees</param>
            <param name="_withProgressBar">if progress bar should be shown in this part if false it is shown in the triangle matching part and not here else if true only here</param>
            <param name="_cancelableProgressBar">if progress bar is cancel-able</param>
            <returns>list of normal surfaces with their normal if cancelled returns null</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.processTriangleForNormalSurface(System.Int32,System.Int32,System.Single,u040.prespective.math.doubles.DMatrix4x4,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Double,System.Boolean,System.Boolean,System.Boolean[]@,System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{u040.prespective.math.doubles.DVector3,System.Collections.Generic.List{System.Int32}}}@)">
            <summary>
            processes a single triangle to get triangle surface
            </summary>
            <param name="_index">index triangle</param>
            <param name="_progressBarIndex">index for progress bar</param>
            <param name="_total">total for progress bar</param>
            <param name="_localToWorld">local to world matrix of mesh</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_angleDiff">maximum angle difference allowed within normal planes in degrees</param>
            <param name="_withProgressBar">if progress bar should be shown in this part if false it is shown in the triangle matching part and not here else if true only here</param>
            <param name="_cancelableProgressBar">if progress bar is cancel-able</param>
            <param name="_checkedTriangles">triangles that are already checked</param>
            <param name="_normalPlanes">normal planes found</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetNormalSurfaceOfTriIndex(System.Int32,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Double,System.Boolean[]@,System.Boolean,System.Boolean)">
            <summary>
            gets a list of triangle indices that are connected to the given triangle index within an normal planer angle difference
            </summary>
            <param name="_triIndex">triangle index to build from</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_angleDiff">maximum angle difference allowed within normal planes in degrees</param>
            <param name="_checkedNormals">already added boolean array indication is reference to give back the ones found here</param>
            <param name="_withProgressBar">if progress bar should be shown</param>
            <param name="_cancelableProgressBar">if progress bar is cancel-able</param>
            <returns>found triangle indices connected if cancelled returns null</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.getTriangleNeighbours(System.Int32,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,System.Int32},System.Collections.Concurrent.ConcurrentDictionary{System.Int32,u040.prespective.math.doubles.DVector3},System.Boolean[],System.Double)">
            <summary>
            finds the triangle's neighbours
            </summary>
            <param name="_triIndexToCheck">triangle index to compare</param>
            <param name="_tri">triangles</param>
            <param name="_vert">vertices</param>
            <param name="_checkedNormals">already added boolean array indication</param>
            <param name="_angleDifference">maximum angle difference allowed within normal planes in degrees</param>
            <returns>list triangle indices</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetTransformFromTransformPath(System.String,UnityEngine.Transform@,UnityEngine.Transform,System.Boolean,System.String,System.Char)">
            <summary>
            Returns whether a transform was found at the forwarded hierarchical path; either starting at the scene root or at the _head transform level
            </summary>
            <param name="_transfromPath">the path (formatted as [parentTransformName][_indexSplitter][siblingIndex]/[childTransformName][_indexSplitter][siblingIndex]/..</param>
            <param name="_foundTransform">Output transform found after traversing the path</param>
            <param name="_head">optional parent or head transform to start looking (relative path)</param>
            <param name="_ignoreSiblingIndex">whether we want to ignore looking at the sibling index - making the lookup less rigid, but also more at risk of false positives</param>
            <param name="_indexSplitter">the splitter characters between transform name and sibling index - default '#*#'</param>
            <param name="_nestingSplitter">the splitter character between parent and child transforms</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.transformInterration(System.String,System.Int32,System.String[],System.Int32,UnityEngine.Transform,System.Boolean,System.String,System.Char,UnityEngine.Transform@)">
            <summary>
            goes checks if parent is equal to given path and then checks if it needs to check its children
            </summary>
            <param name="_path">given path</param>
            <param name="_index">index of next path part</param>
            <param name="_brokenPaths">paths broken up</param>
            <param name="_amountBrokenPaths">amount of broken paths</param>
            <param name="_toCheck">transform to check</param>
            <param name="_ignoreSiblingIndex">whether we want to ignore looking at the sibling index - making the lookup less rigid, but also more at risk of false positives</param>
            <param name="_indexSplitter">the splitter characters between transform name and sibling index</param>
            <param name="_nestingSplitter">the splitter character between parent and child transforms</param>
            <param name="_foundTransform">transform found connected to transform path</param>
            <returns>if found transform</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetTransformPathFromTransform(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            gets a transform path of a transform to given parent
            </summary>
            <param name="_t">transform</param>
            <param name="_parent">parent</param>
            <returns>transform path</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.getPathAndIndexToParent(UnityEngine.Transform,UnityEngine.Transform,System.String,System.String,System.Char)">
            <summary>
            makes the transform path
            </summary>
            <param name="_toIndex">transform the index from</param>
            <param name="_parent">parent to stop indexing at</param>
            <param name="_pathResult">already made path</param>
            <param name="_indexSplitter">index splitter</param>
            <param name="_nestingSplitter">nesting splitter</param>
            <returns>transform path</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.getTransformPathString(UnityEngine.Transform,System.String,System.Char)">
            <summary>
            get transforms string path description
            </summary>
            <param name="_transform">transform</param>
            <param name="_indexSplitter">index splitter</param>
            <param name="_nestingSplitter">nesting splitter</param>
            <returns>transform string path</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetHierarchyDepth(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            get hierarchy depth of transform
            </summary>
            <param name="_t">transform</param>
            <param name="_parent">parent to stop indexing at</param>
            <returns>hierarchy depth</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.getDepth(UnityEngine.Transform,UnityEngine.Transform,System.Int32)">
            <summary>
            creates the hierarchy depth
            </summary>
            <param name="_toIndex">transform the index from</param>
            <param name="_parent">parent to stop indexing at</param>
            <param name="_depthLevel">depth level your at</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetGameobjectsFromTransformPaths(System.String[],System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,UnityEngine.Transform}},UnityEngine.GameObject[]@,System.Exception@)">
            <summary>
            gets the game objects connected to transform paths
            </summary>
            <param name="_ntp">transform paths</param>
            <param name="_connections">connections</param>
            <param name="_ngo">game objects</param>
            <param name="_error">exceptions</param>
            <returns>if successful</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindTransformFromTransformPath(System.String,System.Collections.Generic.List{System.Collections.Generic.KeyValuePair{System.String,UnityEngine.Transform}})">
            <summary>
            finds the transform connected to the transform path
            </summary>
            <param name="_path">transform path</param>
            <param name="_connections">connections</param>
            <returns>transform</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FolderNameCheck(System.String)">
            <summary>
            checks the folder name for illegal characters and returns the folder name without illegal characters
            </summary>
            <param name="_folderName">folder name</param>
            <returns>clean folder name</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FileNameCheck(System.String)">
            <summary>
            checks the file name for illegal characters and returns the file name without illegal characters
            </summary>
            <param name="_fileName">file name</param>
            <returns>clean file name</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.StoringNameCheckAndFix(System.String,System.String)">
            <summary>
            checks if this name in part of the storing pattern and then just updates the iterator in pattern
            </summary>
            <param name="_name">name to check</param>
            <param name="_prefixCheck">prefix to check if present</param>
            <returns>corrected name</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.CreateOrAddComponent``1(UnityEngine.GameObject)">
            <summary>
            gets the component when it exists or creates the component when it doesn't.
            </summary>
            <param name="_gameObject"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.TransformLocalPoint(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            transform point of a local point
            </summary>
            <param name="_transform">transform</param>
            <param name="_point">local point</param>
            <returns>global point</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.InverseTransformLocalPoint(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            inverse transform point of global point
            </summary>
            <param name="_transform">transform</param>
            <param name="_point">global point</param>
            <returns>local point</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.TransformLocalDirection(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            transform direction of local direction
            </summary>
            <param name="_transform">transform</param>
            <param name="_direction">local direction</param>
            <returns>global direction</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.InverseTransformLocalDirection(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            inverse transform direction of global direction
            </summary>
            <param name="_transform">transform</param>
            <param name="_direction">global direction</param>
            <returns>local direction</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.TransformLocalVector(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            transform vector of local vector
            </summary>
            <param name="_transform">transform</param>
            <param name="_vector">local vector</param>
            <returns>global vector</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetStandardUnityMaterial">
            <summary>
            gets the Unity standard material
            </summary>
            <returns>Unity standard material</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ProcessMaterialPath(System.String)">
            <summary>
            process the material path in case of default material en returns material from material path
            </summary>
            <param name="_path">material path</param>
            <returns>material</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetTypeOfMesh(UnityEngine.MeshFilter,System.String)">
            <summary>
            determines mesh type of mesh
            </summary>
            <param name="_mf">mesh filter</param>
            <param name="_path">path of mesh</param>
            <returns>type of mesh</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindTypeOfStanderMesh(UnityEngine.Mesh)">
            <summary>
            finds type of standard mesh
            </summary>
            <param name="_mf">mesh filter</param>
            <returns>type of standard mesh</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.ProcessMeshPath(System.String,u040.prespective.utility.MeshType)">
            <summary>
            process the mesh path in case of default mesh en returns mesh from mesh path
            </summary>
            <param name="_path">mesh path</param>
            <param name="_standardMeshType">type of standard mesh stored here if standard mesh</param>
            <returns>mesh</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetDefaultMesh(u040.prespective.utility.MeshType)">
            <summary>
            get a standard mesh
            </summary>
            <param name="_typeOfDefaultMesh">type of standard mesh</param>
            <returns>mesh</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.InverseTransformLocalVector(UnityEngine.Transform,UnityEngine.Vector3)">
            <summary>
            inverse transform vector of global vector
            </summary>
            <param name="_transform">transform</param>
            <param name="_vector">global vector</param>
            <returns>local vector</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.AddComponentToSelection(System.Type,System.String,System.Boolean,System.Nullable{UnityEngine.PrimitiveType})">
            <summary>
            Add a component to a selected GameObject or create a new GameObject if none are selected.
            </summary>
            <param name="_t1"></param>
            <param name="_gameObjectName">The name of the GameObject for when a new one is created</param>
            <param name="_preventMultiple">Prevent the component from being created if one already exists</param>
            <param name="_primitiveType">The primitive type of the GameObject if a new GameObject is created</param>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindLowestSharedParent(System.Collections.Generic.List{UnityEngine.Transform},System.Boolean)">
            <summary>
            finds the lowest shared parent
            </summary>
            <param name="_transforms">transforms to find lowest shared parent of</param>
            <param name="_excludeSelf">if self cannot be a shared parent</param>
            <returns>lowest shared parent</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindLowestSharedParent(System.Collections.Generic.List{UnityEngine.GameObject},System.Boolean)">
            <summary>
            finds the lowest shared parent
            </summary>
            <param name="_gameObjects">game objects to find lowest shared parent of</param>
            <param name="_excludeSelf">if self cannot be a shared parent</param>
            <returns>lowest shared parent</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.FindLowestSharedParent(System.Collections.Generic.List{System.Collections.Generic.List{UnityEngine.Transform}})">
            <summary>
            finds the lowest shared parent
            </summary>
            <param name="_parentStructures">parent structures to find lowest shared parent of (is from the lowest to highest in hierarchy)</param>
            <returns>lowest shared parent</returns>
        </member>
        <member name="M:u040.prespective.utility.PreSpectiveUtility.GetParentStructure(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            gets all the parents of a transform to a certain parent
            </summary>
            <param name="_transformToProcess">transform</param>
            <param name="_endParent">parent to stop at</param>
            <returns>parent structure (lowest in hierarchy to highest in hierarchy)</returns>
        </member>
        <member name="T:u040.prespective.utility.TraingleHitrecord">
            <summary>
            this is used to document the ray cast hits of the model
            </summary>
        </member>
        <member name="F:u040.prespective.utility.TraingleHitrecord.GameObject">
            <summary>
            game object connected to hit triangle
            </summary>
        </member>
        <member name="F:u040.prespective.utility.TraingleHitrecord.TriangleIndicesHits">
            <summary>
            keys are triangle index value is if it has been hit
            </summary>
        </member>
        <member name="F:u040.prespective.utility.TraingleHitrecord.NumberOfHits">
            <summary>
            number of hits
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.TraingleHitrecord.#ctor(UnityEngine.GameObject)" -->
        <member name="T:u040.prespective.utility.editorui.customuifields.ReadOnlyAttribute">
            <summary>
            source : https://answers.unity.com/questions/489942/how-to-make-a-readonly-property-in-inspector.html
            Display a field as read-only in the inspector.
            CustomPropertyDrawers will not work when this attribute is used.
            </summary>
            <seealso cref="T:u040.prespective.utility.editorui.customuifields.BeginReadOnlyGroupAttribute"/>
            <seealso cref="T:u040.prespective.utility.editorui.customuifields.EndReadOnlyGroupAttribute"/>
        </member>
        <member name="T:u040.prespective.utility.editorui.customuifields.BeginReadOnlyGroupAttribute">
            <summary>
            source : https://answers.unity.com/questions/489942/how-to-make-a-readonly-property-in-inspector.html
            Display one or more fields as read-only in the inspector.
            Use <see cref="T:u040.prespective.utility.editorui.customuifields.EndReadOnlyGroupAttribute"/> to close the group.
            Works with CustomPropertyDrawers.
            </summary>
            <seealso cref="T:u040.prespective.utility.editorui.customuifields.EndReadOnlyGroupAttribute"/>
            <seealso cref="T:u040.prespective.utility.editorui.customuifields.ReadOnlyAttribute"/>
        </member>
        <member name="T:u040.prespective.utility.editorui.customuifields.EndReadOnlyGroupAttribute">
            <summary>
            source : https://answers.unity.com/questions/489942/how-to-make-a-readonly-property-in-inspector.html
            Use with <see cref="T:u040.prespective.utility.editorui.customuifields.BeginReadOnlyGroupAttribute"/>.
            Close the read-only group and resume editable fields.
            </summary>
            <seealso cref="T:u040.prespective.utility.editorui.customuifields.BeginReadOnlyGroupAttribute"/>
            <seealso cref="T:u040.prespective.utility.editorui.customuifields.ReadOnlyAttribute"/>
        </member>
        <member name="T:u040.prespective.utility.editorui.customuifields.ButtonAttribute">
            <summary>
            @CLASS : InspectorButtonAttribute
            
            @ABOUT : Custom Attribute that replaces a 'bool' field for a button in the inspector
            
            @HOWTOUSE:
                0) Make sure this script is somewhere in your project
                1) Add a public boolean to your class
                2) Add this attribute to the boolean, e.g.:
            
                    [InspectorButton("FunctionToInvoke", "OptionalVisibilityToggle")]
                    public bool loadFromPatchPreferences;
            
                Note that: the first parameter string is the name of the function to invoke (within that class)
                           the second (Optional) parameter string is the name of the public boolean (within that class)
                           to toggle the button between visible and invisible
                           
                3) add the function to invoke to your class as a private void, e.g.
            
                private void FunctionToInvoke()
                    {
                    //Do something when the button is pressed
                    }
                    
            @AUTHOR : Pieter (Unit040)
            
            @SOURCE : https://github.com/zaikman/UnityPublic/blob/master/InspectorButton.cs
            
            @VERSION : 1.00 - Added second attribute to toggle visibility
            </summary>
            
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.ButtonAttribute.kDefaultButtonWidth">
            <summary>
            The Default button width to use
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.ButtonAttribute.METHOD_NAME">
            <summary>
            The string signifying the method to call
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.ButtonAttribute.HIDE_FIELD_TOGGLE">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.utility.editorui.customuifields.ButtonAttribute.ButtonWidth">
            <summary>
            Getter/Setter setup for the button width (Required for button (optional) options)
            </summary>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.ButtonAttribute.#ctor(System.String,System.String)">
            <summary>
            Attribute Constructor
            </summary>
            <param name="_methodToCall">the name of the method to call in this class when the button is pressed</param>
            <param name="_hideFieldToggle">(optional) the name of the field used to toggle the visibility of this field</param>
            <param name="_actWidth">(Optional) the desired width of this button</param>
        </member>
        <member name="T:u040.prespective.utility.editorui.customuifields.PropertyFieldDelegates">
            <summary>
            Data class for Prespective property drawer.
            </summary>
        </member>
        <member name="T:u040.prespective.utility.editorui.customuifields.HideAttribute">
            <summary>
            @CLASS : HideAttribute
            
            @ABOUT : Property attribute to enable you to hide a property field based on the value of a bool field value in the same class
            
            @AUTHOR: Pieter (Unit040)
            
            @VERSION: 1.01 - Refactored to work with the CustomPD class
            </summary>
        </member>
        <member name="T:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog">
            <summary>
            A display dialog box that pops in build and editor mode. Takes in a title text, message text along with a true and false text as input and returns a boolean based on the button selected.
            
            <para>Copyright (c) 2015-2022 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="T:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.ButtonStatus">
            <summary>
            Stores the status of the button
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.currentButtonDialogStatus">
            <summary>
            Stores the current status of the button.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.acceptText">
            <summary>
            The text that is added on the first button.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.rejectText">
            <summary>
            The text that is added on the first button.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.titlePosition">
            <summary>
            Stores the position of the title in a Rect Transform.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.title">
            <summary>
            The Title GameObject.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.titleText">
            <summary>
            The text of the Title.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.background">
            <summary>
            The background GameObject.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.backgroundImage">
            <summary>
            The background image.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.colorRGB">
            <summary>
            The color scheme for the background of the display dialog.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.backgroundPosition">
            <summary>
            Stores the position of the background in a Rect Transform.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.message">
            <summary>
            The message game object.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.messageText">
            <summary>
            The message Text.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.dialogContainer">
            <summary>
            The Dialog container game object.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.myCanvas">
            <summary>
            The Canvas over which the display dialog box will be drawn.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.canvasScaler">
            <summary>
            The Scaler to the canvas.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.buttonImage">
            <summary>
            The image of the button.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.button">
            <summary>
            The button that will be instantiated later.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.textfield">
            <summary>
            The text filed stored in the game object.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.spriteName">
            <summary>
            The name of the sprite.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.fontName">
            <summary>
            The font of the text to be written on the display dialog box.
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.backgroundSpriteName">
            <summary>
            The name of the background sprite.
            </summary>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.buttonInstantiation(UnityEngine.GameObject,System.String,System.String,u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.ButtonStatus)">
            <summary>
            Instantiates a button, adds all the visual elements to it and adds a listener to it.
            </summary>
            <param name="_visualElement"></param>
            <param name="_text"></param>
            <param name="_buttonName"></param>
            <param name="_status"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.titleInstantiationAndPosition(UnityEngine.GameObject,System.String)">
            <summary>
            Creates a title with the specified visuals for the display dialog and positions it at a certain location.
            </summary>
            <param name="_visualElement"></param>
            <param name="_titleText"></param>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.backgroundInstantiationAndPosition(UnityEngine.GameObject)">
            <summary>
            Creates a background with the specified visuals like color for the display dialog and positions it at a certain location.
            </summary>
            <param name="_visualElement"></param>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.messageInstantiationAndPosition(UnityEngine.GameObject,System.String)">
            <summary>
            Creates a message with the specified visuals for the display dialog and positions it at a certain location.
            </summary>
            <param name="_visualElement"></param>
            <param name="_messageText"></param>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.canvasInitialization">
            <summary>
            Initializes the canvas for the display dialog box.
            </summary>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.buttonPositioning(UnityEngine.GameObject@,UnityEngine.Vector2,UnityEngine.Vector3)">
            <summary>
            Positions a button at a certain location with respect to the display dialog box.
            </summary>
            <param name="_obj"></param>
            <param name="_vector2"></param>
            <param name="_vector3"></param>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.positioning(UnityEngine.RectTransform,UnityEngine.Vector2,UnityEngine.Vector3)">
            <summary>
            Positions the given rect transform at a certain location.
            </summary>
            <param name="_rectTransform"></param>
            <param name="_vector2"></param>
            <param name="_vector3"></param>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.buttonTextPositioning(UnityEngine.UI.Text@,UnityEngine.Vector2,UnityEngine.Vector3)">
            <summary>
            Positions the text that will be added to a particular button.
            </summary>
            <param name="_text"></param>
            <param name="_vector2"></param>
            <param name="_vector3"></param>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.buttonTextInstantiation(UnityEngine.UI.Text@,System.String)">
            <summary>
            Instantiates the text that will be added to a particular button
            </summary>
            <param name="_buttonText"></param>
            <param name="_text"></param>
        </member>
        <member name="M:u040.prespective.utility.editorui.customuifields.PrespectiveDisplayDialog.DisplayDialog(System.String,System.String,System.String,System.String)">
            <summary>
            A static task that pops up a dialog box with two options, text that explains the title and message and returns a boolean based on the selection made. 
            </summary>
            <param name="_titleText"></param>
            <param name="_messageText"></param>
            <param name="_okText"></param>
            <param name="_cancelText"></param>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.VectorSpace">
            <summary>
            Space used for creating this vector
            </summary>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.VectorDefaultDirections">
            <summary>
            Shorthand directions to use for setting the vector
            </summary>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.SceneVector">
            <summary>
            Helper class for Tracking a Direction in a Specific Transform Space
            
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129545751/SceneVector+-+Track+Direction+in+Specific+Transform+Space"> Documentation </a></para>
            
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version 
                ver="1.0.0" 
                author="PWS, TGE" 
                date="180711">
                -  Implemented setup for global/ parent and child space
            </version>
            <testing>
            [None]
            </testing>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.localParentvector">
            <summary>
            Buffered local parent vector
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.localChildvector">
            <summary>
            buffered local child vector
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.globalVector">
            <summary>
            Buffered Global vector
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.transform">
            <summary>
            Buffered Transform
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.transformPath">
            <summary>
            transform path of connected transform
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.VectorSpace">
            <summary>
            The VectorSpace this vector was stored in
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.TrackingSpace">
            <summary>
            tracking space of vecotr
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.DefaultDirection">
            <summary>
            present default direction
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.VectorColor">
            <summary>
            Color this vector should have in the scene
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.OnVectorChanged">
            <summary>
            what to do if vector changes
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.FoldOutInInspector">
            <summary>
            Whether the vector settings should be folded out in the inspector
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.ShowGizmoInScene">
            <summary>
            whether the gizmo should be visible in the scene
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneVector.VectorLength">
            <summary>
            Forced length of vector. -1f is dynamic.
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.currentSpaceVector">
            <summary>
            Return the vector in in the currently selected space
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneVector.getVectorSpaceVector(UnityEngine.Vector3)">
            <summary>
            get this space here vector from global vector
            </summary>
            <param name="_globalVector">global vector</param>
            <returns>this space vector</returns>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.GlobalVector">
            <summary>
            Return the global vector
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.localVector">
            <summary>
            Return the local vector
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.localChildVector">
            <summary>
            return local child vector
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.HasTransform">
            <summary>
            if scene vector has a transform stored
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.SilentLocalVector">
            <summary>
            Set the vector locally without triggering a Vector changed event
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.SilentGlobalVector">
            <summary>
            Set the global vector without triggering a Vector changed event
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneVector.connectedTransform">
            <summary>
            gets the connected transform and if none found check if it can reattach one
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneVector.#ctor(UnityEngine.Vector3,u040.prespective.utility.scenemanagement.VectorSpace,UnityEngine.Transform)">
            <summary>
            Default constructor for the Scene Vector
            </summary>
            <param name="_value">Value used for the vector</param>
            <param name="_space">whether the supplied vector is in local or global space</param>
            <param name="_t">transform connected to scene vector</param>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneVector.setVector(UnityEngine.Vector3,u040.prespective.utility.scenemanagement.VectorSpace,UnityEngine.Transform)">
            <summary>
            Actually set the vectors
            </summary>
            <param name="_vector"></param>
            <param name="_space">space vector is in</param>
            <param name="_t">transform calculate space in</param>
            <returns>is setting was succesfull</returns>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneVector.interpretVector(UnityEngine.Vector3)">
            <summary>
            Determine if the vector matches a shorthand value
            </summary>
            <param name="_vector">vector to check</param>
            <returns>short hand value</returns>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneVector.castVector(u040.prespective.utility.scenemanagement.VectorDefaultDirections,UnityEngine.Vector3)">
            <summary>
            determines vector depending on short hand
            </summary>
            <param name="_dir">short hand</param>
            <param name="_input">original vector</param>
            <returns>vector connected to short hand</returns>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.PrespectiveSceneViewUtility">
            <summary>
            Utility class to ease coordinate handling in scene view.
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.PrespectiveSceneViewUtility.SceneViewCoordinatesAnchorPoint">
            <summary>
            The corner of the Scene View that represents the coordinate (0,0)
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.PrespectiveSceneViewUtility.ScreenGUIScale">
            <summary>
            Return the value of the GUI scaling.
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.PrespectiveSceneViewUtility.ConvertToDrawingCoordinates(UnityEngine.Vector2,u040.prespective.utility.scenemanagement.PrespectiveSceneViewUtility.SceneViewCoordinatesAnchorPoint,System.Boolean)">
            <summary>
            Convert a point in the scene view in the given coordinate system to the drawing coordinate system. This also accounts for GUI scaling and the SceneView toolbar.
            </summary>
            <param name="_coordinates">The coordinates to convert</param>
            <param name="_anchor">Anchor point to the given coordinate</param>
            <param name="_guiScaled">Whether the given coordinate is being scaled by GUI</param>
            <returns>The converted coordinates</returns>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2">
            <summary>
            Helper class for Tracking/Managing an enumeration of specific child objects
            
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129480212/SceneObjectContainerManager+-+Track+Manage+an+enumeration+of+specific+child+objects"> Documentation </a></para>
            
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version 
                ver="1.0.0" 
                author="PWS" 
                date="191101">
                -  Implemented for managing physical bodies in the scene (FACT)
            </version>
            <testing>
            [None]
            </testing>
            <typeparam name="T1">Monobehavior type specifiying the type managed by this class</typeparam>
            <typeparam name="T2">Type used for monobehavior identification</typeparam>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.OnNewObjectFoundInScene">
            <summary>
            Action Called when a new object was found in this container that was not previously managed by this SceneObjectContainer
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.OnCreateManagedObject">
            <summary>
            Callback override to be invoked when a new managed object should be created
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.OnRemoveManagedObject">
            <summary>
            Callback override to be invoked when managed object is to be removed
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.OnUpdateManagedObject">
            <summary>
            Callback override to be invoked when managed object is to be updated
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.OnDuplicateManagedObject">
            <summary>
            Callback override to be invoked when managed object is to be duplicated
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.containerObjectName">
            <summary>
            Name to use for the object within the parent responsible for managing instances of a specific type
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.defaultContaindObjectName">
            <summary>
            Default name to use for a new contained object created within this container
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.parentTransformPath">
            <summary>
            Path to use for just the parent transform serialization
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2._lastObjectIndex">
            <summary>
            Private time variable used to determine the time past since the last check for new managed Objects
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.parent">
            <summary>
            Lazy setter/getter for the parent transform (due to transform not being serializable in a non-scene class we'll just link it via scene path
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.#ctor(UnityEngine.Transform,System.Func{System.Collections.Generic.List{`0},`1,System.Int32},System.Func{System.Collections.Generic.List{`0},`1})">
            <summary>
            Creates a new SceneObject Container (setting the transform path)
            </summary>
            <param name="_parent"></param>
            <param name="_indexFinder"></param>
            <param name="_keyGenerator"></param>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.GetUniqueKey">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.GetIndexByKey(`1)">
            <summary>
            
            </summary>
            <param name="_key"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.ForceReindexObjects">
            <summary>
            Force reindexing of the managed objects states
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.ManagedObjects">
            <summary>
            Lazy-load a list with the objects this manager contains
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.ContainerGameObject">
            <summary>
            Lazy loader for retrieving a handle to the Container Object for the managed objects
            (Retrieve parent child with name [containerObjectName]; or create when not found)
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.GetIndexWithName">
            <summary>
            Overridable filter function for checking if an object with the sought name is already managed by this manager
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.GetNewUniqueDefaultObjectName">
            <summary>
            Generator to get a new unique default object name
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.InvokeOnCreateManagedObject(`1,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Invocation wrapper for creating a new managed object within this managers' container
            </summary>
            <param name="_key">key to use for the new object</param>
            <param name="_params">any parameters relevant for the creation of a new object</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.InvokeOnRemoveSceneObject(`1,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Invocation wrapper for removing a new managed object within this managers' container
            </summary>
            <param name="_key">key to look for within this manager</param>
            <param name="_params">any parameters relevant for the removal of the object</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.InvokeOnDuplicateSceneObject(`1,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Invocation wrapper for Duplicating a new managed object within this managers' container
            </summary>
            <param name="_key">key to look for within this manager</param>
            <param name="_params">any parameters relevant for the duplication of the object</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.SceneObjectContainerManager`2.InvokeOnUpdateSceneObject(`1,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Invocation wrapper for Updating a managed object within this managers' container
            </summary>
            <param name="_key">key to look for within this manager</param>
            <param name="_params">any parameters relevant for the update of the object</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.CameraUtils">
            <summary>
            
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.CameraUtils.UsingURP">
            <summary>
            Getter to see if the Universal Render Pipeline is used in this Unity project. (value is unserializedly stored)
            </summary>
        </member>
        <member name="P:u040.prespective.utility.scenemanagement.CameraUtils.CurrentCamera">
            <summary>
            Getter for the current camera to work around the fact that Camera.current is not fully supported (yet) with URP. (date: 2023-02-03) 
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.CameraUtils.ZoomToFit(UnityEngine.Camera,UnityEngine.Transform,UnityEngine.Vector2Int,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_cam"></param>
            <param name="_target"></param>
            <param name="_frame"></param>
            <param name="_considerHiddenParts"></param>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.CameraUtils.PanToCenter(UnityEngine.Camera,UnityEngine.Transform,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_cam"></param>
            <param name="_target"></param>
            <param name="_considerHiddenParts"></param>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.CameraUtils.CreateScreenShot(UnityEngine.Camera,UnityEngine.Transform,UnityEngine.Vector2Int,UnityEngine.Rect,System.Int32,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_cam"></param>
            <param name="_target"></param>
            <param name="_size"></param>
            <param name="_fitTarget"></param>
            <param name="_dpi"></param>
            <param name="_considerHiddenParts"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.scenemanagement.TransformTracker">
            <summary>
            Enables a user to track changes in a transform elsewhere in the hierarchy
            
            <para>NOTE : since we track floatingpoint transforms escalating to doubles is not necassary, but this does mean that going beyond a precision of 1e-5 is not prudent</para>
            
            <para>NOTE : this script uses the 'SerializeReference' flag, and will thus work only >= Unity 2019.3</para>
            
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129381917/Transform+Tracker+-+Follow+another+Transform+hierarchy+independent"> Documentation </a></para>
            
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version 
               ver="1.0.0" 
                author="PWS" 
                date="200606">
                Implemented for the new DSplineControlpoint functionalities but implemented for generic use - This class allows you to easily add a snippet to your component to track another transform position and rotation
            </version>
            <testing>
            [None]
            </testing>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.TrackTransformRotation">
            <summary>
            Whether to Follow the rotation of the transform
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.TrackTransformTranslation">
            <summary>
            Whether to Follow the translation of the transform
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.TrackingIsActive">
            <summary>
            Whether the Transform tracking is currently active
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.minimumResponseTranslation">
            <summary>
            The minimum response distance before forcing a resync
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.minimumResponseAngle">
            <summary>
            The minimum response angle before forcing a resync
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.TransformToTrack">
            <summary>
            Transform set for following around
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.BufferedRotation">
            <summary>
            The Last Tracked Rotation
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.BufferedTranslation">
            <summary>
            The Last Tracked Position
            </summary>
        </member>
        <member name="M:u040.prespective.utility.scenemanagement.TransformTracker.TrackedTransformHasChanged(UnityEngine.Transform,UnityEngine.Vector3@,UnityEngine.Quaternion@)">
            <summary>
            Determine whether the followed transform has changed
            </summary>
            <param name="_newPosition"></param>
            <param name="_newRotation"></param>
            <returns></returns>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.NAN_QUATERNION">
            <summary>
            Default NAN Quaternion
            </summary>
        </member>
        <member name="F:u040.prespective.utility.scenemanagement.TransformTracker.NAN_VECTOR3">
            <summary>
            Default NaN Vector
            </summary>
        </member>
        <member name="M:u040.prespective.utility.buildmanagement.ScriptingBackendUtility.IsIL2CPP">
            <summary>
            Check if scripting backend is il2cpp
            </summary>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.versionmanagement.RegistryUtility">
            <summary>
            Helper functions for saving values to the registry
            <para>Copyright (c) 2015-2023 Prespective, Unit040 Beheer B.V. All Rights Reserved. See License.txt in the project Prespective folder for license information.</para>
            </summary>
        </member>
        <member name="M:u040.prespective.utility.versionmanagement.RegistryUtility.WriteKeyValueCurrentUser(System.String,System.String,System.String,System.Object)">
            <summary>
            Write to specific current user registry path
            </summary>
            <param name="_appName">Application Name</param>
            <param name="_appVersion">Version</param>
            <param name="_key">Registry Key</param>
            <param name="_value">Value to write</param>
        </member>
        <member name="M:u040.prespective.utility.versionmanagement.RegistryUtility.ReadKeyValueCurrentUser(System.String,System.String,System.String)">
            <summary>
            Read from specific current user registry path
            </summary>
            <param name="_appName">Application Name</param>
            <param name="_appVersion">Version</param>
            <param name="_key">Registry Key</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.versionmanagement.RegistryUtility.ClearKeyValueCurrentUser(System.String,System.String,System.String)">
            <summary>
            Clear a key from a specific current user registry path
            </summary>
            <param name="_appName">Application Name</param>
            <param name="_appVersion">Application Version</param>
            <param name="_key">Registry Key</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.versionmanagement.RegistryUtility.RemoveKeyCurrentUser(System.String,System.String,System.String)">
            <summary>
            Remove a key from a specific current user registry path
            </summary>
            <param name="_appName">Application Name</param>
            <param name="_appVersion">Application Version</param>
            <param name="_key">Registry Key</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.versionmanagement.EncryptionUtility">
            <summary>
            @CLASS : License
            
            @ABOUT : Encryption Utils based on https://stackoverflow.com/questions/10168240/encrypting-decrypting-a-string-in-c-sharp
            
            @AUTHOR: Bas Botermans (Unit040)
            
            @VERSION:   v1.0 - 11/07/2019 - Added try/catch block
                        
                                           
            
            </summary>
        </member>
        <member name="M:u040.prespective.utility.versionmanagement.EncryptionUtility.Encrypt(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_plainText"></param>
            <param name="_passPhrase"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.versionmanagement.EncryptionUtility.Decrypt(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_cipherText"></param>
            <param name="_passPhrase"></param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.versionmanagement.SemanticVersion">
            <summary>
            Versioning conform:
            https://semver.org/
            </summary>
        </member>
        <member name="T:u040.prespective.utility.versionmanagement.TimeUtility">
            <summary>
            Helper static library class for network time operations
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version 
                ver="1.0.0" 
                author="BBS" 
                date="190711">
                - Added comments
            </version>
        </member>
        <member name="M:u040.prespective.utility.versionmanagement.TimeUtility.GetNtpDateTime(System.String)">
            <summary>
            Return the NTP datetime from the given server
            </summary>
            <param name="_ntpServer">NTP Timeserver as string i.e. time.nist.gov</param>
            <returns>Current DateTime</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.versionmanagement.TimeUtility.SwapEndianness(System.UInt64)" -->
        <member name="T:u040.prespective.utility.exceptions.InvalidCharacterException">
            <summary>
            Exception used when running into a character in a string that is not be allowed in the current context.
            </summary>
        </member>
        <member name="M:u040.prespective.utility.exceptions.InvalidCharacterException.#ctor">
            <summary>
            Throws InvalidCharacterException with only the default message.
            </summary>
        </member>
        <member name="M:u040.prespective.utility.exceptions.InvalidCharacterException.#ctor(System.String)">
            <summary>
            Throws InvalidCharacterException with default message and additional message.
            </summary>
            <param name="_message">Additional message to be shown to the user.</param>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.getGlobalScale(UnityEngine.Transform)">
            <summary>
            Get the global scale of a transform target in double precision
            </summary>
            <param name="_target"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.recurseToGlobalScale(UnityEngine.Transform,u040.prespective.math.doubles.DVector3@)">
            <summary>
            Recursor (support) function to get the global scale of a transform 
            </summary>
            <param name="_target"></param>
            <param name="_localscale"></param>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.TransformVector(u040.prespective.math.doubles.DVector3,UnityEngine.Transform,UnityEngine.Transform,System.Boolean)">
            <summary>
            Transform a vector from transform A to Transform B, accounting for rotation and scale in double precision
            </summary>
            <param name="_localVectorInFrom">the local starting vector</param>
            <param name="_from">the transform in whos' space to local starting vector is defined</param>
            <param name="_to">the transform in whos' space the local starting vector should be resolved</param>
            <param name="_considerScale">whether scale should be considered (default = true)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.TransformVector(u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,u040.prespective.math.doubles.DVector3,UnityEngine.Transform,UnityEngine.Transform,System.Boolean)">
            <summary>
            Transform a vector from a arbitrary fwd and up dir in transform A to an arbitrary fwd and up dir in Transform B, accounting for rotation and scale in double precision
            </summary>
            <param name="_localVectorInFrom">the local starting vector in space A</param>
            <param name="_fromForwardDir"></param>
            <param name="_fromUpDir"></param>
            <param name="_toForwardDir"></param>
            <param name="_toUpDir"></param>
            <param name="_fromOwner"></param>
            <param name="_toOwner"></param>
            <param name="_considerScale"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.TransformRotation(u040.prespective.math.doubles.DQuaternion,UnityEngine.Transform,UnityEngine.Transform,System.Boolean)">
            <summary>
            Default unity rotation conversion doesn't consider scale :(; so do that here
            </summary>
            <param name="_rotation"></param>
            <param name="_from"></param>
            <param name="_to"></param>
            <param name="_considerScale"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.getOrCreateDirectChild(System.String,UnityEngine.Transform)">
            <summary>
            Retrieves, or otherwise creates, a direct child object with name '_name'
            </summary>
            <param name="_name">the child to look for</param>
            <param name="_parent">the parent transform</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.deisolateAllTransforms(UnityEngine.Transform)">
            <summary>
            Force all transforms in the scene active (quick fix for lost isolation context)
            </summary>
            <param name="_parent"></param>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.isolateTransforms(System.Collections.Generic.List{UnityEngine.Transform},System.Boolean,System.Collections.Generic.List{UnityEngine.Transform}@,System.Type[],System.Action{System.Collections.Generic.List{UnityEngine.Transform}})">
            <summary>
            set the selected transforms as isolated
            </summary>
            <param name="_toIsolate">the list of transforms to isolate</param>
            <param name="_setIsolated">whether or not to activate or deactivate isolation</param>
            <param name="_affectedByIsolation">list of transforms allready affected by isolation</param>
            <param name="_containersWithComponentToIgnore">the components to ignore in isolation</param>
            <param name="_doBeforeApply">action to run before Isolation is applied</param>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.isolateTransformsFromParents(System.Collections.Generic.List{UnityEngine.Transform},System.Boolean,System.Collections.Generic.List{UnityEngine.Transform}@,System.Type[],System.Action{System.Collections.Generic.List{UnityEngine.Transform}},System.Boolean)">
            <summary>
            set the selected transforms as isolated through its parents
            </summary>
            <param name="_toIsolate">the list of transforms to isolate</param>
            <param name="_setIsolated">whether or not to activate or deactivate isolation</param>
            <param name="_effectedByIsolation">list of transforms all ready affected by isolation</param>
            <param name="_containersWithComponentToIgnore">the components to ignore in isolation</param>
            <param name="_doBeforeApply">action to run before Isolation is applied</param>
            <param name="_keepChildrenActive">if children of objects are turned off</param>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.getSceneTransformsAffected(UnityEngine.Transform,System.Func{UnityEngine.Transform,System.Boolean},System.Collections.Generic.List{UnityEngine.Transform}@)">
            <summary>
            recurrent function to batch test all transforms contained in current
            </summary>
            <param name="_current">the current transform</param>
            <param name="_test">the test to perform</param>
            <param name="_affectedTransforms">the resulting list of this operation</param>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.processTransformTurnHighestPossibleParentsOff(UnityEngine.Transform,System.Collections.Generic.List{System.Collections.Generic.List{UnityEngine.Transform}},System.Int32,System.Boolean)">
            <summary>
            process a single transform for turning off highest possible parent
            </summary>
            <param name="_transformToProcess">transform</param>
            <param name="_parentsStructuresIsolatedObjects">parental structure to use for processing</param>
            <param name="_depthLevel">depth level in parental structure</param>
            <param name="_keepChildrenActive">if children of objects are turned off</param>
            <returns>turned off transforms</returns>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.getTransformMeshBounds(UnityEngine.Transform,System.Boolean)">
            <summary>
            Retrieves the World-aligned boundary description of all Meshes combined within the target transform
            </summary>
            <param name="_target">the transform to consider all meshes for</param>
            <param name="_considerHiddenParts">whether to also consider meshes that have been set hidden</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.getAllContainedMeshFilters(System.Collections.Generic.List{UnityEngine.MeshFilter}@,UnityEngine.Transform)">
            <summary>
            Returns all contained meshfilters within a transform (recursive)
            </summary>
            <param name="_fndMeshes"></param>
            <param name="_base"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.uTransformOps.getPathAndIndexToParent(UnityEngine.Transform,UnityEngine.Transform,System.String,System.String,System.Char)" -->
        <member name="M:u040.prespective.utility.uTransformOps.ScalingFromToTransforms(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Get the scaling (Vector3) required to get from transform <paramref name="_t1"/> to transform <paramref name="_t2"/>
            If <paramref name="_t2"/> is left blank, scaling to the world is calculated
            </summary>       
        </member>
        <member name="M:u040.prespective.utility.uTransformOps.InvScalingFromToTransforms(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Get the scaling (Vector3) required to get from transform <paramref name="_t2"/> to transform <paramref name="_t1"/>
            If <paramref name="_t2"/> is left blank, scaling from the world is calculated
            </summary>  
        </member>
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.uTransformOps.getHierarchyDepth(UnityEngine.Transform,UnityEngine.Transform)" -->
        <!-- Badly formed XML comment ignored for member "M:u040.prespective.utility.uTransformOps.getDepth(UnityEngine.Transform,UnityEngine.Transform,System.Int32)" -->
        <member name="T:u040.prespective.utility.Int2">
            <summary>
            
            </summary>
        </member>
        <member name="F:u040.prespective.utility.Int2.X">
            <summary>
            
            </summary>
        </member>
        <member name="F:u040.prespective.utility.Int2.Y">
            <summary>
            
            </summary>
        </member>
        <member name="M:u040.prespective.utility.Int2.#ctor(System.Int32,System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="_x"></param>
            <param name="_y"></param>
        </member>
        <member name="M:u040.prespective.utility.Int2.op_Subtraction(u040.prespective.utility.Int2,u040.prespective.utility.Int2)">
            <summary>
            
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.op_Addition(u040.prespective.utility.Int2,u040.prespective.utility.Int2)">
            <summary>
            
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.op_Multiply(System.Int32,u040.prespective.utility.Int2)">
            <summary>
            
            </summary>
            <param name="_a"></param>
            <param name="_b"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.op_Multiply(u040.prespective.utility.Int2,System.Int32)">
            <summary>
            
            </summary>
            <param name="_b"></param>
            <param name="_a"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.GetHashCode">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.op_Equality(u040.prespective.utility.Int2,u040.prespective.utility.Int2)">
            <summary>
            
            </summary>
            <param name="_c1"></param>
            <param name="_c2"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.op_Inequality(u040.prespective.utility.Int2,u040.prespective.utility.Int2)">
            <summary>
            
            </summary>
            <param name="_c1"></param>
            <param name="_c2"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.Equals(System.Object)">
            <summary>
            
            </summary>
            <param name="_obj"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.Int2.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.modelmanagement.RequireComponentExtension">
            <summary>
            Static library class with extension methods for the Component class to make sure dependant instances exist
            
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129447434/RequireComponentExtension+-+Auto-find+and+assign+a+valid+required+type+instance"> Documentation </a></para>
            
            <para>Copyright (c) Prespective, Unit040 BV. All Rights Reserved. See License.txt in the project root for license information.</para>
            </summary>
            <version 
                ver="1.0.0" 
                author="MVN" 
                date="200101">
            </version>
            <testing>
            [None]
            </testing>
        </member>
        <member name="M:u040.prespective.utility.modelmanagement.RequireComponentExtension.RequireComponent``1(UnityEngine.Component,System.Boolean,System.Boolean)">
            <summary>
            This method returns the first component of type T found. If none are found, the component is created and returned. 
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129447434/RequireComponentExtension+-+Auto-find+and+assign+a+valid+required+type+instance"> Documentation </a></para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_targetComponent">The component that requires the given component</param>
            <param name="_includeChildren">Whether to include children when looking for the given component</param>
            <param name="_createOnNewChild">Whether to create a new child object when creating a new component</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.modelmanagement.RequireComponentExtension.RequireComponent``1(UnityEngine.GameObject,System.Boolean,System.Boolean)">
            <summary>
            This method returns the first component of type T found. If none are found, the component is created and returned. 
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129447434/RequireComponentExtension+-+Auto-find+and+assign+a+valid+required+type+instance"> Documentation </a></para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_targetGameObject">The GameObject that requires the given component</param>
            <param name="_includeChildren">Whether to include children when looking for the given component</param>
            <param name="_createOnNewChild">Whether to create a new child object when creating a new component</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.modelmanagement.RequireComponentExtension.RequireComponent``1(UnityEngine.Component,System.Type,System.Boolean,System.Boolean)">
            <summary>
            This method returns the first component of type T found. If none are found, the component is created and returned. 
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129447434/RequireComponentExtension+-+Auto-find+and+assign+a+valid+required+type+instance"> Documentation </a></para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_targetComponent">The component that requires the given component</param>
            <param name="_type">type of component</param>
            <param name="_includeChildren">Whether to include children when looking for the given component</param>
            <param name="_createOnNewChild">Whether to create a new child object when creating a new component</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.modelmanagement.RequireComponentExtension.RequireComponent``1(UnityEngine.GameObject,System.Type,System.Boolean,System.Boolean)">
            <summary>
            This method returns the first component of type T found. If none are found, the component is created and returned. 
            <para><a href="https://unit040.atlassian.net/wiki/spaces/PAD/pages/1129447434/RequireComponentExtension+-+Auto-find+and+assign+a+valid+required+type+instance"> Documentation </a></para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_targetGameObject">The GameObject that requires the given component</param>
            <param name="_type">type of component</param>
            <param name="_includeChildren">Whether to include children when looking for the given component</param>
            <param name="_createOnNewChild">Whether to create a new child object when creating a new component</param>
            <returns></returns>
        </member>
        <member name="T:u040.prespective.utility.editormanagement.EditorEventForwardingRegistry">
            <summary>
            Class to inherit for Assembly specific Event Forwarding
            </summary>
        </member>
        <member name="T:u040.prespective.utility.editormanagement.EditorEventForwardingItem">
            <summary>
            Single Event Forwarding Item Registration
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editormanagement.EditorEventForwardingItem.MonoType">
            <summary>
            The Type to look for, inheriting monobehavior
            </summary>
        </member>
        <member name="F:u040.prespective.utility.editormanagement.EditorEventForwardingItem.OnScriptReloaded">
            <summary>
            Callback made after the script was reloaded
            </summary>
        </member>
        <member name="T:u040.prespective.utility.uStringOps">
            <summary>
            
            </summary>
        </member>
        <member name="F:u040.prespective.utility.uStringOps.HTML_ENCODING">
            <summary>
            HTML encoding symbols as described in:
            https://www.web2generators.com/html-based-tools/online-html-entities-encoder-and-decoder
            </summary>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.BatchReplace(System.String,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Replaces multiple target keywords in a string with the attributed values
            </summary>
            <param name="_in">the input string</param>
            <param name="_replacements">a dictionary describing the replacements; keys are looked up - values are the replacement value</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.HasNumericSuffix(System.String,System.Int32@,System.String@)">
            <summary>
            Whether the string has a numeric suffix
            </summary>
            <param name="_value">the string value to check</param>
            <param name="_number">the number found as suffix</param>
            <param name="_prefix">the prefix (not part of the number part)</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.LimitTextLinesSplit(System.String,System.Int32)">
            <summary>
            Limits a text to _maxLines, if it exceeds this number the first lines are removed
            NOTE: this method was found to be about 30% faster than the regex method when keeping a string maxed at 150 lines
            </summary>
            <param name="_in">the input string</param>
            <param name="_maxLines">the maximum number of lines</param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.LimitTextLinesRegex(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <param name="_maxLines"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.GetNoOfLines(System.String,System.Text.RegularExpressions.MatchCollection@)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <param name="_lineBreaks"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.SplitTextByPage(System.String,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="_text"></param>
            <param name="_charsPerLine"></param>
            <param name="_linesPerPage"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.SplitTextByLine(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.Boolean}@,System.Int32)">
            <summary>
            Splits the provided text by lines through both checking for linebreaks and # of characters per line
            On a soft linebreak (i.e. too many characters on a single line, preference is given to splitting on the last word(-end))
            but if the line is build up out of a single word (i.e. no spaces found) a seperator is inserted ('-')
            </summary>
            <param name="_text">the text to split by lines</param>
            <param name="_sByLines">the list with strings returned (split by lines, with a maximum of _charsPerLine)</param>
            <param name="_hardLineBreak">a list matchin the list with strings returned, explaining whether the line has a hard linebreak</param>
            <param name="_charsPerLine">the maximum number of characters per line</param>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.FindLineBreaks(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_oString"></param>
            <param name="_ignoreTrailing"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.FindSubStringOccurance(System.String,System.String,System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            
            </summary>
            <param name="_oString"></param>
            <param name="_sString"></param>
            <param name="_fnds"></param>
            <param name="_sSLoffset"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.CountSubstringOccurance(System.String,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="_oString"></param>
            <param name="_sString"></param>
            <param name="_cBuffer"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.SplitByString(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <param name="_splitter"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.ReplaceString(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <param name="_substring"></param>
            <param name="_replace"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.SplitByEnvelopingChar(System.String,System.Collections.Generic.List{System.String}@,System.Int32@,System.Char,System.Char,System.Boolean)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <param name="_excessBetween"></param>
            <param name="_maxDepth"></param>
            <param name="_cIn"></param>
            <param name="_cOut"></param>
            <param name="_addExternalExcess"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.SplitByOperators(System.String,System.String@)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <param name="_operator"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.IsNumericOp(System.String)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.SplitByCommandOperators(System.String)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.uStringOps.StringQueryTest(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="_in"></param>
            <param name="_operator"></param>
            <param name="_soughtvalue"></param>
            <returns></returns>
        </member>
        <member name="M:u040.prespective.utility.StringHelper.ToTitleCase(System.String)">
            <summary>
            Convert every first letter of a word to upper case
            Based on: http://stackoverflow.com/questions/4135317/make-first-letter-of-a-string-upper-case-for-maximum-performance
            </summary>
            <param name="str">the input string to convert</param>
            <returns>string with every first letter of a word upper cased</returns>
        </member>
        <member name="M:u040.prespective.utility.StringHelper.ToTitleCase(System.String,u040.prespective.utility.TitleCase)">
            <summary>
            Convert the first letter to upper-case (and the rest to lower case)
            Based on the enum TitleCase either every word in the string gets a upper-case first letter, or only the first word
            Based on: http://stackoverflow.com/questions/4135317/make-first-letter-of-a-string-upper-case-for-maximum-performance
            </summary>
            <param name="str">the input string to convert</param>
            <param name="tcase">whether to upper-case the first letter in all words in the string, or only the first</param>
            <returns>the converted string</returns>
        </member>
        <member name="T:u040.prespective.utility.TitleCase">
            <summary>
            
            </summary>
        </member>
        <member name="M:UnityEngine.Vector2Extension.Rotate(UnityEngine.Vector2,System.Single)">
            <summary>
            Rotate a given Vector2
            </summary>
            <param name="_vector">Vector2 to rotate</param>
            <param name="_angle">Amount of degrees to rotate</param>
            <returns>The Vector2 after being rotated</returns>
        </member>
        <member name="M:UnityEngine.UnityEventExtension.RefreshListener(UnityEngine.Events.UnityEvent,UnityEngine.Events.UnityAction)">
            <summary>
            Extension method to UnityEvent. Removes and (re)Adds a call to a UnityEvent.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_unityEvent"></param>
            <param name="_call"></param>
        </member>
        <member name="M:UnityEngine.UnityEventExtension.RefreshListener``1(UnityEngine.Events.UnityEvent{``0},UnityEngine.Events.UnityAction{``0})">
            <summary>
            Extension method to UnityEvent. Removes and (re)Adds a call to a UnityEvent.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_unityEvent"></param>
            <param name="_call"></param>
        </member>
        <member name="M:UnityEngine.UnityEventExtension.RefreshListener``2(UnityEngine.Events.UnityEvent{``0,``1},UnityEngine.Events.UnityAction{``0,``1})">
            <summary>
            Extension method to UnityEvent. Removes and (re)Adds a call to a UnityEvent.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="_unityEvent"></param>
            <param name="_call"></param>
        </member>
        <member name="M:UnityEngine.UnityEventExtension.RefreshListener``3(UnityEngine.Events.UnityEvent{``0,``1,``2},UnityEngine.Events.UnityAction{``0,``1,``2})">
            <summary>
            Extension method to UnityEvent. Removes and (re)Adds a call to a UnityEvent.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <param name="_unityEvent"></param>
            <param name="_call"></param>
        </member>
        <member name="M:UnityEngine.UnityEventExtension.RefreshListener``4(UnityEngine.Events.UnityEvent{``0,``1,``2,``3},UnityEngine.Events.UnityAction{``0,``1,``2,``3})">
            <summary>
            Extension method to UnityEvent. Removes and (re)Adds a call to a UnityEvent.
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <param name="_unityEvent"></param>
            <param name="_call"></param>
        </member>
    </members>
</doc>
